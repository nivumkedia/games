<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sushi Stack - Multiplayer Math Game!</title>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            min-height: 100vh;
            background: #1e1e3a;
            overflow: auto;
            position: relative;
        }

        /* Animated background canvas */
        #bgCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        /* Main container */
        .game-container {
            width: 100vw;
            min-height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
            z-index: 1;
        }

        /* Header */
        .header {
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.12);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 100;
        }

        .game-title {
            font-size: 1.8rem;
            font-weight: 900;
            background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #a55eea);
            background-size: 300% 300%;
            animation: gradientShift 4s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .turn-info {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .round-display {
            font-size: 1.1rem;
            color: #d4a5ff;
            font-weight: 800;
            background: rgba(165, 94, 234, 0.25);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 12px;
            border: 1px solid rgba(165, 94, 234, 0.3);
        }

        .current-player {
            font-size: 1.2rem;
            color: #fff;
            font-weight: 700;
        }

        .current-player .player-name {
            padding: 5px 15px;
            border-radius: 20px;
            margin-left: 10px;
        }

        .timer-display {
            font-size: 2rem;
            font-weight: 900;
            color: #feca57;
            min-width: 80px;
            text-align: center;
            text-shadow: 0 0 20px rgba(254, 202, 87, 0.5);
        }

        .timer-display.warning {
            color: #ff6b6b;
            animation: pulse 0.5s infinite;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.7);
        }

        .end-game-btn {
            padding: 8px 16px;
            font-size: 0.9rem;
            font-weight: 700;
            background: rgba(255, 107, 107, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 107, 107, 0.4);
            border-radius: 10px;
            color: #ff6b6b;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        .end-game-btn:hover {
            background: rgba(255, 107, 107, 0.3);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        /* Player scores */
        .player-scores {
            display: flex;
            gap: 15px;
        }

        .player-score {
            padding: 10px 20px;
            border-radius: 15px;
            text-align: center;
            color: #fff;
            font-weight: 700;
            opacity: 0.6;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-score.active {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.4), 0 0 15px rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .player-score .name {
            font-size: 0.85rem;
            margin-bottom: 5px;
        }

        .player-score .score {
            font-size: 1.5rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        /* Game stage */
        .game-stage {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        /* Main game area - zoomed in view */
        .game-main {
            display: flex;
            align-items: center;
            gap: 40px;
        }

        /* Sushi viewport - shows only current area */
        .sushi-viewport {
            width: 800px;
            height: 900px;
            overflow: hidden;
            position: relative;
            border-radius: 24px;
            background: #252550;
            border: 2px solid #3a3a6e;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4), inset 0 0 80px rgba(100, 100, 200, 0.03);
        }

        /* Sushi tower */
        .sushi-tower {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            transition: transform 0.5s ease-out;
            will-change: transform;
        }

        .sushi-platform {
            position: relative;
            width: 400px;
            height: 250px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1;
        }

        .sushi-platform svg {
            width: 200px;
            height: 160px;
            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        .sushi-platform.current {
            transform: scale(1.15);
            animation: currentGlow 2s ease-in-out infinite;
        }

        .sushi-platform.current svg {
            filter: drop-shadow(0 0 20px rgba(254, 202, 87, 0.5)) drop-shadow(0 4px 8px rgba(0,0,0,0.3));
        }

        @keyframes currentGlow {
            0%, 100% { transform: scale(1.15); }
            50% { transform: scale(1.2); }
        }

        .sushi-platform.completed {
            opacity: 0.35;
        }

        .sushi-platform.completed svg {
            filter: saturate(0.5) drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        .sushi-platform.collapsing {
            animation: collapse 0.3s ease-out forwards;
        }

        @keyframes collapse {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(0.3) rotate(180deg);
                opacity: 0;
            }
        }

        .sushi-platform.locked {
            opacity: 0.15;
        }

        .sushi-platform.locked svg {
            filter: grayscale(0.9) blur(1px);
        }

        /* Character */
        .character {
            position: absolute;
            left: 50%;
            bottom: auto;
            transform: translateX(-50%);
            z-index: 10;
            transition: bottom 0.3s;
            width: 120px;
            height: 140px;
        }

        .character svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.5));
        }

        .character.walking {
            animation: walk 0.3s ease-in-out infinite;
        }

        @keyframes walk {
            0%, 100% { transform: translateX(-50%) translateY(0) rotate(-5deg); }
            50% { transform: translateX(-50%) translateY(-10px) rotate(5deg); }
        }

        .character.falling {
            animation: fall 1s ease-in forwards;
        }

        @keyframes fall {
            0% { transform: translateX(-50%) translateY(0) rotate(0deg); }
            100% { transform: translateX(-50%) translateY(500px) rotate(720deg); opacity: 0; }
        }

        .character.sliding {
            transition: bottom 1.5s cubic-bezier(0.6, 0.0, 0.8, 0.2);
            animation: tumble 1.5s ease-out;
        }

        @keyframes tumble {
            0% { transform: translateX(-50%) rotate(0deg); }
            100% { transform: translateX(-50%) rotate(720deg); }
        }

        .character.celebrating {
            animation: celebrate 0.5s ease-in-out infinite;
        }

        @keyframes celebrate {
            0%, 100% { transform: translateX(-50%) translateY(0) scale(1); }
            50% { transform: translateX(-50%) translateY(-20px) scale(1.2); }
        }

        /* Tower shake */
        .sushi-tower.shaking {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-20px) rotate(-2deg); }
            40% { transform: translateX(20px) rotate(2deg); }
            60% { transform: translateX(-15px) rotate(-1deg); }
            80% { transform: translateX(15px) rotate(1deg); }
        }

        /* Completed stacks display */
        .completed-stacks {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 50;
        }

        .completed-stack {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(38, 222, 129, 0.15);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(38, 222, 129, 0.4);
            border-radius: 15px;
            padding: 10px;
            animation: stackComplete 0.5s ease-out;
            box-shadow: 0 5px 20px rgba(38, 222, 129, 0.2);
        }

        @keyframes stackComplete {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        .completed-stack .stack-sushi {
            display: flex;
            flex-direction: column-reverse;
            font-size: 0.9rem;
            line-height: 1;
        }

        .completed-stack .stack-label {
            color: #26de81;
            font-size: 0.7rem;
            font-weight: 700;
            margin-top: 5px;
            text-shadow: 0 0 10px rgba(38, 222, 129, 0.5);
        }

        /* Ground/plate - enhanced wooden plate */
        .plate {
            width: 160px;
            height: 20px;
            background: linear-gradient(180deg, #c6956e 0%, #8B4513 40%, #654321 100%);
            border-radius: 50%;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.6), 0 2px 5px rgba(198, 149, 110, 0.3), inset 0 -2px 4px rgba(0, 0, 0, 0.3);
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Inline equation panel */
        .equation-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        .equation-display {
            font-size: 3rem;
            font-weight: 900;
            color: #fff;
            text-align: center;
            text-shadow: 0 2px 15px rgba(0, 0, 0, 0.4), 0 0 40px rgba(255, 255, 255, 0.1);
        }

        .equation-display .operator {
            color: #feca57;
            text-shadow: 0 0 20px rgba(254, 202, 87, 0.5);
        }

        .inline-input {
            font-size: 2.5rem;
            font-weight: 700;
            padding: 15px 25px;
            width: 150px;
            text-align: center;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            color: #fff;
            outline: none;
            transition: all 0.3s;
        }

        .inline-input:focus {
            border-color: #48dbfb;
            box-shadow: 0 0 30px rgba(72, 219, 251, 0.4), 0 0 60px rgba(72, 219, 251, 0.15);
        }

        .inline-input.correct {
            border-color: #26de81;
            background: rgba(38, 222, 129, 0.2);
            box-shadow: 0 0 30px rgba(38, 222, 129, 0.4);
        }

        .inline-input.wrong {
            border-color: #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.4);
        }

        .input-hint {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }

        /* Height progress */
        .height-progress {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .height-number {
            font-size: 2.5rem;
            font-weight: 900;
            color: #feca57;
            text-shadow: 0 0 20px rgba(254, 202, 87, 0.5);
        }

        .height-label {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Math problem overlay - HIDDEN (not used anymore) */
        .problem-overlay {
            display: none !important;
        }

        .problem-card {
            background: linear-gradient(135deg, #2d2d44 0%, #1a1a2e 100%);
            padding: 50px 80px;
            border-radius: 30px;
            text-align: center;
            border: 3px solid rgba(255, 255, 255, 0.1);
            transform: scale(0.8);
            transition: transform 0.3s;
        }

        .problem-overlay.show .problem-card {
            transform: scale(1);
        }

        .problem-sushi {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        .problem-text {
            font-size: 2.8rem;
            font-weight: 900;
            color: #fff;
            margin-bottom: 30px;
            line-height: 1.3;
        }

        .problem-text .operator {
            color: #feca57;
            margin: 0 10px;
        }

        .problem-input {
            font-size: 3rem;
            font-weight: 700;
            padding: 15px 30px;
            width: 200px;
            text-align: center;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            outline: none;
            transition: all 0.3s;
        }

        .problem-input:focus {
            border-color: #48dbfb;
            box-shadow: 0 0 30px rgba(72, 219, 251, 0.3);
        }

        .problem-hint {
            color: #888;
            margin-top: 20px;
            font-size: 1rem;
        }

        /* Start screen */
        .screen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1e1e3a;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300;
            transition: opacity 0.5s, visibility 0.5s;
            overflow-y: auto;
        }

        .screen-overlay.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .screen-content {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }

        .screen-title {
            font-size: 3.5rem;
            font-weight: 900;
            background: linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #a55eea);
            background-size: 300% 300%;
            animation: gradientShift 4s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 20px;
        }

        .screen-sushi {
            font-size: 5rem;
            margin-bottom: 30px;
            animation: floatSushi 3s ease-in-out infinite;
        }

        @keyframes floatSushi {
            0%, 100% { transform: translateY(0) rotate(-3deg); }
            33% { transform: translateY(-15px) rotate(3deg); }
            66% { transform: translateY(-5px) rotate(-1deg); }
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .screen-subtitle {
            color: rgba(255, 255, 255, 0.75);
            font-size: 1.2rem;
            margin-bottom: 40px;
        }

        /* Player setup */
        .player-setup {
            margin-bottom: 40px;
        }

        .setup-label {
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
            margin-bottom: 15px;
            display: block;
        }

        .player-count-btns {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }

        .count-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 1.5rem;
            font-weight: 800;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
        }

        .count-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(72, 219, 251, 0.3);
        }

        .count-btn.selected {
            border-color: #48dbfb;
            background: rgba(72, 219, 251, 0.25);
            box-shadow: 0 0 25px rgba(72, 219, 251, 0.4);
        }

        .solo-mode-hint {
            color: #feca57;
            font-size: 1rem;
            font-weight: 700;
            margin-top: 10px;
            animation: pulse 2s infinite;
            text-shadow: 0 0 15px rgba(254, 202, 87, 0.5);
        }

        .player-names {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }

        .player-name-input {
            display: flex;
            align-items: center;
            gap: 15px;
            justify-content: center;
        }

        .player-avatar {
            width: 50px;
            height: 58px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            overflow: hidden;
        }

        .player-avatar svg {
            width: 100%;
            height: 100%;
        }

        .player-name-input input {
            padding: 12px 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.15);
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 1.1rem;
            font-family: inherit;
            width: 200px;
            outline: none;
            transition: all 0.3s;
        }

        .player-name-input input:focus {
            border-color: #48dbfb;
            box-shadow: 0 0 20px rgba(72, 219, 251, 0.3);
        }

        /* Difficulty buttons */
        .difficulty-btns {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .diff-btn {
            padding: 15px 20px;
            border: 2px solid rgba(255, 255, 255, 0.12);
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            min-width: 100px;
        }

        .diff-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        .diff-btn.selected {
            border-color: #feca57;
            background: rgba(254, 202, 87, 0.15);
            box-shadow: 0 5px 25px rgba(254, 202, 87, 0.3), inset 0 0 20px rgba(254, 202, 87, 0.05);
        }

        .diff-icon {
            font-size: 1.8rem;
        }

        .diff-name {
            color: #fff;
            font-weight: 700;
            font-size: 1rem;
        }

        .diff-desc {
            color: #888;
            font-size: 0.75rem;
        }

        .diff-btn[data-diff="easy"] .diff-name { color: #26de81; }
        .diff-btn[data-diff="medium"] .diff-name { color: #48dbfb; }
        .diff-btn[data-diff="hard"] .diff-name { color: #feca57; }
        .diff-btn[data-diff="brutal"] .diff-name { color: #e17055; }
        .diff-btn[data-diff="insane"] .diff-name { color: #ff6b6b; }
        .diff-btn[data-diff="custom"] .diff-name { color: #a55eea; }
        .diff-btn[data-diff="perplayer"] .diff-name { color: #fd79a8; }

        /* Custom difficulty slider */
        .custom-diff-container {
            margin-top: 20px;
            padding: 20px;
            background: rgba(165, 94, 234, 0.1);
            border-radius: 15px;
            border: 2px solid rgba(165, 94, 234, 0.3);
        }

        .slider-label {
            color: #fff;
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 15px;
        }

        .slider-label span {
            color: #a55eea;
            font-size: 1.5rem;
        }

        .diff-slider {
            width: 100%;
            height: 12px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .diff-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a55eea, #8854d0);
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(165, 94, 234, 0.5);
            transition: transform 0.2s;
        }

        .diff-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .diff-slider::-moz-range-thumb {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: linear-gradient(135deg, #a55eea, #8854d0);
            cursor: pointer;
            border: none;
            box-shadow: 0 4px 15px rgba(165, 94, 234, 0.5);
        }

        .slider-labels {
            display: flex;
            justify-content: space-between;
            color: #888;
            font-size: 0.8rem;
            margin-top: 10px;
        }

        /* Per-player difficulty selector */
        .player-diff-select {
            padding: 8px 12px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 0.9rem;
            font-family: inherit;
            cursor: pointer;
            outline: none;
            min-width: 90px;
        }

        .player-diff-select:focus {
            border-color: #fd79a8;
        }

        .player-diff-select option {
            background: #1a1a2e;
            color: #fff;
        }

        .start-btn {
            padding: 20px 60px;
            font-size: 1.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, #ff6b6b, #ff9a56, #feca57);
            background-size: 200% 200%;
            animation: gradientShift 3s ease infinite;
            border: none;
            border-radius: 20px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 8px 30px rgba(255, 107, 107, 0.3);
        }

        .start-btn:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 45px rgba(255, 107, 107, 0.5);
        }

        /* Turn transition */
        .turn-transition {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(26, 26, 62, 0.95), rgba(0, 0, 0, 0.98));
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 250;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .turn-transition.show {
            opacity: 1;
            pointer-events: auto;
        }

        .turn-player-avatar {
            width: 150px;
            height: 170px;
            margin-bottom: 20px;
            animation: bounce 1s ease-in-out infinite;
        }

        .turn-player-avatar svg {
            width: 100%;
            height: 100%;
        }

        .turn-player-name {
            font-size: 2.5rem;
            font-weight: 900;
            color: #fff;
            margin-bottom: 10px;
        }

        .turn-message {
            font-size: 1.5rem;
            color: #feca57;
            margin-bottom: 30px;
        }

        .ready-btn {
            padding: 15px 50px;
            font-size: 1.3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #26de81, #20bf6b);
            border: none;
            border-radius: 15px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
            font-family: inherit;
            box-shadow: 0 8px 25px rgba(38, 222, 129, 0.3);
        }

        .ready-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(38, 222, 129, 0.5);
        }

        /* Results screen */
        .results-content {
            text-align: center;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
        }

        .results-title {
            font-size: 3rem;
            font-weight: 900;
            color: #feca57;
            margin-bottom: 30px;
        }

        .winner-display {
            margin-bottom: 40px;
        }

        .winner-avatar {
            width: 140px;
            height: 160px;
            margin: 0 auto 15px;
        }

        .winner-avatar svg {
            width: 100%;
            height: 100%;
        }

        .winner-name {
            font-size: 2.5rem;
            font-weight: 900;
            color: #fff;
            margin-bottom: 10px;
        }

        .winner-score {
            font-size: 1.5rem;
            color: #48dbfb;
        }

        .final-scores {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        .final-score-card {
            padding: 20px 25px;
            border-radius: 20px;
            text-align: center;
            min-width: 180px;
            max-width: 220px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .final-score-card .avatar {
            width: 80px;
            height: 90px;
            margin: 0 auto 10px;
        }

        .final-score-card .avatar svg {
            width: 100%;
            height: 100%;
        }

        .final-score-card .name {
            color: #fff;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .final-score-card .score {
            font-size: 1.8rem;
            font-weight: 900;
            color: #fff;
        }

        .final-score-card .height {
            color: #aaa;
            font-size: 0.9rem;
        }

        .final-score-card .rank {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .final-score-card .score-label {
            color: #aaa;
            font-size: 0.85rem;
            margin-top: -5px;
        }

        .final-score-card .stats {
            display: flex;
            gap: 15px;
            color: #888;
            font-size: 0.8rem;
            margin: 10px 0;
            justify-content: center;
        }

        .final-score-card .last-position-label,
        .final-score-card .stacks-label {
            color: #feca57;
            font-size: 0.75rem;
            margin-top: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .final-score-card .no-stacks {
            color: #666;
            font-size: 0.75rem;
            margin-top: 10px;
            font-style: italic;
        }

        /* Position tower in results */
        .position-tower {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            margin: 5px 0;
            gap: 2px;
        }

        .position-tower .pos-sushi {
            font-size: 1rem;
            line-height: 1;
        }

        .position-tower .pos-more {
            font-size: 0.7rem;
            color: #888;
        }

        /* Completed stacks display in results */
        .player-stacks {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-top: 8px;
            max-width: 200px;
        }

        .mini-stack {
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            background: rgba(38, 222, 129, 0.15);
            border: 1px solid rgba(38, 222, 129, 0.3);
            border-radius: 8px;
            padding: 5px;
            gap: 1px;
        }

        .mini-stack .mini-sushi {
            font-size: 0.7rem;
            line-height: 1;
        }

        .mini-stack .mini-more {
            font-size: 0.5rem;
            color: #888;
        }

        /* Solo mode results */
        .solo-result {
            margin-bottom: 30px;
        }

        .solo-avatar {
            width: 120px;
            height: 140px;
            margin: 0 auto 10px;
        }

        .solo-avatar svg {
            width: 100%;
            height: 100%;
        }

        .solo-name {
            font-size: 1.8rem;
            font-weight: 800;
            color: #fff;
            margin-bottom: 10px;
        }

        .solo-score-big {
            font-size: 4rem;
            font-weight: 900;
            color: #feca57;
            line-height: 1;
        }

        .solo-score-label {
            color: #888;
            font-size: 1rem;
            margin-bottom: 15px;
        }

        .new-high-score {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.5rem;
            font-weight: 900;
            animation: pulse 1s infinite;
            margin-bottom: 15px;
        }

        .solo-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin: 20px 0;
        }

        .solo-stat {
            text-align: center;
        }

        .solo-stat .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: #48dbfb;
        }

        .solo-stat .stat-label {
            color: #888;
            font-size: 0.85rem;
        }

        .stacks-section {
            margin-top: 20px;
        }

        .stacks-title {
            color: #feca57;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        .solo-stacks {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            max-width: 400px;
            margin: 0 auto;
        }

        /* Leaderboard */
        .leaderboard {
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            margin: 20px auto;
            max-width: 400px;
        }

        .leaderboard h3 {
            color: #feca57;
            font-size: 1.3rem;
            margin-bottom: 15px;
        }

        .leaderboard-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .leaderboard-entry {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.3s;
        }

        .leaderboard-entry.current {
            background: rgba(254, 202, 87, 0.2);
            border: 2px solid rgba(254, 202, 87, 0.5);
        }

        .leaderboard-entry .lb-rank {
            font-size: 1rem;
            min-width: 35px;
        }

        .leaderboard-entry .lb-name {
            flex: 1;
            color: #fff;
            font-weight: 600;
            text-align: left;
        }

        .leaderboard-entry .lb-score {
            color: #48dbfb;
            font-weight: 800;
            font-size: 1.1rem;
        }

        .leaderboard-entry .lb-diff {
            color: #888;
            font-size: 0.75rem;
            min-width: 60px;
            text-align: right;
        }

        .no-scores {
            color: #666;
            font-style: italic;
            padding: 20px;
        }

        /* Feedback flash */
        .feedback-flash {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 150;
            opacity: 0;
            transition: opacity 0.15s;
        }

        .feedback-flash.correct {
            background: radial-gradient(circle at center, rgba(38, 222, 129, 0.4), rgba(38, 222, 129, 0.1));
            opacity: 1;
        }

        .feedback-flash.wrong {
            background: radial-gradient(circle at center, rgba(255, 107, 107, 0.4), rgba(255, 107, 107, 0.1));
            opacity: 1;
        }

        /* Height indicator */
        .height-indicator {
            position: absolute;
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        .height-label {
            color: rgba(255, 255, 255, 0.7);
            font-weight: 700;
            font-size: 1rem;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            letter-spacing: 2px;
        }

        .height-value {
            font-size: 3rem;
            font-weight: 900;
            color: #feca57;
            text-shadow: 0 0 20px rgba(254, 202, 87, 0.5);
        }

        .height-unit {
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
        }

        /* Clouds decoration - hidden, replaced by canvas */
        .cloud {
            display: none;
        }

        /* Sparkle effect on correct answer */
        .sparkle-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 160;
        }

        .sparkle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: sparkleAnim 0.8s ease-out forwards;
            pointer-events: none;
        }

        @keyframes sparkleAnim {
            0% { transform: scale(0) translate(0, 0); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(0) translate(var(--tx), var(--ty)); opacity: 0; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
                padding: 10px;
            }

            .player-scores {
                flex-wrap: wrap;
                justify-content: center;
            }

            .problem-card {
                padding: 30px 40px;
                margin: 20px;
            }

            .problem-text {
                font-size: 2.5rem;
            }

            .problem-input {
                font-size: 2rem;
                width: 150px;
            }

            .screen-title {
                font-size: 2.5rem;
            }

            .height-indicator {
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="bgCanvas"></canvas>
    <div class="sparkle-container" id="sparkleContainer"></div>
    <div class="game-container">
        <!-- Header -->
        <div class="header" id="header" style="display: none;">
            <div class="game-title">Sushi Stack</div>
            <div class="turn-info">
                <div class="round-display">Round <span id="roundDisplay">1</span>/5</div>
                <div class="current-player">
                    Current: <span class="player-name" id="currentPlayerName">Player 1</span>
                </div>
                <div class="timer-display" id="timerDisplay">2:00</div>
                <button class="end-game-btn" id="endGameBtn">End Game</button>
            </div>
            <div class="player-scores" id="playerScores"></div>
        </div>

        <!-- Game stage -->
        <div class="game-stage" id="gameStage" style="display: none;">
            <!-- Completed stacks display -->
            <div class="completed-stacks" id="completedStacks"></div>

            <div class="game-main">
                <!-- Height progress -->
                <div class="height-progress">
                    <div class="height-number" id="heightValue">0</div>
                    <div class="height-label">Height</div>
                </div>

                <!-- Sushi viewport -->
                <div class="sushi-viewport">
                    <div class="sushi-tower" id="sushiTower">
                        <!-- Sushi platforms will be generated here -->
                        <div class="character" id="character">üßë‚Äçüç≥</div>
                    </div>
                    <div class="plate"></div>
                </div>

                <!-- Equation panel -->
                <div class="equation-panel">
                    <div class="equation-display" id="equationDisplay">5 + 3 <span class="operator">=</span> ?</div>
                    <input type="number" class="inline-input" id="inlineInput" placeholder="?" autofocus>
                    <div class="input-hint">Press Enter</div>
                </div>
            </div>
        </div>

        <!-- Clouds -->
        <div class="cloud" style="top: 10%; left: 5%;">‚òÅÔ∏è</div>
        <div class="cloud" style="top: 25%; right: 10%;">‚òÅÔ∏è</div>
        <div class="cloud" style="top: 40%; left: 15%;">‚òÅÔ∏è</div>
    </div>

    <!-- Math problem overlay -->
    <div class="problem-overlay" id="problemOverlay">
        <div class="problem-card">
            <div class="problem-sushi" id="problemSushi">üç£</div>
            <div class="problem-text" id="problemText">
                <span id="probNum1">5 + 3</span>
                <span class="operator">=</span>
                <span>?</span>
            </div>
            <input type="number" class="problem-input" id="problemInput" placeholder="?" autofocus>
            <div class="problem-hint">Press Enter to submit</div>
        </div>
    </div>

    <!-- Feedback flash -->
    <div class="feedback-flash" id="feedbackFlash"></div>

    <!-- Start screen -->
    <div class="screen-overlay" id="startScreen">
        <div class="screen-content">
            <div class="screen-sushi">üç£üóº</div>
            <h1 class="screen-title">Sushi Stack</h1>
            <p class="screen-subtitle">Climb the sushi tower by solving math problems!<br>Wrong answer? You fall!</p>

            <div class="player-setup">
                <span class="setup-label">How many players?</span>
                <div class="player-count-btns">
                    <button class="count-btn" data-count="1">1</button>
                    <button class="count-btn" data-count="2">2</button>
                    <button class="count-btn selected" data-count="3">3</button>
                    <button class="count-btn" data-count="4">4</button>
                </div>
                <div class="solo-mode-hint" id="soloModeHint" style="display: none;">
                    Endless mode - climb until you fall!
                </div>

                <div class="player-names" id="playerNames">
                    <!-- Generated dynamically -->
                </div>

                <span class="setup-label" style="margin-top: 25px;">Difficulty Level</span>
                <div class="difficulty-btns">
                    <button class="diff-btn" data-diff="easy">
                        <span class="diff-icon">üçô</span>
                        <span class="diff-name">Easy</span>
                        <span class="diff-desc">+ ‚àí only</span>
                    </button>
                    <button class="diff-btn selected" data-diff="medium">
                        <span class="diff-icon">üç£</span>
                        <span class="diff-name">Medium</span>
                        <span class="diff-desc">+ ‚àí √ó</span>
                    </button>
                    <button class="diff-btn" data-diff="hard">
                        <span class="diff-icon">üêô</span>
                        <span class="diff-name">Hard</span>
                        <span class="diff-desc">+ ‚àí √ó √∑ x¬≤</span>
                    </button>
                    <button class="diff-btn" data-diff="brutal">
                        <span class="diff-icon">üíÄ</span>
                        <span class="diff-name">Brutal</span>
                        <span class="diff-desc">+ ‚àí √ó √∑ x¬≤ ‚àö</span>
                    </button>
                    <button class="diff-btn" data-diff="insane">
                        <span class="diff-icon">üî•</span>
                        <span class="diff-name">INSANE</span>
                        <span class="diff-desc">Everything!</span>
                    </button>
                    <button class="diff-btn" data-diff="custom">
                        <span class="diff-icon">üéöÔ∏è</span>
                        <span class="diff-name">Custom</span>
                        <span class="diff-desc">Level 1-10</span>
                    </button>
                    <button class="diff-btn" data-diff="perplayer">
                        <span class="diff-icon">üë•</span>
                        <span class="diff-name">Per Player</span>
                        <span class="diff-desc">Individual</span>
                    </button>
                </div>

                <!-- Custom difficulty slider -->
                <div class="custom-diff-container" id="customDiffContainer" style="display: none;">
                    <div class="slider-label">Difficulty Level: <span id="customLevelDisplay">5</span></div>
                    <input type="range" class="diff-slider" id="customDiffSlider" min="1" max="10" value="5">
                    <div class="slider-labels">
                        <span>1 (Easy)</span>
                        <span>5 (Medium)</span>
                        <span>10 (Brutal)</span>
                    </div>
                </div>
            </div>

            <button class="start-btn" id="startBtn">Start Game!</button>
        </div>
    </div>

    <!-- Turn transition screen -->
    <div class="turn-transition" id="turnTransition">
        <div class="turn-player-avatar" id="turnAvatar">üßë‚Äçüç≥</div>
        <div class="turn-player-name" id="turnName">Player 1</div>
        <div class="turn-message">Your turn to climb!</div>
        <button class="ready-btn" id="readyBtn">Ready!</button>
    </div>

    <!-- Results screen -->
    <div class="screen-overlay hidden" id="resultsScreen">
        <div class="results-content">
            <h1 class="results-title">üèÜ Game Over! üèÜ</h1>
            <div class="winner-display">
                <div class="winner-avatar" id="winnerAvatar">üßë‚Äçüç≥</div>
                <div class="winner-name" id="winnerName">Player 1</div>
                <div class="winner-score">Winner with <span id="winnerScore">0</span> sushi climbed!</div>
            </div>
            <div class="final-scores" id="finalScores"></div>
            <button class="start-btn" id="playAgainBtn">Play Again!</button>
        </div>
    </div>

    <script>
        // === ANIMATED BACKGROUND ===
        const bgCanvas = document.getElementById('bgCanvas');
        const bgCtx = bgCanvas.getContext('2d');
        let bgParticles = [];
        let bgClouds = [];
        let bgStars = [];

        function resizeBgCanvas() {
            bgCanvas.width = window.innerWidth;
            bgCanvas.height = window.innerHeight;
        }
        resizeBgCanvas();
        window.addEventListener('resize', resizeBgCanvas);

        // Create stars
        for (let i = 0; i < 120; i++) {
            bgStars.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight * 0.6,
                size: Math.random() * 2.5 + 0.5,
                twinkleSpeed: Math.random() * 0.03 + 0.01,
                twinklePhase: Math.random() * Math.PI * 2
            });
        }

        // Create floating sakura/particles
        for (let i = 0; i < 25; i++) {
            bgParticles.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight,
                size: Math.random() * 6 + 3,
                speedX: Math.random() * 0.5 - 0.1,
                speedY: Math.random() * 0.3 + 0.2,
                rotation: Math.random() * 360,
                rotSpeed: Math.random() * 2 - 1,
                opacity: Math.random() * 0.4 + 0.1,
                hue: Math.random() > 0.5 ? 340 + Math.random() * 20 : 30 + Math.random() * 20 // pink or gold
            });
        }

        // Create clouds
        for (let i = 0; i < 5; i++) {
            bgClouds.push({
                x: Math.random() * window.innerWidth,
                y: Math.random() * window.innerHeight * 0.5 + 50,
                width: Math.random() * 200 + 100,
                speed: Math.random() * 0.2 + 0.05,
                opacity: Math.random() * 0.08 + 0.02
            });
        }

        function drawBackground() {
            bgCtx.clearRect(0, 0, bgCanvas.width, bgCanvas.height);

            // Draw stars
            bgStars.forEach(star => {
                star.twinklePhase += star.twinkleSpeed;
                const alpha = 0.3 + Math.sin(star.twinklePhase) * 0.3;
                bgCtx.beginPath();
                bgCtx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                bgCtx.fillStyle = `rgba(255, 255, 240, ${alpha})`;
                bgCtx.fill();
            });

            // Draw clouds
            bgClouds.forEach(cloud => {
                cloud.x += cloud.speed;
                if (cloud.x > bgCanvas.width + cloud.width) cloud.x = -cloud.width;

                bgCtx.beginPath();
                const gradient = bgCtx.createRadialGradient(
                    cloud.x, cloud.y, 0,
                    cloud.x, cloud.y, cloud.width / 2
                );
                gradient.addColorStop(0, `rgba(255, 255, 255, ${cloud.opacity})`);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                bgCtx.fillStyle = gradient;
                bgCtx.ellipse(cloud.x, cloud.y, cloud.width / 2, cloud.width / 4, 0, 0, Math.PI * 2);
                bgCtx.fill();
            });

            // Draw floating particles (sakura petals)
            bgParticles.forEach(p => {
                p.x += p.speedX + Math.sin(p.rotation * 0.02) * 0.3;
                p.y += p.speedY;
                p.rotation += p.rotSpeed;

                if (p.y > bgCanvas.height + 20) {
                    p.y = -20;
                    p.x = Math.random() * bgCanvas.width;
                }
                if (p.x > bgCanvas.width + 20) p.x = -20;
                if (p.x < -20) p.x = bgCanvas.width + 20;

                bgCtx.save();
                bgCtx.translate(p.x, p.y);
                bgCtx.rotate(p.rotation * Math.PI / 180);
                bgCtx.beginPath();
                bgCtx.ellipse(0, 0, p.size, p.size * 0.6, 0, 0, Math.PI * 2);
                bgCtx.fillStyle = `hsla(${p.hue}, 80%, 75%, ${p.opacity})`;
                bgCtx.fill();
                bgCtx.restore();
            });

            requestAnimationFrame(drawBackground);
        }
        drawBackground();

        // === SPARKLE EFFECT ===
        function createSparkles(x, y, color = '#feca57') {
            const container = document.getElementById('sparkleContainer');
            for (let i = 0; i < 12; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                const angle = (Math.PI * 2 / 12) * i + Math.random() * 0.5;
                const distance = 40 + Math.random() * 60;
                const tx = Math.cos(angle) * distance;
                const ty = Math.sin(angle) * distance;
                sparkle.style.cssText = `
                    left: ${x}px; top: ${y}px;
                    background: ${color};
                    box-shadow: 0 0 6px ${color};
                    --tx: ${tx}px; --ty: ${ty}px;
                `;
                container.appendChild(sparkle);
                setTimeout(() => sparkle.remove(), 800);
            }
        }

        // === SVG SUSHI GRAPHICS ===
        function makeSushiSVG(type) {
            const svgs = {
                nigiri: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="120" rx="80" ry="35" fill="#f5f0e0" stroke="#e0d5b5" stroke-width="2"/>
                    <ellipse cx="100" cy="115" rx="75" ry="30" fill="#fff8e7"/>
                    <ellipse cx="100" cy="90" rx="70" ry="25" fill="#e85d3a"/>
                    <ellipse cx="100" cy="85" rx="65" ry="22" fill="#f47347"/>
                    <path d="M45 85 Q70 60 100 58 Q130 60 155 85" fill="#ff8c5a" opacity="0.5"/>
                    <line x1="60" y1="80" x2="80" y2="75" stroke="#e85d3a" stroke-width="1.5" opacity="0.4"/>
                    <line x1="90" y1="73" x2="115" y2="75" stroke="#e85d3a" stroke-width="1.5" opacity="0.4"/>
                    <line x1="120" y1="78" x2="140" y2="83" stroke="#e85d3a" stroke-width="1.5" opacity="0.4"/>
                    <rect x="88" y="75" width="24" height="80" rx="3" fill="#1a3a1a" opacity="0.8"/>
                </svg>`,
                maki: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="130" rx="50" ry="12" fill="rgba(0,0,0,0.2)"/>
                    <rect x="50" y="50" width="100" height="80" rx="8" fill="#1a3a1a"/>
                    <rect x="54" y="54" width="92" height="72" rx="5" fill="#2a5a2a"/>
                    <circle cx="100" cy="90" r="30" fill="#f5f0e0"/>
                    <circle cx="100" cy="90" r="22" fill="#ff5252"/>
                    <circle cx="100" cy="90" r="15" fill="#e84040"/>
                    <circle cx="92" cy="84" r="4" fill="#ff7070" opacity="0.6"/>
                </svg>`,
                onigiri: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="140" rx="55" ry="10" fill="rgba(0,0,0,0.15)"/>
                    <path d="M100 20 L45 130 Q45 145 100 145 Q155 145 155 130 Z" fill="#f5f0e0" stroke="#e0d5b5" stroke-width="2"/>
                    <path d="M100 25 L50 128 Q50 140 100 140 Q150 140 150 128 Z" fill="#fff8e7"/>
                    <rect x="70" y="95" width="60" height="50" rx="3" fill="#1a3a1a"/>
                    <circle cx="90" cy="65" r="3" fill="#333" opacity="0.3"/>
                    <circle cx="110" cy="72" r="2.5" fill="#333" opacity="0.3"/>
                    <circle cx="95" cy="80" r="2" fill="#333" opacity="0.2"/>
                </svg>`,
                shrimp: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="125" rx="80" ry="30" fill="#f5f0e0" stroke="#e0d5b5" stroke-width="2"/>
                    <ellipse cx="100" cy="120" rx="75" ry="25" fill="#fff8e7"/>
                    <path d="M50 100 Q60 50 100 40 Q150 35 160 70 Q162 85 150 100" fill="#ff8a65" stroke="#e67345" stroke-width="1.5"/>
                    <path d="M55 100 Q65 55 100 47 Q145 42 155 72 Q157 85 147 100" fill="#ffab80" opacity="0.5"/>
                    <line x1="70" y1="80" x2="75" y2="65" stroke="#e67345" stroke-width="1" opacity="0.5"/>
                    <line x1="90" y1="70" x2="93" y2="55" stroke="#e67345" stroke-width="1" opacity="0.5"/>
                    <line x1="110" y1="65" x2="115" y2="52" stroke="#e67345" stroke-width="1" opacity="0.5"/>
                    <line x1="130" y1="72" x2="138" y2="60" stroke="#e67345" stroke-width="1" opacity="0.5"/>
                    <circle cx="155" cy="55" r="4" fill="#1a1a1a"/>
                    <path d="M158 42 Q170 30 175 35" stroke="#e67345" stroke-width="2" fill="none"/>
                    <path d="M160 45 Q175 38 178 42" stroke="#e67345" stroke-width="2" fill="none"/>
                </svg>`,
                tamago: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="120" rx="80" ry="35" fill="#f5f0e0" stroke="#e0d5b5" stroke-width="2"/>
                    <ellipse cx="100" cy="115" rx="75" ry="30" fill="#fff8e7"/>
                    <ellipse cx="100" cy="88" rx="72" ry="28" fill="#ffd54f"/>
                    <ellipse cx="100" cy="83" rx="68" ry="24" fill="#ffe082"/>
                    <path d="M45 88 Q75 60 100 58 Q125 60 155 88" fill="#fff59d" opacity="0.4"/>
                    <rect x="88" y="75" width="24" height="80" rx="3" fill="#1a3a1a" opacity="0.8"/>
                </svg>`,
                sashimi: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="130" rx="60" ry="12" fill="rgba(0,0,0,0.15)"/>
                    <path d="M40 120 Q40 70 100 50 Q160 70 160 120 Z" fill="#e85d3a"/>
                    <path d="M45 118 Q45 75 100 55 Q155 75 155 118 Z" fill="#f47347"/>
                    <path d="M50 115 Q55 80 100 62 Q145 80 150 115" fill="#ff8c5a" opacity="0.5"/>
                    <line x1="60" y1="105" x2="85" y2="80" stroke="#fff" stroke-width="1.5" opacity="0.15"/>
                    <line x1="80" y1="110" x2="105" y2="75" stroke="#fff" stroke-width="1.5" opacity="0.15"/>
                    <line x1="100" y1="112" x2="125" y2="78" stroke="#fff" stroke-width="1.5" opacity="0.15"/>
                    <line x1="120" y1="110" x2="140" y2="85" stroke="#fff" stroke-width="1.5" opacity="0.15"/>
                </svg>`,
                california: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="130" rx="50" ry="12" fill="rgba(0,0,0,0.2)"/>
                    <rect x="50" y="50" width="100" height="80" rx="8" fill="#f5f0e0"/>
                    <rect x="54" y="54" width="92" height="72" rx="5" fill="#fff8e7"/>
                    <circle cx="85" cy="85" r="12" fill="#4caf50"/>
                    <circle cx="115" cy="85" r="10" fill="#ff8a65"/>
                    <circle cx="100" cy="100" r="9" fill="#ffeb3b" opacity="0.8"/>
                    <circle cx="90" cy="95" r="4" fill="#f47347" opacity="0.5"/>
                    <circle cx="110" cy="95" r="3" fill="#4caf50" opacity="0.5"/>
                    <circle cx="100" cy="78" r="5" fill="#e85d3a" opacity="0.6"/>
                </svg>`,
                temaki: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="145" rx="40" ry="8" fill="rgba(0,0,0,0.15)"/>
                    <path d="M70 145 L100 25 L150 145 Z" fill="#1a3a1a"/>
                    <path d="M75 140 L100 32 L145 140 Z" fill="#2a5a2a"/>
                    <ellipse cx="108" cy="60" rx="18" ry="25" fill="#f5f0e0" opacity="0.9"/>
                    <circle cx="103" cy="52" r="7" fill="#ff5252"/>
                    <circle cx="115" cy="58" r="5" fill="#4caf50"/>
                    <circle cx="105" cy="68" r="4" fill="#ff8a65"/>
                    <circle cx="112" cy="48" r="3" fill="#ffeb3b" opacity="0.7"/>
                </svg>`,
                uramaki: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="130" rx="50" ry="12" fill="rgba(0,0,0,0.2)"/>
                    <rect x="50" y="50" width="100" height="80" rx="10" fill="#ff8a65"/>
                    <rect x="55" y="55" width="90" height="70" rx="7" fill="#ffab80"/>
                    <circle cx="60" cy="65" r="3" fill="#f5f0e0" opacity="0.6"/>
                    <circle cx="80" cy="58" r="2.5" fill="#f5f0e0" opacity="0.5"/>
                    <circle cx="140" cy="62" r="2" fill="#f5f0e0" opacity="0.5"/>
                    <circle cx="65" cy="115" r="2.5" fill="#f5f0e0" opacity="0.5"/>
                    <circle cx="135" cy="118" r="3" fill="#f5f0e0" opacity="0.6"/>
                    <rect x="65" y="65" width="70" height="50" rx="5" fill="#1a3a1a"/>
                    <rect x="69" y="69" width="62" height="42" rx="3" fill="#2a5a2a"/>
                    <circle cx="90" cy="90" r="10" fill="#e85d3a"/>
                    <circle cx="110" cy="90" r="8" fill="#4caf50"/>
                </svg>`,
                dango: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <rect x="97" y="20" width="6" height="130" rx="3" fill="#c6956e"/>
                    <circle cx="100" cy="40" r="22" fill="#f48fb1"/>
                    <circle cx="100" cy="40" r="18" fill="#f8bbd0"/>
                    <circle cx="92" cy="34" r="5" fill="#fce4ec" opacity="0.5"/>
                    <circle cx="100" cy="80" r="22" fill="#fff9c4"/>
                    <circle cx="100" cy="80" r="18" fill="#fffde7"/>
                    <circle cx="93" cy="74" r="5" fill="#fff" opacity="0.4"/>
                    <circle cx="100" cy="120" r="22" fill="#a5d6a7"/>
                    <circle cx="100" cy="120" r="18" fill="#c8e6c9"/>
                    <circle cx="93" cy="114" r="5" fill="#e8f5e9" opacity="0.5"/>
                </svg>`,
                ramen: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="140" rx="70" ry="15" fill="rgba(0,0,0,0.15)"/>
                    <path d="M30 80 Q30 145 100 145 Q170 145 170 80 Z" fill="#ff7043"/>
                    <path d="M35 80 Q35 140 100 140 Q165 140 165 80 Z" fill="#ff8a65"/>
                    <ellipse cx="100" cy="80" rx="70" ry="20" fill="#ffd54f"/>
                    <ellipse cx="100" cy="78" rx="65" ry="16" fill="#ffe082"/>
                    <path d="M50 78 Q65 65 80 78" stroke="#d4a14a" stroke-width="2" fill="none"/>
                    <path d="M80 78 Q95 65 110 78" stroke="#d4a14a" stroke-width="2" fill="none"/>
                    <path d="M110 78 Q125 65 140 78" stroke="#d4a14a" stroke-width="2" fill="none"/>
                    <circle cx="75" cy="72" r="8" fill="#f5f0e0" stroke="#ddd" stroke-width="1"/>
                    <circle cx="75" cy="72" r="4" fill="#ffd54f"/>
                    <ellipse cx="120" cy="70" rx="15" ry="8" fill="#e85d3a" opacity="0.7"/>
                    <rect x="60" y="68" width="4" height="20" rx="1" fill="#4caf50" transform="rotate(-15, 62, 78)"/>
                    <rect x="130" y="68" width="4" height="20" rx="1" fill="#4caf50" transform="rotate(10, 132, 78)"/>
                </svg>`,
                gyoza: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="130" rx="65" ry="12" fill="rgba(0,0,0,0.15)"/>
                    <path d="M35 110 Q100 30 165 110 Q100 130 35 110 Z" fill="#f5deb3"/>
                    <path d="M40 108 Q100 35 160 108 Q100 125 40 108 Z" fill="#ffe4b5"/>
                    <path d="M55 95 Q75 75 95 95" stroke="#d4a14a" stroke-width="2" fill="none" opacity="0.5"/>
                    <path d="M75 90 Q95 70 115 90" stroke="#d4a14a" stroke-width="2" fill="none" opacity="0.5"/>
                    <path d="M95 88 Q115 68 135 88" stroke="#d4a14a" stroke-width="2" fill="none" opacity="0.5"/>
                    <path d="M45 108 Q100 100 155 108" stroke="#c6956e" stroke-width="2" fill="none" opacity="0.6"/>
                    <ellipse cx="80" cy="105" rx="5" ry="3" fill="#daa520" opacity="0.3"/>
                    <ellipse cx="120" cy="103" rx="4" ry="2.5" fill="#daa520" opacity="0.3"/>
                </svg>`,
                taiyaki: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="140" rx="55" ry="10" fill="rgba(0,0,0,0.15)"/>
                    <ellipse cx="100" cy="90" rx="60" ry="40" fill="#daa520"/>
                    <ellipse cx="100" cy="88" rx="55" ry="36" fill="#f0c040"/>
                    <path d="M155 85 L185 70 L180 90 L190 95 L175 100 L155 95" fill="#daa520"/>
                    <circle cx="70" cy="78" r="5" fill="#333"/>
                    <circle cx="68" cy="76" r="2" fill="#666"/>
                    <path d="M82 95 Q90 102 98 95" stroke="#8B4513" stroke-width="2" fill="none"/>
                    <path d="M85 80 Q95 72 105 80" stroke="#c68c1e" stroke-width="1.5" fill="none" opacity="0.5"/>
                    <path d="M95 90 Q105 82 115 90" stroke="#c68c1e" stroke-width="1.5" fill="none" opacity="0.5"/>
                    <path d="M90 100 Q100 92 110 100" stroke="#c68c1e" stroke-width="1.5" fill="none" opacity="0.5"/>
                </svg>`,
                takoyaki: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <ellipse cx="100" cy="130" rx="55" ry="12" fill="rgba(0,0,0,0.15)"/>
                    <circle cx="75" cy="100" r="30" fill="#daa520"/>
                    <circle cx="75" cy="98" r="27" fill="#f0c040"/>
                    <circle cx="125" cy="100" r="30" fill="#daa520"/>
                    <circle cx="125" cy="98" r="27" fill="#f0c040"/>
                    <circle cx="100" cy="70" r="30" fill="#daa520"/>
                    <circle cx="100" cy="68" r="27" fill="#f0c040"/>
                    <path d="M85 60 Q100 50 115 60" stroke="#8B4513" stroke-width="3" fill="none" opacity="0.5"/>
                    <path d="M60 92 Q75 82 90 92" stroke="#8B4513" stroke-width="3" fill="none" opacity="0.5"/>
                    <path d="M110 92 Q125 82 140 92" stroke="#8B4513" stroke-width="3" fill="none" opacity="0.5"/>
                    <circle cx="95" cy="62" r="3" fill="#4caf50"/>
                    <circle cx="70" cy="92" r="2.5" fill="#4caf50"/>
                    <circle cx="120" cy="94" r="3" fill="#4caf50"/>
                    <circle cx="108" cy="65" r="2" fill="#ff5252" opacity="0.6"/>
                    <circle cx="80" cy="96" r="2" fill="#ff5252" opacity="0.6"/>
                    <circle cx="130" cy="95" r="2" fill="#ff5252" opacity="0.6"/>
                </svg>`,
                bento: `<svg viewBox="0 0 200 160" xmlns="http://www.w3.org/2000/svg">
                    <rect x="30" y="40" width="140" height="100" rx="10" fill="#8B4513"/>
                    <rect x="34" y="44" width="132" height="92" rx="7" fill="#a0522d"/>
                    <line x1="100" y1="44" x2="100" y2="136" stroke="#8B4513" stroke-width="2"/>
                    <line x1="34" y1="90" x2="100" y2="90" stroke="#8B4513" stroke-width="2"/>
                    <rect x="38" y="48" width="58" height="38" rx="3" fill="#f5f0e0"/>
                    <circle cx="55" cy="60" r="5" fill="#ff5252"/>
                    <circle cx="70" cy="65" r="4" fill="#ff5252"/>
                    <circle cx="60" cy="72" r="4.5" fill="#ff5252"/>
                    <rect x="38" y="94" width="58" height="38" rx="3" fill="#fff8e7"/>
                    <ellipse cx="67" cy="113" rx="20" ry="12" fill="#4caf50" opacity="0.6"/>
                    <circle cx="55" cy="108" r="6" fill="#ff8a65"/>
                    <rect x="104" y="48" width="58" height="84" rx="3" fill="#fff8e7"/>
                    <ellipse cx="133" cy="70" rx="20" ry="10" fill="#e85d3a" opacity="0.7"/>
                    <circle cx="120" cy="100" r="12" fill="#ffd54f"/>
                    <circle cx="120" cy="100" r="6" fill="#ffeb3b"/>
                    <rect x="140" y="110" width="15" height="6" rx="2" fill="#4caf50"/>
                </svg>`
            };

            return svgs[type] || svgs.nigiri;
        }

        // SVG character graphics
        function makeCharacterSVG(color, hatColor) {
            return `<svg viewBox="0 0 120 140" xmlns="http://www.w3.org/2000/svg">
                <!-- Body -->
                <ellipse cx="60" cy="130" rx="25" ry="8" fill="rgba(0,0,0,0.2)"/>
                <rect x="40" y="75" width="40" height="50" rx="10" fill="${color}"/>
                <rect x="42" y="78" width="36" height="46" rx="8" fill="${color}" opacity="0.9"/>
                <!-- Apron -->
                <path d="M44 85 L76 85 L73 120 L47 120 Z" fill="white" opacity="0.85"/>
                <rect x="55" y="85" width="10" height="8" rx="2" fill="${color}" opacity="0.5"/>
                <!-- Head -->
                <circle cx="60" cy="55" r="28" fill="#ffe0bd"/>
                <circle cx="60" cy="56" r="26" fill="#ffdbac"/>
                <!-- Eyes -->
                <ellipse cx="50" cy="52" rx="4" ry="4.5" fill="#2c2c2c"/>
                <ellipse cx="70" cy="52" rx="4" ry="4.5" fill="#2c2c2c"/>
                <circle cx="48" cy="50" r="1.5" fill="white"/>
                <circle cx="68" cy="50" r="1.5" fill="white"/>
                <!-- Mouth -->
                <path d="M52 63 Q60 70 68 63" stroke="#c47a5a" stroke-width="2" fill="none"/>
                <!-- Blush -->
                <ellipse cx="42" cy="60" rx="6" ry="3.5" fill="#ffb3b3" opacity="0.5"/>
                <ellipse cx="78" cy="60" rx="6" ry="3.5" fill="#ffb3b3" opacity="0.5"/>
                <!-- Chef hat -->
                <ellipse cx="60" cy="33" rx="30" ry="8" fill="${hatColor || '#f5f5f5'}"/>
                <path d="M32 33 Q30 5 60 2 Q90 5 88 33" fill="${hatColor || '#f5f5f5'}"/>
                <path d="M35 33 Q34 10 60 7 Q86 10 85 33" fill="white" opacity="0.3"/>
                <!-- Arms -->
                <ellipse cx="32" cy="95" rx="10" ry="7" fill="${color}" transform="rotate(-15, 32, 95)"/>
                <circle cx="25" cy="92" r="6" fill="#ffe0bd"/>
                <ellipse cx="88" cy="95" rx="10" ry="7" fill="${color}" transform="rotate(15, 88, 95)"/>
                <circle cx="95" cy="92" r="6" fill="#ffe0bd"/>
                <!-- Legs/feet -->
                <rect x="45" y="118" width="12" height="15" rx="5" fill="#555"/>
                <rect x="63" y="118" width="12" height="15" rx="5" fill="#555"/>
                <ellipse cx="51" cy="134" rx="8" ry="5" fill="#444"/>
                <ellipse cx="69" cy="134" rx="8" ry="5" fill="#444"/>
            </svg>`;
        }

        // Player avatars and colors
        const PLAYER_DATA = [
            { avatar: 'chef-red', color: '#ff6b6b', hatColor: '#ff6b6b', name: 'Chef Red' },
            { avatar: 'chef-blue', color: '#48dbfb', hatColor: '#48dbfb', name: 'Chef Blue' },
            { avatar: 'chef-green', color: '#26de81', hatColor: '#26de81', name: 'Chef Green' },
            { avatar: 'chef-gold', color: '#feca57', hatColor: '#feca57', name: 'Chef Gold' }
        ];

        // Get avatar display (mini emoji for UI, SVG for game)
        function getAvatarEmoji(playerIndex) {
            const emojis = ['üî¥', 'üîµ', 'üü¢', 'üü°'];
            return emojis[playerIndex] || 'üî¥';
        }

        // Sushi types for the tower (keys into makeSushiSVG)
        const SUSHI_KEYS = ['nigiri', 'maki', 'onigiri', 'shrimp', 'tamago', 'sashimi', 'california', 'temaki', 'uramaki', 'dango', 'ramen', 'gyoza', 'taiyaki', 'takoyaki', 'bento'];

        // Keep SUSHI_TYPES for backward compat in results display (uses emoji for mini displays)
        const SUSHI_TYPES = ['üç£', 'üçô', 'üç•', 'üç§', 'üç±', 'ü¶ê', 'üêü', 'üêô', 'ü¶ë', 'ü¶Ä', 'ü•¢', 'üçò', 'ü•ü', 'üç°', 'üç¢'];

        // Game state
        let gameState = {
            playerCount: 3,
            players: [],
            currentPlayerIndex: 0,
            currentRound: 1,
            maxRounds: 5,
            turnTimeLeft: 120,
            turnTimer: null,
            currentHeight: 0,
            maxTowerHeight: 15,
            currentAnswer: 0,
            isShowingProblem: false,
            towerSushi: [],
            completedStacks: [],
            difficulty: 'medium',
            customLevel: 5,
            perPlayerMode: false,
            soloMode: false,
            soloTotalScore: 0
        };

        // High scores storage key
        const HIGH_SCORES_KEY = 'sushiStackHighScores';

        // Load high scores from localStorage
        function loadHighScores() {
            try {
                const scores = localStorage.getItem(HIGH_SCORES_KEY);
                return scores ? JSON.parse(scores) : [];
            } catch (e) {
                return [];
            }
        }

        // Save high score to localStorage
        function saveHighScore(name, score, difficulty, stacks) {
            const scores = loadHighScores();
            scores.push({
                name: name,
                score: score,
                difficulty: difficulty,
                stacks: stacks,
                date: new Date().toLocaleDateString()
            });
            // Sort by score descending and keep top 10
            scores.sort((a, b) => b.score - a.score);
            scores.splice(10);
            try {
                localStorage.setItem(HIGH_SCORES_KEY, JSON.stringify(scores));
            } catch (e) {
                console.log('Could not save high scores');
            }
            return scores;
        }

        // Get player's rank in high scores
        function getScoreRank(score) {
            const scores = loadHighScores();
            for (let i = 0; i < scores.length; i++) {
                if (score >= scores[i].score) {
                    return i + 1;
                }
            }
            return scores.length + 1;
        }

        // Audio context for sound effects
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // Sound: Falling whistle (descending pitch)
        function playFallSound() {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.8);

            gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.8);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.8);
        }

        // Sound: Splat/crash when hitting ground
        function playSplatSound() {
            initAudio();

            // Create noise for splat
            const bufferSize = audioCtx.sampleRate * 0.3;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 400;

            const gainNode = audioCtx.createGain();
            gainNode.gain.setValueAtTime(0.6, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            noise.start();
        }

        // Sound: Correct answer (happy ding)
        function playCorrectSound() {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(523.25, audioCtx.currentTime); // C5
            oscillator.frequency.setValueAtTime(659.25, audioCtx.currentTime + 0.1); // E5
            oscillator.frequency.setValueAtTime(783.99, audioCtx.currentTime + 0.2); // G5

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.4);
        }

        // Sound: Wrong answer buzzer
        function playWrongSound() {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(150, audioCtx.currentTime);
            oscillator.frequency.setValueAtTime(120, audioCtx.currentTime + 0.15);

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.3);
        }

        // Sound: Climb up
        function playClimbSound() {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.15);

            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.15);
        }

        // Sound: Stack complete fanfare
        function playStackCompleteSound() {
            initAudio();
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
            notes.forEach((freq, i) => {
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                oscillator.type = 'sine';
                oscillator.frequency.value = freq;
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime + i * 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.1 + 0.3);
                oscillator.start(audioCtx.currentTime + i * 0.1);
                oscillator.stop(audioCtx.currentTime + i * 0.1 + 0.3);
            });
        }

        // DOM elements
        const elements = {
            header: document.getElementById('header'),
            completedStacks: document.getElementById('completedStacks'),
            gameStage: document.getElementById('gameStage'),
            startScreen: document.getElementById('startScreen'),
            turnTransition: document.getElementById('turnTransition'),
            resultsScreen: document.getElementById('resultsScreen'),
            playerScores: document.getElementById('playerScores'),
            currentPlayerName: document.getElementById('currentPlayerName'),
            timerDisplay: document.getElementById('timerDisplay'),
            sushiTower: document.getElementById('sushiTower'),
            character: document.getElementById('character'),
            heightValue: document.getElementById('heightValue'),
            problemOverlay: document.getElementById('problemOverlay'),
            problemSushi: document.getElementById('problemSushi'),
            probNum1: document.getElementById('probNum1'),
            problemInput: document.getElementById('problemInput'),
            equationDisplay: document.getElementById('equationDisplay'),
            inlineInput: document.getElementById('inlineInput'),
            feedbackFlash: document.getElementById('feedbackFlash'),
            turnAvatar: document.getElementById('turnAvatar'),
            turnName: document.getElementById('turnName'),
            winnerAvatar: document.getElementById('winnerAvatar'),
            winnerName: document.getElementById('winnerName'),
            winnerScore: document.getElementById('winnerScore'),
            finalScores: document.getElementById('finalScores'),
            playerNames: document.getElementById('playerNames')
        };

        // Initialize player name inputs
        function updatePlayerNameInputs() {
            elements.playerNames.innerHTML = '';
            for (let i = 0; i < gameState.playerCount; i++) {
                const div = document.createElement('div');
                div.className = 'player-name-input';

                let diffSelector = '';
                if (gameState.perPlayerMode) {
                    diffSelector = `
                        <select class="player-diff-select" data-player="${i}">
                            <option value="easy">Easy</option>
                            <option value="medium" selected>Medium</option>
                            <option value="hard">Hard</option>
                            <option value="brutal">Brutal</option>
                            <option value="insane">Insane</option>
                            <optgroup label="Custom Level">
                                <option value="1">Level 1</option>
                                <option value="2">Level 2</option>
                                <option value="3">Level 3</option>
                                <option value="4">Level 4</option>
                                <option value="5">Level 5</option>
                                <option value="6">Level 6</option>
                                <option value="7">Level 7</option>
                                <option value="8">Level 8</option>
                                <option value="9">Level 9</option>
                                <option value="10">Level 10</option>
                            </optgroup>
                        </select>
                    `;
                }

                div.innerHTML = `
                    <div class="player-avatar" style="background: ${PLAYER_DATA[i].color}40;">${makeCharacterSVG(PLAYER_DATA[i].color, PLAYER_DATA[i].hatColor)}</div>
                    <input type="text" placeholder="${PLAYER_DATA[i].name}" data-player="${i}" value="${PLAYER_DATA[i].name}">
                    ${diffSelector}
                `;
                elements.playerNames.appendChild(div);
            }
        }

        // Build the sushi tower
        function buildTower() {
            elements.sushiTower.innerHTML = '';
            gameState.towerSushi = [];

            for (let i = 0; i < gameState.maxTowerHeight; i++) {
                const sushiKey = SUSHI_KEYS[Math.floor(Math.random() * SUSHI_KEYS.length)];
                const sushiEmoji = SUSHI_TYPES[Math.floor(Math.random() * SUSHI_TYPES.length)];
                gameState.towerSushi.push(sushiEmoji);

                const platform = document.createElement('div');
                platform.className = 'sushi-platform' + (i === 0 ? ' current' : ' locked');
                platform.innerHTML = makeSushiSVG(sushiKey);
                platform.dataset.index = i;
                elements.sushiTower.appendChild(platform);
            }

            // Re-add the character element (it was cleared with innerHTML)
            const character = document.createElement('div');
            character.className = 'character';
            character.id = 'character';
            if (gameState.players.length > 0) {
                const p = gameState.players[gameState.currentPlayerIndex];
                const pd = PLAYER_DATA[gameState.currentPlayerIndex];
                character.innerHTML = makeCharacterSVG(pd.color, pd.hatColor);
            } else {
                character.innerHTML = makeCharacterSVG('#ff6b6b', '#ff6b6b');
            }
            elements.sushiTower.appendChild(character);
            elements.character = character;

            // Add plate
            const plate = document.createElement('div');
            plate.className = 'plate';
            elements.sushiTower.appendChild(plate);
        }

        // Update tower visuals
        function updateTowerVisuals() {
            const platforms = document.querySelectorAll('.sushi-platform');
            platforms.forEach((p, i) => {
                p.classList.remove('current', 'completed', 'locked');
                if (i < gameState.currentHeight) {
                    p.classList.add('completed');
                } else if (i === gameState.currentHeight) {
                    p.classList.add('current');
                } else {
                    p.classList.add('locked');
                }
            });

            // Auto-scroll the tower to keep current platform visible
            scrollTowerToCurrentHeight();
        }

        // Scroll tower to keep current platform in view
        function scrollTowerToCurrentHeight() {
            // Each platform is about 250px tall based on CSS
            const platformHeight = 250;
            const viewportHeight = 900; // Based on CSS .sushi-viewport height
            const baseBottom = 100; // Initial bottom position from CSS

            // Calculate how much to shift the tower
            // We want to keep the current platform in the middle-lower part of the viewport
            const currentPlatformBottom = baseBottom + (gameState.currentHeight * platformHeight);
            const targetVisibleHeight = viewportHeight * 0.6; // Keep it in lower 60% of viewport

            if (currentPlatformBottom > targetVisibleHeight) {
                const scrollOffset = currentPlatformBottom - targetVisibleHeight;
                elements.sushiTower.style.transform = `translateX(-50%) translateY(-${scrollOffset}px)`;
            } else {
                elements.sushiTower.style.transform = 'translateX(-50%)';
            }
        }

        // Position character
        function positionCharacter(animate = true) {
            const platforms = document.querySelectorAll('.sushi-platform');
            if (platforms.length === 0) return;

            // Position character based on current height
            // Each platform is 250px tall, character sits on top of current platform
            const platformHeight = 250;
            const characterBottom = gameState.currentHeight * platformHeight + 200;

            if (animate) {
                elements.character.classList.add('walking');
                setTimeout(() => {
                    elements.character.classList.remove('walking');
                }, 500);
            }

            elements.character.style.bottom = characterBottom + 'px';

            elements.heightValue.textContent = gameState.currentHeight;
        }

        // Update player scores display
        function updatePlayerScores() {
            elements.playerScores.innerHTML = '';
            gameState.players.forEach((player, i) => {
                const div = document.createElement('div');
                div.className = 'player-score' + (i === gameState.currentPlayerIndex ? ' active' : '');
                div.style.background = player.color + '40';
                div.innerHTML = `
                    <div class="name">${getAvatarEmoji(i)} ${player.name}</div>
                    <div class="score">${player.totalScore}</div>
                `;
                elements.playerScores.appendChild(div);
            });
        }

        // Update current player display
        function updateCurrentPlayer() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const pd = PLAYER_DATA[gameState.currentPlayerIndex];
            elements.currentPlayerName.textContent = player.name;
            elements.currentPlayerName.style.background = player.color + '60';
            elements.character.innerHTML = makeCharacterSVG(pd.color, pd.hatColor);
        }

        // Format time
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Update timer display
        function updateTimerDisplay() {
            elements.timerDisplay.textContent = formatTime(gameState.turnTimeLeft);
            if (gameState.turnTimeLeft <= 30) {
                elements.timerDisplay.classList.add('warning');
            } else {
                elements.timerDisplay.classList.remove('warning');
            }
        }

        // Difficulty settings - numbers stay firmly within each level
        // tier controls how big numbers get inside each operation type
        const DIFFICULTY_SETTINGS = {
            easy: {
                // Addition and subtraction only, small numbers
                baseMax: 10,
                heightScale: 1,
                maxNum: 20,
                tier: 1,
                operations: ['add', 'sub']
            },
            medium: {
                // Add, sub, simple multiply
                baseMax: 20,
                heightScale: 2,
                maxNum: 50,
                tier: 2,
                operations: ['add', 'sub', 'mul', 'mul']
            },
            hard: {
                // Add, sub, mul, div, squares
                baseMax: 40,
                heightScale: 5,
                maxNum: 150,
                tier: 3,
                operations: ['add', 'sub', 'mul', 'div', 'square', 'mul2digit']
            },
            brutal: {
                // Hard + sqrt, order of operations, bigger numbers everywhere
                baseMax: 80,
                heightScale: 15,
                maxNum: 500,
                tier: 4,
                operations: ['add', 'sub', 'mul', 'div', 'square', 'mul2digit', 'sqrt', 'orderOps', 'orderOps2', 'parentheses', 'cube', 'negative', 'tripleMul']
            },
            insane: {
                // EVERYTHING with massive numbers
                baseMax: 150,
                heightScale: 30,
                maxNum: 9999,
                tier: 5,
                operations: ['add3digit', 'sub3digit', 'mul2digit', 'mulBig', 'div', 'divBig', 'square', 'squareBig', 'cube', 'sqrt', 'sqrtBig', 'orderOps', 'orderOps2', 'orderOps3', 'parentheses', 'parentheses2', 'percent', 'negative', 'tripleMul', 'divMul', 'power2', 'powerBig', 'fraction', 'chainOps', 'modulo']
            }
        };

        // Custom level settings (1-10 scale)
        function getCustomDifficultySettings(level) {
            const ops = [
                ['add', 'sub'],                                          // Level 1
                ['add', 'sub', 'mul'],                                   // Level 2
                ['add', 'sub', 'mul', 'mul'],                            // Level 3
                ['add', 'sub', 'mul', 'div'],                            // Level 4
                ['add', 'sub', 'mul', 'div', 'square'],                  // Level 5
                ['add', 'sub', 'mul', 'div', 'square', 'mul2digit'],     // Level 6
                ['add', 'sub', 'mul', 'div', 'square', 'mul2digit', 'sqrt', 'orderOps'], // Level 7
                ['add', 'sub', 'mul2digit', 'div', 'square', 'sqrt', 'orderOps', 'orderOps2', 'parentheses', 'tripleMul'], // Level 8
                ['add3digit', 'sub3digit', 'mul2digit', 'div', 'square', 'cube', 'sqrt', 'orderOps', 'orderOps3', 'percent', 'negative', 'parentheses'], // Level 9
                ['add3digit', 'sub3digit', 'mul2digit', 'mulBig', 'divBig', 'squareBig', 'cube', 'sqrtBig', 'orderOps', 'orderOps2', 'orderOps3', 'parentheses', 'parentheses2', 'percent', 'negative', 'tripleMul', 'divMul', 'powerBig', 'fraction', 'chainOps', 'modulo'] // Level 10
            ];
            const tiers = [1, 1, 2, 2, 3, 3, 3, 4, 4, 5];
            return {
                baseMax: 8 + level * 8,
                heightScale: level,
                maxNum: 30 + level * 100,
                tier: tiers[level - 1] || 3,
                operations: ops[level - 1] || ops[4]
            };
        }

        // Generate math problem based on difficulty
        function generateProblem() {
            const height = gameState.currentHeight;

            // Determine which difficulty settings to use
            let diff;
            if (gameState.perPlayerMode) {
                // Use current player's individual difficulty
                const playerDiff = gameState.players[gameState.currentPlayerIndex].difficulty;
                if (typeof playerDiff === 'number') {
                    diff = getCustomDifficultySettings(playerDiff);
                } else {
                    diff = DIFFICULTY_SETTINGS[playerDiff] || DIFFICULTY_SETTINGS.medium;
                }
            } else if (gameState.difficulty === 'custom') {
                diff = getCustomDifficultySettings(gameState.customLevel);
            } else {
                diff = DIFFICULTY_SETTINGS[gameState.difficulty] || DIFFICULTY_SETTINGS.medium;
            }

            let problemText, answer;

            // Scale numbers with height, but firmly cap at difficulty's maxNum
            const maxNum = Math.min(diff.baseMax + height * diff.heightScale, diff.maxNum);
            const tier = diff.tier || 2;

            // Pick random operation from available ones
            const op = diff.operations[Math.floor(Math.random() * diff.operations.length)];

            switch (op) {
                case 'add': {
                    const a = Math.floor(Math.random() * maxNum) + 1;
                    const b = Math.floor(Math.random() * maxNum) + 1;
                    answer = a + b;
                    problemText = `${a} + ${b}`;
                    break;
                }
                case 'sub': {
                    const a = Math.floor(Math.random() * maxNum) + 10;
                    const b = Math.floor(Math.random() * a) + 1;
                    answer = a - b;
                    problemText = `${a} ‚àí ${b}`;
                    break;
                }
                case 'mul': {
                    // tier scales: t1=2-6, t2=2-12, t3=2-15, t4=5-20, t5=10-25
                    const mulMax = [6, 12, 15, 20, 25][tier - 1] || 12;
                    const mulMin = tier >= 4 ? 5 : 2;
                    const a = Math.floor(Math.random() * (mulMax - mulMin)) + mulMin;
                    const b = Math.floor(Math.random() * (mulMax - mulMin)) + mulMin;
                    answer = a * b;
                    problemText = `${a} √ó ${b}`;
                    break;
                }
                case 'div': {
                    const divMax = [6, 12, 15, 20, 25][tier - 1] || 12;
                    const divMin = tier >= 4 ? 5 : 2;
                    const b = Math.floor(Math.random() * (divMax - divMin)) + divMin;
                    answer = Math.floor(Math.random() * (divMax - divMin)) + divMin;
                    const a = b * answer;
                    problemText = `${a} √∑ ${b}`;
                    break;
                }
                case 'divBig': {
                    // Large division: e.g. 4536 √∑ 72
                    const b = Math.floor(Math.random() * 80) + 12;
                    answer = Math.floor(Math.random() * 80) + 10;
                    const a = b * answer;
                    problemText = `${a} √∑ ${b}`;
                    break;
                }
                case 'square': {
                    const sqMax = [8, 12, 15, 20, 25][tier - 1] || 12;
                    const a = Math.floor(Math.random() * sqMax) + 3;
                    answer = a * a;
                    problemText = `${a}¬≤`;
                    break;
                }
                case 'squareBig': {
                    // Squares of larger numbers: 25-50
                    const a = Math.floor(Math.random() * 26) + 25;
                    answer = a * a;
                    problemText = `${a}¬≤`;
                    break;
                }
                case 'mul2digit': {
                    const m2Max = tier >= 4 ? 80 : 40;
                    const m2Min = tier >= 4 ? 20 : 10;
                    const a = Math.floor(Math.random() * (m2Max - m2Min)) + m2Min;
                    const b = Math.floor(Math.random() * (m2Max - m2Min)) + m2Min;
                    answer = a * b;
                    problemText = `${a} √ó ${b}`;
                    break;
                }
                case 'mulBig': {
                    // 3-digit √ó 2-digit
                    const a = Math.floor(Math.random() * 900) + 100;
                    const b = Math.floor(Math.random() * 90) + 10;
                    answer = a * b;
                    problemText = `${a} √ó ${b}`;
                    break;
                }
                case 'add3digit': {
                    const a = Math.floor(Math.random() * 9000) + 1000;
                    const b = Math.floor(Math.random() * 9000) + 1000;
                    answer = a + b;
                    problemText = `${a} + ${b}`;
                    break;
                }
                case 'sub3digit': {
                    const a = Math.floor(Math.random() * 9000) + 1000;
                    const b = Math.floor(Math.random() * a) + 1;
                    answer = a - b;
                    problemText = `${a} ‚àí ${b}`;
                    break;
                }
                case 'cube': {
                    const cubeMax = tier >= 5 ? 15 : 10;
                    const a = Math.floor(Math.random() * cubeMax) + 3;
                    answer = a * a * a;
                    problemText = `${a}¬≥`;
                    break;
                }
                case 'sqrt': {
                    const sqrtMax = tier >= 4 ? 20 : 15;
                    answer = Math.floor(Math.random() * sqrtMax) + 5;
                    const a = answer * answer;
                    problemText = `‚àö${a}`;
                    break;
                }
                case 'sqrtBig': {
                    // Bigger square roots: ‚àö625, ‚àö2025, etc.
                    answer = Math.floor(Math.random() * 50) + 20;
                    const a = answer * answer;
                    problemText = `‚àö${a}`;
                    break;
                }
                case 'orderOps': {
                    const ooMul = tier >= 4 ? 25 : 15;
                    const ooAdd = tier >= 4 ? 50 : 20;
                    const a = Math.floor(Math.random() * ooMul) + 5;
                    const b = Math.floor(Math.random() * ooMul) + 2;
                    const c = Math.floor(Math.random() * ooAdd) + 5;
                    answer = a * b + c;
                    problemText = `${a} √ó ${b} + ${c}`;
                    break;
                }
                case 'orderOps2': {
                    const oo2Mul = tier >= 4 ? 30 : 15;
                    const a = Math.floor(Math.random() * oo2Mul) + 10;
                    const b = Math.floor(Math.random() * oo2Mul) + 2;
                    const c = Math.floor(Math.random() * 20) + 2;
                    answer = a * b - c;
                    problemText = `${a} √ó ${b} ‚àí ${c}`;
                    break;
                }
                case 'orderOps3': {
                    // a √ó b + c √ó d (four-term order of ops)
                    const a = Math.floor(Math.random() * 20) + 5;
                    const b = Math.floor(Math.random() * 15) + 2;
                    const c = Math.floor(Math.random() * 20) + 5;
                    const d = Math.floor(Math.random() * 15) + 2;
                    answer = a * b + c * d;
                    problemText = `${a} √ó ${b} + ${c} √ó ${d}`;
                    break;
                }
                case 'parentheses': {
                    const pMul = tier >= 4 ? 15 : 8;
                    const pAdd = tier >= 4 ? 40 : 20;
                    const a = Math.floor(Math.random() * pAdd) + 10;
                    const b = Math.floor(Math.random() * pAdd) + 5;
                    const c = Math.floor(Math.random() * pMul) + 2;
                    answer = (a + b) * c;
                    problemText = `(${a} + ${b}) √ó ${c}`;
                    break;
                }
                case 'parentheses2': {
                    // (a ‚àí b) √ó c + d
                    const a = Math.floor(Math.random() * 40) + 30;
                    const b = Math.floor(Math.random() * 25) + 5;
                    const c = Math.floor(Math.random() * 15) + 2;
                    const d = Math.floor(Math.random() * 50) + 10;
                    answer = (a - b) * c + d;
                    problemText = `(${a} ‚àí ${b}) √ó ${c} + ${d}`;
                    break;
                }
                case 'percent': {
                    if (tier >= 5) {
                        // Harder percents: 12.5%, 37.5%, odd bases
                        const percent = [5, 12, 15, 35, 45, 60, 75, 85][Math.floor(Math.random() * 8)];
                        const base = Math.floor(Math.random() * 49 + 1) * 20;
                        answer = (percent / 100) * base;
                        problemText = `${percent}% of ${base}`;
                    } else {
                        const percent = [10, 15, 20, 25, 50, 75][Math.floor(Math.random() * 6)];
                        const base = Math.floor(Math.random() * 19 + 1) * 20;
                        answer = (percent / 100) * base;
                        problemText = `${percent}% of ${base}`;
                    }
                    break;
                }
                case 'negative': {
                    const negScale = tier >= 5 ? 3 : 1;
                    const a = Math.floor(Math.random() * 40 * negScale) + 10;
                    const b = Math.floor(Math.random() * 60 * negScale) + 30;
                    answer = a - b;
                    problemText = `${a} ‚àí ${b}`;
                    break;
                }
                case 'tripleMul': {
                    const tmMax = tier >= 4 ? 15 : 8;
                    const a = Math.floor(Math.random() * tmMax) + 2;
                    const b = Math.floor(Math.random() * tmMax) + 2;
                    const c = Math.floor(Math.random() * tmMax) + 2;
                    answer = a * b * c;
                    problemText = `${a} √ó ${b} √ó ${c}`;
                    break;
                }
                case 'divMul': {
                    const dmMax = tier >= 5 ? 20 : 8;
                    const divisor = Math.floor(Math.random() * dmMax) + 2;
                    const quotient = Math.floor(Math.random() * 15) + 3;
                    const a = divisor * quotient;
                    const c = Math.floor(Math.random() * 12) + 2;
                    answer = quotient * c;
                    problemText = `${a} √∑ ${divisor} √ó ${c}`;
                    break;
                }
                case 'power2': {
                    const exp = Math.floor(Math.random() * 6) + 4;
                    answer = Math.pow(2, exp);
                    problemText = `2^${exp}`;
                    break;
                }
                case 'powerBig': {
                    // Larger bases and exponents: 3^5, 5^4, 7^3, etc.
                    const bases = [[3,5],[4,4],[5,4],[6,3],[7,3],[8,3],[9,3],[11,3],[12,3]];
                    const [base, maxExp] = bases[Math.floor(Math.random() * bases.length)];
                    const exp = Math.floor(Math.random() * (maxExp - 2)) + 2;
                    answer = Math.pow(base, exp);
                    problemText = `${base}^${exp}`;
                    break;
                }
                case 'fraction': {
                    const frMax = tier >= 5 ? 15 : 8;
                    const whole = Math.floor(Math.random() * frMax) + 2;
                    const denom = Math.floor(Math.random() * 8) + 2;
                    const numer = Math.floor(Math.random() * (denom - 1)) + 1;
                    answer = whole * denom + numer;
                    problemText = `${whole} ${numer}/${denom} = ?/${denom}`;
                    break;
                }
                case 'chainOps': {
                    // a + b √ó c ‚àí d (long chain, order of operations)
                    const a = Math.floor(Math.random() * 100) + 50;
                    const b = Math.floor(Math.random() * 20) + 5;
                    const c = Math.floor(Math.random() * 15) + 2;
                    const d = Math.floor(Math.random() * 50) + 10;
                    answer = a + b * c - d;
                    problemText = `${a} + ${b} √ó ${c} ‚àí ${d}`;
                    break;
                }
                case 'modulo': {
                    // What is the remainder of a √∑ b?
                    const b = Math.floor(Math.random() * 15) + 3;
                    const a = Math.floor(Math.random() * 200) + 50;
                    answer = a % b;
                    problemText = `${a} mod ${b}`;
                    break;
                }
                default: {
                    const a = Math.floor(Math.random() * maxNum) + 1;
                    const b = Math.floor(Math.random() * maxNum) + 1;
                    answer = a + b;
                    problemText = `${a} + ${b}`;
                }
            }

            gameState.currentAnswer = answer;

            // Update display
            elements.probNum1.textContent = problemText;
            elements.problemSushi.textContent = gameState.towerSushi[gameState.currentHeight] || 'üç£';
            elements.problemInput.value = '';
        }

        // Show problem
        function showProblem() {
            if (gameState.currentHeight >= gameState.maxTowerHeight) {
                // Completed the stack! Show it at top and give new stack
                completeStack();
                return;
            }

            gameState.isShowingProblem = true;
            generateProblem();
            // Update inline equation display instead of showing overlay
            updateInlineDisplay();
            setTimeout(() => elements.inlineInput.focus(), 100);
        }

        // Update inline equation display
        function updateInlineDisplay() {
            // Get the problem text (it's already set in generateProblem)
            elements.equationDisplay.innerHTML = elements.probNum1.textContent + ' <span class="operator">=</span> ?';
            elements.inlineInput.value = '';
            elements.inlineInput.classList.remove('correct', 'wrong');
        }

        // Complete a stack and start a new one
        function completeStack() {
            playStackCompleteSound();
            // Big sparkle burst for completing a stack!
            createSparkles(window.innerWidth / 2, window.innerHeight / 2, '#feca57');
            createSparkles(window.innerWidth / 2 - 50, window.innerHeight / 2 - 30, '#ff6b6b');
            createSparkles(window.innerWidth / 2 + 50, window.innerHeight / 2 + 30, '#48dbfb');

            // Add visual completed stack
            const stackDiv = document.createElement('div');
            stackDiv.className = 'completed-stack';

            const sushiDiv = document.createElement('div');
            sushiDiv.className = 'stack-sushi';
            // Show mini version of the completed stack (just a few sushi)
            for (let i = 0; i < Math.min(5, gameState.towerSushi.length); i++) {
                const s = document.createElement('span');
                s.textContent = gameState.towerSushi[i];
                sushiDiv.appendChild(s);
            }
            if (gameState.towerSushi.length > 5) {
                const more = document.createElement('span');
                more.textContent = '...';
                more.style.fontSize = '0.7rem';
                sushiDiv.appendChild(more);
            }

            const label = document.createElement('div');
            label.className = 'stack-label';
            gameState.completedStacks.push(gameState.towerSushi.length);
            // Also track per-player completed stacks
            gameState.players[gameState.currentPlayerIndex].completedStacks.push([...gameState.towerSushi]);
            label.textContent = `+${gameState.maxTowerHeight}`;

            stackDiv.appendChild(sushiDiv);
            stackDiv.appendChild(label);
            elements.completedStacks.appendChild(stackDiv);

            // Celebrate
            elements.character.classList.add('celebrating');

            // Add points for completing the stack
            gameState.players[gameState.currentPlayerIndex].totalScore += gameState.maxTowerHeight;
            updatePlayerScores();

            // Reset and build new tower
            setTimeout(() => {
                elements.character.classList.remove('celebrating');
                gameState.currentHeight = 0;
                buildTower();
                updateTowerVisuals();
                positionCharacter(false);

                // Continue if time left (or solo mode)
                if (gameState.soloMode || gameState.turnTimeLeft > 0) {
                    setTimeout(() => showProblem(), 300);
                }
            }, 800);
        }

        // Clear completed stacks display
        function clearCompletedStacks() {
            elements.completedStacks.innerHTML = '';
            gameState.completedStacks = [];
        }

        // Hide problem
        function hideProblem() {
            gameState.isShowingProblem = false;
            elements.problemOverlay.classList.remove('show');
        }

        // Check answer
        function checkAnswer() {
            const userAnswer = parseInt(elements.inlineInput.value);
            if (isNaN(userAnswer)) return;

            gameState.isShowingProblem = false;

            if (userAnswer === gameState.currentAnswer) {
                // Correct! - with sparkle effect
                elements.inlineInput.classList.add('correct');
                playCorrectSound();
                playClimbSound();
                showFeedback(true);
                // Sparkle at the input location
                const inputRect = elements.inlineInput.getBoundingClientRect();
                createSparkles(inputRect.left + inputRect.width / 2, inputRect.top + inputRect.height / 2, '#26de81');
                gameState.currentHeight++;
                updateTowerVisuals();
                positionCharacter();

                // Update best height
                if (gameState.currentHeight > gameState.players[gameState.currentPlayerIndex].bestHeight) {
                    gameState.players[gameState.currentPlayerIndex].bestHeight = gameState.currentHeight;
                    updatePlayerScores();
                }

                // Celebrate briefly then show next problem
                elements.character.classList.add('celebrating');
                setTimeout(() => {
                    elements.character.classList.remove('celebrating');
                    if (gameState.soloMode || gameState.turnTimeLeft > 0) {
                        showProblem();
                    }
                }, 800);
            } else {
                // Wrong! Slide down!
                elements.inlineInput.classList.add('wrong');
                playWrongSound();
                showFeedback(false);
                elements.sushiTower.classList.add('shaking');

                setTimeout(() => {
                    elements.sushiTower.classList.remove('shaking');

                    // Start sliding down
                    playFallSound(); // Falling whistle sound
                    elements.character.classList.add('sliding');

                    // Make platforms collapse sequentially from top to bottom
                    const platforms = document.querySelectorAll('.sushi-platform');
                    const completedPlatforms = Array.from(platforms).filter((p, i) => i < gameState.currentHeight);
                    completedPlatforms.reverse().forEach((platform, index) => {
                        setTimeout(() => {
                            platform.classList.add('collapsing');
                        }, index * 100); // Stagger the collapse
                    });

                    // Slide character to bottom
                    elements.character.style.bottom = '200px'; // Base position

                    // Scroll tower back to bottom
                    elements.sushiTower.style.transition = 'transform 1.5s cubic-bezier(0.6, 0.0, 0.8, 0.2)';
                    elements.sushiTower.style.transform = 'translateX(-50%)';

                    // Wait for slide animation to complete (1.5s)
                    setTimeout(() => {
                        playSplatSound(); // Splat when hitting ground
                        elements.character.classList.remove('sliding');

                        // Remove collapsing class from all platforms
                        platforms.forEach(p => p.classList.remove('collapsing'));

                        // Reset tower transition for normal scrolling
                        elements.sushiTower.style.transition = 'transform 0.5s ease-out';

                        if (gameState.soloMode) {
                            // Solo mode - game over on fall!
                            endSoloGame();
                        } else {
                            gameState.currentHeight = 0;
                            updateTowerVisuals();
                            positionCharacter(false);

                            // Continue turn if time left
                            if (gameState.turnTimeLeft > 0) {
                                setTimeout(() => showProblem(), 500);
                            }
                        }
                    }, 1500);
                }, 500);
            }
        }

        // End solo game
        function endSoloGame() {
            const player = gameState.players[0];
            player.lastHeight = gameState.currentHeight;

            // Calculate total score (completed stacks + current height)
            const totalScore = player.completedStacks.length * gameState.maxTowerHeight + gameState.currentHeight;
            player.totalScore = totalScore;

            // Get difficulty name for high score
            let diffName = gameState.difficulty;
            if (gameState.difficulty === 'custom') {
                diffName = `Level ${gameState.customLevel}`;
            }

            // Save to high scores
            const scores = saveHighScore(player.name, totalScore, diffName, player.completedStacks.length);

            // Show solo results
            showSoloResults(player, scores);
        }

        // Show solo results with leaderboard
        function showSoloResults(player, highScores) {
            elements.header.style.display = 'none';
            elements.gameStage.style.display = 'none';

            const rank = highScores.findIndex(s => s.score === player.totalScore && s.name === player.name) + 1;

            // Build completed stacks display
            let stacksHtml = '';
            if (player.completedStacks.length > 0) {
                stacksHtml = '<div class="solo-stacks">';
                player.completedStacks.forEach((stack, idx) => {
                    stacksHtml += '<div class="mini-stack">';
                    for (let j = 0; j < Math.min(5, stack.length); j++) {
                        stacksHtml += `<span class="mini-sushi">${stack[j]}</span>`;
                    }
                    if (stack.length > 5) {
                        stacksHtml += '<span class="mini-more">...</span>';
                    }
                    stacksHtml += '</div>';
                });
                stacksHtml += '</div>';
            }

            // Build leaderboard
            let leaderboardHtml = '<div class="leaderboard"><h3>High Scores</h3><div class="leaderboard-list">';
            highScores.forEach((score, i) => {
                const isCurrentPlayer = score.score === player.totalScore && score.name === player.name && i === rank - 1;
                leaderboardHtml += `
                    <div class="leaderboard-entry ${isCurrentPlayer ? 'current' : ''}">
                        <span class="lb-rank">${i === 0 ? 'üëë' : `#${i + 1}`}</span>
                        <span class="lb-name">${score.name}</span>
                        <span class="lb-score">${score.score}</span>
                        <span class="lb-diff">${score.difficulty}</span>
                    </div>
                `;
            });
            if (highScores.length === 0) {
                leaderboardHtml += '<div class="no-scores">No high scores yet!</div>';
            }
            leaderboardHtml += '</div></div>';

            elements.resultsScreen.querySelector('.results-content').innerHTML = `
                <h1 class="results-title">Game Over!</h1>
                <div class="solo-result">
                    <div class="solo-avatar">${makeCharacterSVG(PLAYER_DATA[0].color, PLAYER_DATA[0].hatColor)}</div>
                    <div class="solo-name">${player.name}</div>
                    <div class="solo-score-big">${player.totalScore}</div>
                    <div class="solo-score-label">Total Sushi Climbed</div>
                    ${rank <= 10 ? `<div class="new-high-score">New High Score! #${rank}</div>` : ''}
                    <div class="solo-stats">
                        <div class="solo-stat">
                            <div class="stat-value">${player.completedStacks.length}</div>
                            <div class="stat-label">Stacks</div>
                        </div>
                        <div class="solo-stat">
                            <div class="stat-value">${player.lastHeight}</div>
                            <div class="stat-label">Last Height</div>
                        </div>
                    </div>
                    ${stacksHtml ? `<div class="stacks-section"><div class="stacks-title">Completed Stacks</div>${stacksHtml}</div>` : ''}
                </div>
                ${leaderboardHtml}
                <button class="start-btn" id="playAgainBtnSolo">Play Again!</button>
            `;

            // Re-attach play again handler
            document.getElementById('playAgainBtnSolo').addEventListener('click', () => {
                elements.resultsScreen.classList.add('hidden');
                elements.startScreen.classList.remove('hidden');
                // Restore original results content structure
                restoreResultsContent();
            });

            elements.resultsScreen.classList.remove('hidden');
        }

        // Restore original results content for multiplayer
        function restoreResultsContent() {
            elements.resultsScreen.querySelector('.results-content').innerHTML = `
                <h1 class="results-title">Game Over!</h1>
                <div class="winner-display">
                    <div class="winner-avatar" id="winnerAvatar">üßë‚Äçüç≥</div>
                    <div class="winner-name" id="winnerName">Player 1</div>
                    <div class="winner-score">Winner with <span id="winnerScore">0</span> sushi climbed!</div>
                </div>
                <div class="final-scores" id="finalScores"></div>
                <button class="start-btn" id="playAgainBtn">Play Again!</button>
            `;
            // Re-attach event listener
            document.getElementById('playAgainBtn').addEventListener('click', () => {
                elements.resultsScreen.classList.add('hidden');
                elements.startScreen.classList.remove('hidden');
            });
            // Update element references
            elements.winnerAvatar = document.getElementById('winnerAvatar');
            elements.winnerName = document.getElementById('winnerName');
            elements.winnerScore = document.getElementById('winnerScore');
            elements.finalScores = document.getElementById('finalScores');
        }

        // Show feedback
        function showFeedback(correct) {
            elements.feedbackFlash.className = 'feedback-flash ' + (correct ? 'correct' : 'wrong');
            setTimeout(() => {
                elements.feedbackFlash.className = 'feedback-flash';
            }, 200);
        }

        // Start turn timer
        function startTurnTimer() {
            gameState.turnTimeLeft = 120;
            updateTimerDisplay();

            gameState.turnTimer = setInterval(() => {
                gameState.turnTimeLeft--;
                updateTimerDisplay();

                if (gameState.turnTimeLeft <= 0) {
                    endTurn();
                }
            }, 1000);
        }

        // End turn
        function endTurn() {
            clearInterval(gameState.turnTimer);
            hideProblem();

            // Save best height, last height, and add to total score
            const player = gameState.players[gameState.currentPlayerIndex];
            player.bestHeight = Math.max(player.bestHeight, gameState.currentHeight);
            player.lastHeight = gameState.currentHeight; // Track where they ended
            player.totalScore += gameState.currentHeight;
            updatePlayerScores();

            // Check if all players have played this round
            gameState.currentPlayerIndex++;
            if (gameState.currentPlayerIndex >= gameState.players.length) {
                // All players finished this round
                if (gameState.currentRound >= gameState.maxRounds) {
                    // All 5 rounds complete - game over!
                    showResults();
                } else {
                    // Start next round
                    gameState.currentRound++;
                    gameState.currentPlayerIndex = 0;
                    updateRoundDisplay();
                    showTurnTransition();
                }
            } else {
                // Next player's turn
                showTurnTransition();
            }
        }

        // Update round display
        function updateRoundDisplay() {
            document.getElementById('roundDisplay').textContent = gameState.currentRound;
        }

        // Show turn transition
        function showTurnTransition() {
            const player = gameState.players[gameState.currentPlayerIndex];
            const pd = PLAYER_DATA[gameState.currentPlayerIndex];
            elements.turnAvatar.innerHTML = makeCharacterSVG(pd.color, pd.hatColor);
            elements.turnName.textContent = player.name;
            elements.turnName.style.color = player.color;

            // Update turn message with round info
            document.querySelector('.turn-message').textContent =
                `Round ${gameState.currentRound} of ${gameState.maxRounds} - Your turn to climb!`;

            elements.turnTransition.classList.add('show');
        }

        // Start turn
        function startTurn() {
            elements.turnTransition.classList.remove('show');

            gameState.currentHeight = 0;
            clearCompletedStacks();
            updateCurrentPlayer();
            updatePlayerScores();
            buildTower();
            updateTowerVisuals();

            setTimeout(() => {
                positionCharacter(false);
                startTurnTimer();
                setTimeout(() => showProblem(), 500);
            }, 300);
        }

        // Show results
        function showResults() {
            elements.header.style.display = 'none';
            elements.gameStage.style.display = 'none';

            // Find winner (by total score across all rounds)
            const sortedPlayers = [...gameState.players].sort((a, b) => b.totalScore - a.totalScore);
            const winner = sortedPlayers[0];

            const winnerIdx = gameState.players.indexOf(winner);
            const winnerPd = PLAYER_DATA[winnerIdx >= 0 ? winnerIdx : 0];
            elements.winnerAvatar.innerHTML = makeCharacterSVG(winnerPd.color, winnerPd.hatColor);
            elements.winnerName.textContent = winner.name;
            elements.winnerName.style.color = winner.color;
            elements.winnerScore.textContent = winner.totalScore;

            // Show all scores with completed stacks
            elements.finalScores.innerHTML = '';
            sortedPlayers.forEach((player, i) => {
                const card = document.createElement('div');
                card.className = 'final-score-card';
                card.style.background = player.color + '40';

                // Build completed stacks display
                let stacksHtml = '';
                if (player.completedStacks.length > 0) {
                    stacksHtml = '<div class="player-stacks">';
                    player.completedStacks.forEach((stack, stackIdx) => {
                        stacksHtml += '<div class="mini-stack">';
                        // Show first 5 sushi of each stack
                        for (let j = 0; j < Math.min(5, stack.length); j++) {
                            stacksHtml += `<span class="mini-sushi">${stack[j]}</span>`;
                        }
                        if (stack.length > 5) {
                            stacksHtml += '<span class="mini-more">...</span>';
                        }
                        stacksHtml += '</div>';
                    });
                    stacksHtml += '</div>';
                }

                // Build current position tower
                let positionHtml = '';
                if (player.lastHeight > 0) {
                    positionHtml = '<div class="position-tower">';
                    for (let j = 0; j < Math.min(player.lastHeight, 5); j++) {
                        positionHtml += `<span class="pos-sushi">${SUSHI_TYPES[j % SUSHI_TYPES.length]}</span>`;
                    }
                    if (player.lastHeight > 5) {
                        positionHtml += `<span class="pos-more">+${player.lastHeight - 5}</span>`;
                    }
                    positionHtml += '</div>';
                }

                const pIdx = gameState.players.indexOf(player);
                const pData = PLAYER_DATA[pIdx >= 0 ? pIdx : 0];
                card.innerHTML = `
                    <div class="rank">${i === 0 ? 'üëë' : `#${i + 1}`}</div>
                    <div class="avatar">${makeCharacterSVG(pData.color, pData.hatColor)}</div>
                    <div class="name">${player.name}</div>
                    <div class="score">${player.totalScore}</div>
                    <div class="score-label">total sushi</div>
                    <div class="stats">
                        <span>Best: ${player.bestHeight}</span>
                        <span>Stacks: ${player.completedStacks.length}</span>
                    </div>
                    ${positionHtml ? `<div class="last-position-label">Last climb:</div>${positionHtml}` : ''}
                    ${stacksHtml ? `<div class="stacks-label">Completed Stacks (${player.completedStacks.length}):</div>${stacksHtml}` : '<div class="no-stacks">No stacks completed</div>'}
                `;
                elements.finalScores.appendChild(card);
            });

            elements.resultsScreen.classList.remove('hidden');
        }

        // Start game
        function startGame() {
            // Get player names and difficulties
            gameState.players = [];
            const inputs = elements.playerNames.querySelectorAll('input[type="text"]');
            const diffSelects = elements.playerNames.querySelectorAll('.player-diff-select');

            inputs.forEach((input, i) => {
                let playerDiff = 'medium';
                if (gameState.perPlayerMode && diffSelects[i]) {
                    const val = diffSelects[i].value;
                    // Check if it's a number (custom level) or preset
                    playerDiff = isNaN(val) ? val : parseInt(val);
                }

                gameState.players.push({
                    name: input.value || PLAYER_DATA[i].name,
                    avatar: PLAYER_DATA[i].avatar,
                    color: PLAYER_DATA[i].color,
                    bestHeight: 0,
                    totalScore: 0,
                    difficulty: playerDiff,
                    completedStacks: [], // Track all completed stacks for this player
                    lastHeight: 0 // Track where they ended
                });
            });

            gameState.currentPlayerIndex = 0;
            gameState.currentRound = 1;

            elements.startScreen.classList.add('hidden');
            elements.header.style.display = 'flex';
            elements.gameStage.style.display = 'flex';

            // Reset round display visibility
            document.getElementById('roundDisplay').parentElement.style.display = '';

            if (gameState.soloMode) {
                // Solo mode - start immediately, no timer
                startSoloGame();
            } else {
                updateRoundDisplay();
                showTurnTransition();
            }
        }

        // Start solo game
        function startSoloGame() {
            const player = gameState.players[0];

            // Update header for solo mode
            document.getElementById('roundDisplay').parentElement.style.display = 'none';
            elements.timerDisplay.textContent = '‚àû';
            elements.timerDisplay.classList.remove('warning');

            gameState.currentHeight = 0;
            clearCompletedStacks();
            updateCurrentPlayer();
            updatePlayerScores();
            buildTower();
            updateTowerVisuals();

            setTimeout(() => {
                positionCharacter(false);
                setTimeout(() => showProblem(), 500);
            }, 300);
        }

        // Event listeners
        document.querySelectorAll('.count-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.count-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                gameState.playerCount = parseInt(btn.dataset.count);
                gameState.soloMode = gameState.playerCount === 1;

                // Show/hide solo mode hint
                const soloHint = document.getElementById('soloModeHint');
                soloHint.style.display = gameState.soloMode ? 'block' : 'none';

                updatePlayerNameInputs();
            });
        });

        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');

                const diff = btn.dataset.diff;
                gameState.difficulty = diff;

                // Show/hide custom slider
                const customContainer = document.getElementById('customDiffContainer');
                if (diff === 'custom') {
                    customContainer.style.display = 'block';
                    gameState.perPlayerMode = false;
                } else {
                    customContainer.style.display = 'none';
                }

                // Handle per-player mode
                if (diff === 'perplayer') {
                    gameState.perPlayerMode = true;
                } else {
                    gameState.perPlayerMode = false;
                }

                // Refresh player inputs to show/hide difficulty selectors
                updatePlayerNameInputs();
            });
        });

        // Custom difficulty slider
        document.getElementById('customDiffSlider').addEventListener('input', (e) => {
            gameState.customLevel = parseInt(e.target.value);
            document.getElementById('customLevelDisplay').textContent = gameState.customLevel;
        });

        document.getElementById('startBtn').addEventListener('click', startGame);

        document.getElementById('readyBtn').addEventListener('click', startTurn);

        document.getElementById('playAgainBtn').addEventListener('click', () => {
            elements.resultsScreen.classList.add('hidden');
            elements.startScreen.classList.remove('hidden');
        });

        document.getElementById('endGameBtn').addEventListener('click', () => {
            if (confirm('Are you sure you want to end the game?')) {
                clearInterval(gameState.turnTimer);
                hideProblem();

                if (gameState.soloMode) {
                    endSoloGame();
                } else {
                    // For multiplayer, save current player's progress and show results
                    const player = gameState.players[gameState.currentPlayerIndex];
                    player.bestHeight = Math.max(player.bestHeight, gameState.currentHeight);
                    player.lastHeight = gameState.currentHeight;
                    player.totalScore += gameState.currentHeight;
                    showResults();
                }
            }
        });

        elements.problemInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                checkAnswer();
            }
        });

        elements.inlineInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                checkAnswer();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (elements.gameStage.style.display !== 'none') {
                positionCharacter(false);
            }
        });

        // Initialize
        updatePlayerNameInputs();
    </script>
</body>
</html>

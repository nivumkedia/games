<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a1a3a;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: white;
        }
        #gameContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100vh;
        }
        #canvasWrap {
            width: 100%;
            height: calc(100vh - 80px);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        canvas#gameCanvas {
            display: block;
            border: 2px solid #00d4ff;
        }
        #bottomBar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            width: 100%;
            height: 80px;
            padding: 10px 16px;
            background: rgba(20,60,120,0.4);
            flex-shrink: 0;
        }
        .panel {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(30,70,140,0.35);
            border-radius: 10px;
            padding: 8px 16px;
        }
        .panel h3 {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #888;
        }
        .panel .value {
            font-size: 22px;
            font-weight: bold;
        }
        #nextPieceCanvas, #holdPieceCanvas {
            display: block;
        }

        #startScreen, #gameOverScreen {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(5,15,40,0.92);
            z-index: 10;
            text-align: center;
        }
        #gameOverScreen { display: none; }
        h1 { font-size: 48px; margin-bottom: 8px; color: #00d4ff; }
        .subtitle { color: #888; font-size: 16px; margin-bottom: 32px; }
        .btn {
            padding: 14px 48px;
            font-size: 20px;
            border: none;
            border-radius: 10px;
            background: #00d4ff;
            color: #0a1a3a;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s;
        }
        .btn:hover { transform: scale(1.05); }
        .btn:active { transform: scale(0.97); }
        .btn-small {
            padding: 8px 16px;
            font-size: 13px;
            border: none;
            border-radius: 8px;
            background: #00d4ff;
            color: #0a1a3a;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s;
        }
        .btn-small:hover { transform: scale(1.05); }
        .btn-small:active { transform: scale(0.97); }
        .btn-secondary {
            padding: 14px 48px;
            font-size: 20px;
            border: 2px solid #00d4ff;
            border-radius: 10px;
            background: transparent;
            color: #00d4ff;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.1s;
            margin-top: 12px;
        }
        .btn-secondary:hover { transform: scale(1.05); }
        .btn-secondary:active { transform: scale(0.97); }
        .instructions {
            margin-top: 24px;
            color: #666;
            font-size: 14px;
            line-height: 2;
            max-width: 350px;
        }
        .instructions span { color: #aaa; }
        #finalScore { font-size: 48px; font-weight: bold; color: #00d4ff; margin: 12px 0 24px; }
        .lineClearFlash {
            position: absolute;
            left: 0;
            height: 34px;
            background: rgba(255,255,255,0.3);
            pointer-events: none;
            animation: flashOut 0.3s ease-out forwards;
            z-index: 5;
        }
        @keyframes flashOut {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }
    </style>
</head>
<body>

<div id="startScreen">
    <h1>TETRIS</h1>
    <div class="subtitle">The classic block-stacking game</div>
    <button class="btn" onclick="startGame()">Play</button>
    <button class="btn-secondary" id="continueBtn" style="display:none;" onclick="loadGame()">Continue</button>
    <div class="instructions">
        <span>&larr; &rarr;</span> Move &nbsp; <span>&uarr;</span> Rotate &nbsp; <span>&darr;</span> Soft Drop<br>
        <span>Space</span> Hard Drop &nbsp; <span>P</span> Pause &nbsp; <span>C</span> Hold
    </div>
</div>

<div id="gameOverScreen">
    <h1>Game Over</h1>
    <div id="finalScore">0</div>
    <button class="btn" onclick="startGame()">Play Again</button>
</div>

<div id="gameContainer" style="display:none;">
    <div id="canvasWrap">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div id="bottomBar">
        <div class="panel">
            <h3>Hold</h3>
            <canvas id="holdPieceCanvas" width="80" height="50"></canvas>
        </div>
        <div class="panel">
            <h3>Score</h3>
            <div class="value" id="score">0</div>
        </div>
        <div class="panel">
            <h3>Best</h3>
            <div class="value" id="best">0</div>
        </div>
        <div class="panel">
            <h3>Lvl</h3>
            <div class="value" id="level">1</div>
        </div>
        <div class="panel">
            <h3>Lines</h3>
            <div class="value" id="lines">0</div>
        </div>
        <div class="panel">
            <h3>Next</h3>
            <canvas id="nextPieceCanvas" width="80" height="50"></canvas>
        </div>
        <button class="btn-small" id="saveBtn" onclick="saveGame()">Save</button>
    </div>
</div>

<script>
const COLS = 10;
const ROWS = 20;
let CELL = 34;
const PAD = 2;
const BOTTOM_BAR_HEIGHT = 80;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const npCanvas = document.getElementById('nextPieceCanvas');
const npCtx = npCanvas.getContext('2d');

const holdCanvas = document.getElementById('holdPieceCanvas');
const holdCtx = holdCanvas.getContext('2d');

function resizeGame() {
    const availH = window.innerHeight - BOTTOM_BAR_HEIGHT;
    const availW = window.innerWidth;
    CELL = Math.floor(Math.min(availH / ROWS, availW / COLS));
    canvas.width = COLS * CELL;
    canvas.height = ROWS * CELL;
    if (board) {
        drawBoard();
        drawNextPiece();
        drawHoldPiece();
    }
}

window.addEventListener('resize', resizeGame);
resizeGame();

// Piece colors (index matches SHAPES)
const PIECE_COLORS = [
    '#00f0f0', // I - cyan
    '#f0f000', // O - yellow
    '#a000f0', // T - purple
    '#00f000', // S - green
    '#f00000', // Z - red
    '#f0a000', // L - orange
    '#0000f0', // J - blue
];

// Tetromino shapes
const SHAPES = [
    // I
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
    // O
    [[1,1],[1,1]],
    // T
    [[0,1,0],[1,1,1],[0,0,0]],
    // S
    [[0,1,1],[1,1,0],[0,0,0]],
    // Z
    [[1,1,0],[0,1,1],[0,0,0]],
    // L
    [[0,0,1],[1,1,1],[0,0,0]],
    // J
    [[1,0,0],[1,1,1],[0,0,0]],
];

// SRS wall kick data
const WALL_KICKS = {
    normal: [
        [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],  // 0->R
        [[0,0],[1,0],[1,-1],[0,2],[1,2]],        // R->2
        [[0,0],[1,0],[1,1],[0,-2],[1,-2]],       // 2->L
        [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],     // L->0
    ],
    I: [
        [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],     // 0->R
        [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],      // R->2
        [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],      // 2->L
        [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],      // L->0
    ],
};

let board, score, best, level, linesCleared, piece, nextPiece, holdPiece, canHold;
let dropTimer, gameOver, paused, dropInterval, lockDelay, lockTimer, lockMoves;
let bag = [];

const MAX_LOCK_MOVES = 15;
const LOCK_DELAY = 500;

function shuffleBag() {
    const indices = [0, 1, 2, 3, 4, 5, 6];
    for (let i = indices.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [indices[i], indices[j]] = [indices[j], indices[i]];
    }
    return indices;
}

function nextFromBag() {
    if (bag.length === 0) bag = shuffleBag();
    return bag.pop();
}

function createPiece() {
    const shapeIdx = nextFromBag();
    const shape = SHAPES[shapeIdx].map(row => [...row]);
    return {
        cells: shape,
        colorIdx: shapeIdx,
        x: Math.floor((COLS - shape[0].length) / 2),
        y: shapeIdx === 0 ? -1 : 0, // I piece starts higher
    };
}

function rotateCells(cells) {
    const n = cells.length;
    const rotated = [];
    for (let c = 0; c < n; c++) {
        rotated.push([]);
        for (let r = n - 1; r >= 0; r--) {
            rotated[c].push(cells[r][c]);
        }
    }
    return rotated;
}

function collides(cells, px, py) {
    for (let r = 0; r < cells.length; r++) {
        for (let c = 0; c < cells[r].length; c++) {
            if (!cells[r][c]) continue;
            const bx = px + c;
            const by = py + r;
            if (bx < 0 || bx >= COLS || by >= ROWS) return true;
            if (by >= 0 && board[by][bx]) return true;
        }
    }
    return false;
}

function isOnGround() {
    return collides(piece.cells, piece.x, piece.y + 1);
}

function resetLock() {
    lockTimer = null;
    lockMoves = 0;
}

function startLockDelay() {
    if (lockTimer === null) {
        lockTimer = Date.now();
    }
}

function lockPiece() {
    const cells = piece.cells;
    for (let r = 0; r < cells.length; r++) {
        for (let c = 0; c < cells[r].length; c++) {
            if (!cells[r][c]) continue;
            const bx = piece.x + c;
            const by = piece.y + r;
            if (by < 0) {
                triggerGameOver();
                return;
            }
            board[by][bx] = piece.colorIdx + 1; // store 1-indexed color
        }
    }
    clearFullRows();
    spawnNext();
}

function spawnNext() {
    piece = nextPiece;
    nextPiece = createPiece();
    canHold = true;
    resetLock();
    if (collides(piece.cells, piece.x, piece.y)) {
        triggerGameOver();
    }
}

function holdCurrentPiece() {
    if (!canHold) return;
    canHold = false;
    const currentIdx = piece.colorIdx;
    if (holdPiece !== null) {
        const tmp = holdPiece;
        holdPiece = currentIdx;
        // Recreate piece from hold
        const shape = SHAPES[tmp].map(row => [...row]);
        piece = {
            cells: shape,
            colorIdx: tmp,
            x: Math.floor((COLS - shape[0].length) / 2),
            y: tmp === 0 ? -1 : 0,
        };
    } else {
        holdPiece = currentIdx;
        spawnNext();
    }
    resetLock();
    drawHoldPiece();
}

function clearFullRows() {
    let cleared = 0;
    for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
            board.splice(r, 1);
            board.unshift(new Array(COLS).fill(0));
            cleared++;
            r++; // recheck this row
        }
    }
    if (cleared > 0) {
        // Standard Tetris scoring
        const points = [0, 100, 300, 500, 800];
        score += (points[cleared] || 800) * level;
        linesCleared += cleared;
        level = Math.floor(linesCleared / 10) + 1;
        dropInterval = Math.max(50, 800 - (level - 1) * 50);
    }
}

function drawRoundRect(context, x, y, w, h, r) {
    if (context.roundRect) {
        context.beginPath();
        context.roundRect(x, y, w, h, r);
        context.fill();
    } else {
        context.fillRect(x, y, w, h);
    }
}

function drawCell(context, x, y, colorIdx, size, pad) {
    if (colorIdx <= 0) return;
    const color = PIECE_COLORS[colorIdx - 1];
    const cx = x * size + pad;
    const cy = y * size + pad;
    const s = size - pad * 2;

    // Main fill
    context.fillStyle = color;
    drawRoundRect(context, cx, cy, s, s, 3);

    // Highlight (top-left)
    context.fillStyle = 'rgba(255,255,255,0.25)';
    context.fillRect(cx + 2, cy + 2, s - 4, 3);
    context.fillRect(cx + 2, cy + 2, 3, s - 4);

    // Shadow (bottom-right)
    context.fillStyle = 'rgba(0,0,0,0.25)';
    context.fillRect(cx + 2, cy + s - 5, s - 4, 3);
    context.fillRect(cx + s - 5, cy + 2, 3, s - 4);
}

function drawBoard() {
    ctx.fillStyle = '#0c1e3d';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Grid lines using fillRect for reliability
    ctx.fillStyle = 'rgba(100,160,255,0.4)';
    for (let r = 0; r <= ROWS; r++) {
        ctx.fillRect(0, r * CELL, canvas.width, 1);
    }
    for (let c = 0; c <= COLS; c++) {
        ctx.fillRect(c * CELL, 0, 1, canvas.height);
    }

    // Board cells
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            drawCell(ctx, c, r, board[r][c], CELL, PAD);
        }
    }

    // Ghost piece
    if (piece && !gameOver && !paused) {
        let ghostY = piece.y;
        while (!collides(piece.cells, piece.x, ghostY + 1)) ghostY++;
        if (ghostY !== piece.y) {
            ctx.globalAlpha = 0.2;
            for (let r = 0; r < piece.cells.length; r++) {
                for (let c = 0; c < piece.cells[r].length; c++) {
                    if (piece.cells[r][c]) {
                        drawCell(ctx, piece.x + c, ghostY + r, piece.colorIdx + 1, CELL, PAD);
                    }
                }
            }
            ctx.globalAlpha = 1;
        }
    }

    // Active piece
    if (piece && !gameOver) {
        for (let r = 0; r < piece.cells.length; r++) {
            for (let c = 0; c < piece.cells[r].length; c++) {
                if (piece.cells[r][c]) {
                    drawCell(ctx, piece.x + c, piece.y + r, piece.colorIdx + 1, CELL, PAD);
                }
            }
        }
    }

    // Pause overlay
    if (paused && !gameOver) {
        ctx.fillStyle = 'rgba(5,15,40,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
    }
}

function drawPreviewPiece(context, canvasEl, shapeIdx) {
    context.clearRect(0, 0, canvasEl.width, canvasEl.height);
    if (shapeIdx === null || shapeIdx === undefined) return;
    const cells = SHAPES[shapeIdx];
    const cellSize = Math.floor(Math.min(canvasEl.width / cells[0].length, canvasEl.height / cells.length));
    const pad = 2;
    const totalW = cells[0].length * cellSize;
    const totalH = cells.length * cellSize;
    const offsetX = (canvasEl.width - totalW) / 2;
    const offsetY = (canvasEl.height - totalH) / 2;
    for (let r = 0; r < cells.length; r++) {
        for (let c = 0; c < cells[r].length; c++) {
            if (cells[r][c]) {
                const color = PIECE_COLORS[shapeIdx];
                const cx = offsetX + c * cellSize + pad;
                const cy = offsetY + r * cellSize + pad;
                const s = cellSize - pad * 2;
                context.fillStyle = color;
                drawRoundRect(context, cx, cy, s, s, 3);
                context.fillStyle = 'rgba(255,255,255,0.25)';
                context.fillRect(cx + 2, cy + 2, s - 4, 2);
                context.fillRect(cx + 2, cy + 2, 2, s - 4);
            }
        }
    }
}

function drawNextPiece() {
    drawPreviewPiece(npCtx, npCanvas, nextPiece ? nextPiece.colorIdx : null);
}

function drawHoldPiece() {
    drawPreviewPiece(holdCtx, holdCanvas, holdPiece);
}

function updateUI() {
    document.getElementById('score').textContent = score;
    document.getElementById('best').textContent = best;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = linesCleared;
}

function saveGame() {
    const state = {
        board, score, level, linesCleared, dropInterval,
        piece, nextPiece: { colorIdx: nextPiece.colorIdx, cells: nextPiece.cells, x: nextPiece.x, y: nextPiece.y },
        holdPiece, canHold, bag,
    };
    localStorage.setItem('tetris_save', JSON.stringify(state));
    const btn = document.getElementById('saveBtn');
    btn.textContent = 'Saved!';
    setTimeout(() => btn.textContent = 'Save', 1000);
}

function loadGame() {
    const data = localStorage.getItem('tetris_save');
    if (!data) return;
    const state = JSON.parse(data);

    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'flex';
    resizeGame();

    board = state.board;
    score = state.score;
    level = state.level;
    linesCleared = state.linesCleared;
    dropInterval = state.dropInterval;
    piece = state.piece;
    nextPiece = state.nextPiece;
    holdPiece = state.holdPiece;
    canHold = state.canHold;
    bag = state.bag;
    best = parseInt(localStorage.getItem('tetris_best') || '0');
    gameOver = false;
    paused = false;
    resetLock();

    updateUI();
    drawBoard();
    drawNextPiece();
    drawHoldPiece();

    cancelAnimationFrame(dropTimer);
    lastDrop = performance.now();
    gameLoop();

    localStorage.removeItem('tetris_save');
}

function triggerGameOver() {
    gameOver = true;
    localStorage.removeItem('tetris_save');
    if (score > best) {
        best = score;
        localStorage.setItem('tetris_best', best);
    }
    document.getElementById('finalScore').textContent = score;
    document.getElementById('gameOverScreen').style.display = 'flex';
}

function startGame() {
    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameOverScreen').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'flex';
    resizeGame();

    board = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
    score = 0;
    level = 1;
    linesCleared = 0;
    dropInterval = 800;
    gameOver = false;
    paused = false;
    holdPiece = null;
    canHold = true;
    bag = [];
    best = parseInt(localStorage.getItem('tetris_best') || '0');

    piece = createPiece();
    nextPiece = createPiece();
    resetLock();

    updateUI();
    alert('Debug: CELL=' + CELL + ' canvas=' + canvas.width + 'x' + canvas.height);
    drawBoard();
    drawNextPiece();
    drawHoldPiece();

    cancelAnimationFrame(dropTimer);
    lastDrop = performance.now();
    gameLoop();
}

let lastDrop = 0;

function gameLoop(now = performance.now()) {
    if (gameOver) return;
    dropTimer = requestAnimationFrame(gameLoop);

    if (paused) return;

    // Auto drop
    if (now - lastDrop >= dropInterval) {
        if (!collides(piece.cells, piece.x, piece.y + 1)) {
            piece.y++;
            if (isOnGround()) startLockDelay();
        }
        lastDrop = now;
    }

    // Lock delay
    if (lockTimer !== null && isOnGround()) {
        if (Date.now() - lockTimer >= LOCK_DELAY) {
            lockPiece();
            resetLock();
            lastDrop = now;
        }
    } else if (lockTimer !== null && !isOnGround()) {
        // Piece moved off ground, cancel lock
        resetLock();
    }

    updateUI();
    drawBoard();
    drawNextPiece();
}

document.addEventListener('keydown', e => {
    if (gameOver) return;

    if (e.key === 'p' || e.key === 'P') {
        paused = !paused;
        drawBoard();
        return;
    }
    if (paused) return;

    switch (e.key) {
        case 'ArrowLeft':
            if (!collides(piece.cells, piece.x - 1, piece.y)) {
                piece.x--;
                if (isOnGround()) {
                    lockMoves++;
                    if (lockMoves < MAX_LOCK_MOVES) lockTimer = Date.now();
                }
            }
            break;
        case 'ArrowRight':
            if (!collides(piece.cells, piece.x + 1, piece.y)) {
                piece.x++;
                if (isOnGround()) {
                    lockMoves++;
                    if (lockMoves < MAX_LOCK_MOVES) lockTimer = Date.now();
                }
            }
            break;
        case 'ArrowDown':
            if (!collides(piece.cells, piece.x, piece.y + 1)) {
                piece.y++;
                score += 1;
                lastDrop = performance.now();
                if (isOnGround()) startLockDelay();
            }
            break;
        case 'ArrowUp': {
            const rotated = rotateCells(piece.cells);
            const kickTable = piece.colorIdx === 0 ? WALL_KICKS.I : WALL_KICKS.normal;
            const rotation = 0; // simplified rotation state
            const kicks = kickTable[rotation];
            let kicked = false;
            for (const [kx, ky] of kicks) {
                if (!collides(rotated, piece.x + kx, piece.y - ky)) {
                    piece.cells = rotated;
                    piece.x += kx;
                    piece.y -= ky;
                    kicked = true;
                    break;
                }
            }
            if (kicked && isOnGround()) {
                lockMoves++;
                if (lockMoves < MAX_LOCK_MOVES) lockTimer = Date.now();
            }
            break;
        }
        case ' ':
            // Hard drop
            let dropDist = 0;
            while (!collides(piece.cells, piece.x, piece.y + 1)) {
                piece.y++;
                dropDist++;
            }
            score += dropDist * 2;
            lockPiece();
            resetLock();
            lastDrop = performance.now();
            break;
        case 'c':
        case 'C':
            holdCurrentPiece();
            break;
    }
    e.preventDefault();
    updateUI();
    drawBoard();
    drawNextPiece();
});

// Load best score and check for saved game
best = parseInt(localStorage.getItem('tetris_best') || '0');
document.getElementById('best').textContent = best;
if (localStorage.getItem('tetris_save')) {
    document.getElementById('continueBtn').style.display = '';
}
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Tag!</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #e8f0f8;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
        }

        /* Screens overlay */
        .screen-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(240,245,255,0.92);
            color: #2d3748;
            text-align: center;
            z-index: 10;
        }
        .screen-overlay.hidden { display: none; }

        .panel {
            background: rgba(255,255,255,0.95);
            border: 2px solid rgba(100,160,255,0.3);
            border-radius: 20px;
            padding: 40px 50px;
            max-width: 520px;
            width: 90%;
            box-shadow: 0 8px 40px rgba(0,50,150,0.12);
            animation: panelIn 0.5s cubic-bezier(0.16,1,0.3,1) forwards;
            max-height: 90vh;
            overflow-y: auto;
        }
        @keyframes panelIn {
            0% { transform: scale(0.5) translateY(30px); opacity: 0; }
            100% { transform: scale(1) translateY(0); opacity: 1; }
        }

        .panel h1 {
            font-size: 48px;
            margin-bottom: 8px;
            background: linear-gradient(90deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s linear infinite;
        }
        @keyframes shimmer {
            0% { background-position: -300% 0; }
            100% { background-position: 300% 0; }
        }

        .panel h2 {
            font-size: 32px;
            margin-bottom: 10px;
            color: #e67e22;
        }

        .panel p {
            font-size: 15px;
            color: #556;
            margin: 6px 0;
            line-height: 1.5;
        }

        .panel .highlight {
            color: #2563eb;
            font-weight: bold;
        }

        .panel .score-big {
            font-size: 56px;
            font-weight: bold;
            color: #6bcb77;
            margin: 15px 0;
        }

        .panel .score-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 14px;
            color: #555;
        }
        .panel .score-row span:last-child {
            color: #2563eb;
            font-weight: bold;
        }

        .panel .high-score {
            margin-top: 12px;
            font-size: 14px;
            color: #e53e3e;
        }

        .btn {
            margin-top: 20px;
            padding: 14px 44px;
            font-size: 20px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #6bcb77, #4d96ff);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
        }
        .btn:hover {
            transform: scale(1.06);
            box-shadow: 0 4px 20px rgba(107,203,119,0.4);
        }

        .instructions {
            background: rgba(0,80,200,0.06);
            border-radius: 10px;
            padding: 14px 18px;
            margin: 14px 0;
            text-align: left;
        }
        .instructions p {
            font-size: 13px;
            margin: 4px 0;
        }
        .instructions .section-title {
            font-size: 12px;
            color: #888a;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 10px;
            margin-bottom: 2px;
        }

        /* Settings panel */
        #settingsScreen {
            z-index: 12;
        }
        #settingsScreen .panel {
            max-width: 560px;
            padding: 30px 36px;
        }
        .settings-section {
            background: rgba(0,80,200,0.05);
            border-radius: 10px;
            padding: 12px 16px;
            margin: 10px 0;
            text-align: left;
        }
        .settings-section h3 {
            font-size: 13px;
            color: #2563eb;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        .size-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 6px;
        }
        .size-btn {
            padding: 8px 4px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            background: rgba(0,80,200,0.04);
            color: #555;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }
        .size-btn:hover { border-color: rgba(37,99,235,0.4); color: #333; }
        .size-btn.selected {
            border-color: #2563eb;
            background: rgba(37,99,235,0.1);
            color: #2563eb;
        }
        .size-btn small {
            display: block;
            font-size: 9px;
            font-weight: normal;
            color: #999;
            margin-top: 2px;
        }
        .toggle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
        }
        .toggle-btn {
            padding: 7px 6px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: 8px;
            background: rgba(0,80,200,0.03);
            color: #777;
            font-size: 11px;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s;
        }
        .toggle-btn:hover { border-color: rgba(0,0,0,0.25); }
        .toggle-btn.on {
            border-color: var(--tc, #6bcb77);
            background: rgba(107,203,119,0.12);
            color: #333;
        }
        .settings-info {
            font-size: 12px;
            color: #777;
            margin-top: 8px;
            text-align: center;
        }
        .btn-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 16px;
        }
        .btn-sm {
            padding: 10px 28px;
            font-size: 15px;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.15s;
        }
        .btn-sm:hover { transform: scale(1.05); }
        .btn-settings {
            margin-top: 12px;
            padding: 10px 30px;
            font-size: 15px;
            border: 2px solid rgba(0,0,0,0.12);
            border-radius: 10px;
            background: rgba(0,80,200,0.06);
            color: #555;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-settings:hover {
            border-color: rgba(37,99,235,0.4);
            color: #2563eb;
        }

        /* Touch controls */
        #touch-controls {
            display: none;
            position: fixed;
            bottom: 0; left: 0; right: 0;
            height: 200px;
            z-index: 5;
            pointer-events: none;
        }
        #joystick-area {
            position: absolute;
            left: 20px;
            bottom: 20px;
            width: 140px;
            height: 140px;
            pointer-events: auto;
        }
        #dash-btn-touch {
            position: absolute;
            right: 30px;
            bottom: 50px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255,107,107,0.6);
            border: 3px solid rgba(255,107,107,0.9);
            color: white;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
        }
        #use-powerup-touch {
            position: absolute;
            right: 130px;
            bottom: 60px;
            width: 65px;
            height: 65px;
            border-radius: 50%;
            background: rgba(59,130,246,0.5);
            border: 3px solid rgba(59,130,246,0.8);
            color: white;
            font-size: 12px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            user-select: none;
        }
        /* Tutorial highlight for settings sections */
        .tutorial-highlight-section {
            outline: 3px solid #4d96ff;
            outline-offset: 4px;
            border-radius: 12px;
            animation: tutorialPulse 1.2s ease-in-out infinite;
            position: relative;
            z-index: 1;
        }
        @keyframes tutorialPulse {
            0%, 100% { outline-color: rgba(77,150,255,0.8); }
            50% { outline-color: rgba(77,150,255,0.3); }
        }
    </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="touch-controls">
    <div id="joystick-area"></div>
    <div id="dash-btn-touch">DASH</div>
    <div id="use-powerup-touch">USE</div>
</div>

<!-- Start Screen -->
<div id="startScreen" class="screen-overlay">
    <div class="panel">
        <h1>TAG!</h1>
        <p style="font-size:18px; color:#666; margin-bottom:10px;">Don't be IT!</p>
        <div class="instructions">
            <p><span class="highlight">WASD / Arrows</span> ‚Äî Move &nbsp; <span class="highlight">Space</span> ‚Äî Dash</p>
            <p><span class="highlight">E</span> ‚Äî Use stored powerup &nbsp; <span class="highlight">3 rounds</span> of 60s</p>
            <p><span class="highlight">Goal:</span> Avoid being tagged! Score = time NOT being IT</p>
            <p class="section-title">Powerups</p>
            <p><span style="color:#ffd700;">‚òÖ Invincible</span> ‚Äî Can't become IT for 8s</p>
            <p><span style="color:#3b82f6;">üõ° Shield</span> ‚Äî Stored! Press E to block tags for 8s</p>
            <p><span style="color:#facc15;">‚ö° Speed Surge</span> ‚Äî 3x speed for 5s</p>
            <p><span style="color:#22d3ee;">‚ùÑ Freeze</span> ‚Äî Freezes all bots for 3s</p>
            <p><span style="color:#a855f7;">‚Üî Swap</span> ‚Äî Swap position with a random bot</p>
            <p><span style="color:#34d399;">‚óÜ Shrink</span> ‚Äî Become tiny for 6s</p>
            <p class="section-title">Danger</p>
            <p><span style="color:#dc2626;">HUNTER</span> ‚Äî Always chases YOU! Tag it to stun for 5s!</p>
            <p><span style="color:#ef4444;">Lava</span> ‚Äî Makes YOU become IT! &nbsp; <span style="color:#ff8c00;">Idle 3s</span> ‚Äî You're IT!</p>
        </div>
        <p class="high-score" id="startHighScore"></p>
        <button class="btn" id="startBtn">Play!</button>
        <br>
        <button class="btn-settings" id="openSettingsBtn">Settings</button>
        <button class="btn-settings" id="openTutorialBtn" style="margin-top:6px;">Tutorial</button>
    </div>
</div>

<!-- Settings Screen -->
<div id="settingsScreen" class="screen-overlay hidden">
    <div class="panel">
        <h2 style="font-size:24px;">Settings</h2>

        <div class="settings-section">
            <h3>Tag Type</h3>
            <div class="size-grid" id="tagTypeGrid" style="grid-template-columns: repeat(3, 1fr);"></div>
            <div id="ballCountSection" style="display:none; margin-top:10px;">
                <div style="display:flex; align-items:center; justify-content:space-between;">
                    <span style="font-size:12px; color:#555; font-weight:bold;">Balls</span>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <button class="size-btn" id="ballCountDown" style="width:30px; padding:4px 0;">‚àí</button>
                        <span id="ballCountDisplay" style="font-size:16px; font-weight:bold; color:#2563eb; min-width:24px; text-align:center;">1</span>
                        <button class="size-btn" id="ballCountUp" style="width:30px; padding:4px 0;">+</button>
                    </div>
                </div>
                <p style="font-size:10px; color:#999; margin-top:4px; text-align:right;" id="ballCountInfo">1 ball at a time</p>
            </div>
            <div id="freezeTeamSection" style="display:none; margin-top:10px;">
                <div style="display:flex; align-items:center; justify-content:space-between;">
                    <span style="font-size:12px; color:#555; font-weight:bold;">Your Team</span>
                    <div style="display:flex; gap:6px;" id="freezeTeamBtns">
                        <button class="size-btn" id="teamBlueBtn" style="padding:4px 12px; color:#4d96ff; font-weight:bold;">üîµ Blue (Runner)</button>
                        <button class="size-btn" id="teamRedBtn" style="padding:4px 12px; color:#ff4444; font-weight:bold;">üî¥ Red (Tagger)</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="settings-section">
            <h3>Arena Size</h3>
            <div class="size-grid" id="sizeGrid"></div>
            <p class="settings-info" id="sizeInfo">‚Äî</p>
        </div>

        <div class="settings-section">
            <h3>Powerups</h3>
            <div class="toggle-grid" id="powerupGrid"></div>
        </div>

        <div class="settings-section">
            <h3>Arena Elements</h3>
            <div class="toggle-grid" id="elementGrid"></div>
        </div>

        <div class="btn-row">
            <button class="btn-sm" style="background:rgba(255,255,255,0.1);color:#ccc;" id="settingsBackBtn">Back</button>
            <button class="btn-sm" style="background:linear-gradient(135deg,#6bcb77,#4d96ff);color:#000;" id="settingsSaveBtn">Save & Back</button>
        </div>
    </div>
</div>

<!-- Round End Screen -->
<div id="roundEndScreen" class="screen-overlay hidden">
    <div class="panel">
        <h2 id="roundEndTitle">Round Complete!</h2>
        <div class="score-big" id="roundScore">0</div>
        <p id="roundScoreDesc">seconds not being IT</p>
        <p id="roundEndInfo" style="margin-top:10px;"></p>
        <button class="btn" id="nextRoundBtn">Next Round</button>
    </div>
</div>

<!-- Game Over Screen -->
<div id="gameOverScreen" class="screen-overlay hidden">
    <div class="panel">
        <h2>Game Over!</h2>
        <div class="score-big" id="finalScore">0</div>
        <p style="margin-bottom:12px;">Total Survival Score</p>
        <div id="roundBreakdown"></div>
        <p class="high-score" id="endHighScore"></p>
        <button class="btn" id="playAgainBtn">Play Again</button>
    </div>
</div>

<!-- Tutorial Welcome Screen -->
<div id="tutorialScreen" class="screen-overlay hidden">
    <div class="panel">
        <h1>Tutorial</h1>
        <p style="font-size:16px; color:#666; margin-bottom:16px;">Learn how to play Tag!</p>
        <p style="font-size:14px; color:#888;">We'll walk you through controls, arena elements, powerups, and settings.</p>
        <button class="btn" id="tutorialStartBtn">Start Tutorial</button>
        <br>
        <button class="btn-settings" id="tutorialSkipBtn" style="margin-top:8px;">Skip</button>
    </div>
</div>

<!-- Tutorial Tooltip (floating during gameplay) -->
<div id="tutorialTooltip" style="display:none; position:fixed; z-index:15; pointer-events:auto;">
    <div style="background:rgba(255,255,255,0.96); border:2px solid rgba(37,99,235,0.4); border-radius:14px; padding:16px 20px; max-width:340px; box-shadow:0 6px 30px rgba(0,50,150,0.18); font-family:'Segoe UI',Arial,sans-serif;">
        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
            <span id="ttIcon" style="font-size:22px;"></span>
            <span id="ttTitle" style="font-size:16px; font-weight:bold; color:#2d3748;"></span>
        </div>
        <p id="ttText" style="font-size:13px; color:#556; line-height:1.5; margin:6px 0;"></p>
        <p id="ttHint" style="font-size:11px; color:#2563eb; font-weight:bold; margin:8px 0 4px;"></p>
        <div id="ttProgress" style="height:4px; background:rgba(0,80,200,0.1); border-radius:2px; margin-top:10px; overflow:hidden;">
            <div id="ttProgressBar" style="height:100%; background:linear-gradient(90deg,#6bcb77,#4d96ff); border-radius:2px; transition:width 0.3s;"></div>
        </div>
        <div style="display:flex; gap:8px; margin-top:10px; justify-content:flex-end;">
            <button id="ttSkip" style="padding:6px 14px; font-size:12px; border:1px solid rgba(0,0,0,0.15); border-radius:6px; background:#fff; color:#888; cursor:pointer; font-weight:bold;">Skip All</button>
            <button id="ttNext" style="display:none; padding:6px 14px; font-size:12px; border:none; border-radius:6px; background:linear-gradient(135deg,#6bcb77,#4d96ff); color:#000; cursor:pointer; font-weight:bold;">Next</button>
        </div>
    </div>
</div>

<!-- Tutorial Highlight Overlay (for HUD/settings highlights) -->
<div id="tutorialHighlight" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:14; pointer-events:none;">
    <canvas id="highlightCanvas" style="width:100%; height:100%;"></canvas>
</div>

<script>
// ============================================================
// TAG GAME - Full implementation with arena elements
// ============================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- Constants (dynamic arena) ---
let ARENA_W = 2400;
let ARENA_H = 1800;
const PLAYER_RADIUS = 18;
const AI_RADIUS = 16;
const TAG_DISTANCE = 34;
const PLAYER_SPEED = 220;
const DASH_SPEED = 480;
const DASH_DURATION = 0.4;
const DASH_COOLDOWN = 3;
const ROUND_TIME = 60;
const TOTAL_ROUNDS = 3;
const TAG_IMMUNITY_TIME = 1.5;
const CAMERA_LERP = 0.08;

// --- Arena obstacles (regenerated per settings) ---
let WALLS = [
    // Border walls
    { x: 0, y: 0, w: ARENA_W, h: 20 },
    { x: 0, y: ARENA_H - 20, w: ARENA_W, h: 20 },
    { x: 0, y: 0, w: 20, h: ARENA_H },
    { x: ARENA_W - 20, y: 0, w: 20, h: ARENA_H },
    // Interior obstacles ‚Äî spread for bigger arena
    { x: 400, y: 300, w: 180, h: 30 },
    { x: 400, y: 300, w: 30, h: 180 },
    { x: 900, y: 500, w: 200, h: 30 },
    { x: 1600, y: 300, w: 30, h: 250 },
    { x: 1600, y: 300, w: 180, h: 30 },
    { x: 500, y: 800, w: 30, h: 220 },
    { x: 500, y: 990, w: 180, h: 30 },
    { x: 1100, y: 900, w: 220, h: 40 },
    { x: 1100, y: 900, w: 40, h: 180 },
    { x: 1800, y: 700, w: 30, h: 280 },
    { x: 1800, y: 950, w: 200, h: 30 },
    { x: 300, y: 1400, w: 280, h: 30 },
    { x: 800, y: 1500, w: 30, h: 150 },
    { x: 1500, y: 1400, w: 220, h: 30 },
    { x: 1500, y: 1400, w: 30, h: 150 },
    { x: 2000, y: 400, w: 30, h: 200 },
    { x: 2000, y: 1200, w: 200, h: 30 },
    // Central structure
    { x: 1050, y: 750, w: 220, h: 30 },
    { x: 1050, y: 750, w: 30, h: 180 },
    { x: 1240, y: 750, w: 30, h: 180 },
    { x: 1050, y: 900, w: 220, h: 30 },
];

// --- Portal pairs (A <-> B) ---
let PORTALS = [
    { ax: 300, ay: 300, bx: 2100, by: 1500, radius: 30, color1: '#a855f7', color2: '#7c3aed' },
];

// --- Trampolines ---
let TRAMPOLINES = [
    { x: 1200, y: 900, w: 50, h: 50 },
];
const TRAMPOLINE_LAUNCH_SPEED = 550;
const TRAMPOLINE_DURATION = 0.25;

// --- Lava pools ---
let LAVA_POOLS = [
    { x: 800, y: 700, radius: 50 },
    { x: 1800, y: 1200, radius: 45 },
];
const LAVA_SLOW_FACTOR = 0.45;

// --- Speed pads ---
let SPEED_PADS = [
    { x: 1000, y: 400, w: 60, h: 25, angle: 0 },
    { x: 1500, y: 1300, w: 60, h: 25, angle: Math.PI / 4 },
];
const SPEED_BOOST_MULT = 2.0;
const SPEED_BOOST_DURATION = 2.0;

// --- Ice patches ---
let ICE_PATCHES = [
    { x: 1400, y: 800, radius: 55 },
];
const ICE_FRICTION = 0.97; // per-frame velocity retention (normal = instant stop)

// --- Bumpers ---
let BUMPERS = [
    { x: 1000, y: 1000, radius: 22 },
    { x: 1800, y: 600, radius: 22 },
];
const BUMPER_FORCE = 400;

// --- Colors ---
const COLORS = [
    '#4d96ff', // player blue
    '#ff6b6b', // red
    '#ffd93d', // yellow
    '#6bcb77', // green
    '#a66cff', // purple
    '#ff9a3c', // orange
    '#ff6eb4', // pink
    '#00d2d3', // cyan
    '#e879f9', // magenta
    '#34d399', // emerald
    '#fca5a5', // coral
    '#818cf8', // indigo
    '#dc2626', // crimson (hunter)
];

const AI_NAMES = ['Rex', 'Zippy', 'Bubbles', 'Shadow', 'Dash', 'Sparky', 'Wiggles', 'Blitz', 'Nemo', 'Luna', 'Ziggy', 'HUNTER'];

// --- Game state ---
let gameState = 'start'; // start, playing, roundEnd, gameOver
let currentRound = 0;
let roundTimer = 0;
let roundScores = [];
let totalScore = 0;
let highScore = parseInt(localStorage.getItem('tag-game-highscore')) || 0;
let gameTime = 0; // for animations

// Camera
let camX = 0, camY = 0;

// Player
let player = null;

// AI characters
let aiChars = [];

// Who is IT
let itIndex = -1; // -1 = player is IT, 0-6 = AI index

// Tag immunity timer
let immunityTimer = 0;

// Particles
let particles = [];

// Dash trail
let dashTrails = [];

// Confetti
let confetti = [];

// Status banner
let statusBanner = { text: '', timer: 0, color: '#fff' };

// Idle timeout
let idleTimer = 0;
const IDLE_TIMEOUT = 3; // seconds

// Hunter stun
let hunterStunTimer = 0; // 5s countdown when hunter is tagged

// --- Powerup system ---
const POWERUP_TYPES = {
    invincible: { name: 'Invincible', color: '#ffd700', icon: '‚òÖ', duration: 8, stored: false, desc: 'Cannot become IT for 8s' },
    shield:     { name: 'Shield', color: '#3b82f6', icon: 'üõ°', duration: 8, stored: true, desc: 'Press E to activate ‚Äî blocks tag for 8s' },
    speed:      { name: 'Speed Surge', color: '#facc15', icon: '‚ö°', duration: 5, stored: false, desc: '3x speed for 5s' },
    freeze:     { name: 'Freeze Blast', color: '#22d3ee', icon: '‚ùÑ', duration: 3, stored: false, desc: 'Freezes all bots for 3s' },
    swap:       { name: 'Swap', color: '#a855f7', icon: '‚Üî', duration: 0, stored: false, desc: 'Swap positions with a random bot' },
    shrink:     { name: 'Shrink', color: '#34d399', icon: '‚óÜ', duration: 6, stored: false, desc: 'Become tiny for 6s' },
};
let POWERUP_KEYS = Object.keys(POWERUP_TYPES);
const POWERUP_SPAWN_INTERVAL = 8; // seconds between spawns
const MAX_POWERUPS = 3; // max on field at once
let powerups = []; // active pickups on the field
let powerupSpawnTimer = 5; // start with first spawn after 5s

// Player active effects
let playerInvincible = 0; // timer
let playerSpeedSurge = 0;
let playerShrink = 0;
let freezeTimer = 0; // global freeze on bots
let storedPowerup = null; // stored powerup key (e.g. 'shield')
let useStoredPressed = false;
let touchUseStored = false;

// --- Visual effects state ---
// Ambient floating particles (fireflies/dust)
let ambientParticles = [];
const MAX_AMBIENT = 60;

// Screen shake
let shakeTimer = 0;
let shakeIntensity = 0;

// Shockwave rings (on tag events)
let shockwaves = [];

// --- Tag mode state ---
let tagMode = 'classic'; // 'classic', 'ball', 'banana', 'freeze', 'zombie'
let balls = []; // Ball tag: array of {x, y, vx, vy, life, throwerIdx}
let ballCooldown = 0; // Cooldown between throws
const BALL_SPEED = 500;
const BALL_LIFETIME = 2.0;
const BALL_RADIUS = 8;
const BALL_COOLDOWN = 1.5;
let frozenPlayers = new Set(); // Indices of frozen bots (banana/freeze)
let playerFrozen = false; // Is the player frozen
let zombies = new Set(); // Indices of zombie bots
let playerIsZombie = false;
let teams = { blue: [], red: [] }; // For freeze tag
let frozenBy = new Map(); // Banana tag: maps frozen index ‚Üí tagger index (-1 = player)
let playerFrozenBy = -2; // Who froze the player (-2 = not frozen, -1 = player, 0+ = bot index)
let bananaImmunity = new Map(); // Banana tag: brief immunity after unfreeze (index ‚Üí timer)
let playerBananaImmunity = 0; // Player's banana immunity timer
let zombieBonus = 0; // Bonus points for zombie mode

// Footstep trails
let footsteps = [];
const FOOTSTEP_INTERVAL = 0.08; // seconds between footsteps
let playerFootstepTimer = 0;

// Emotion particles (sweat, steam, hearts)
let emotionParticles = [];

// Speed lines (when dashing)
let speedLines = [];

// Input
let keys = {};
let dashPressed = false;

// Touch
let isTouchDevice = false;
let joystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0 };
let touchDash = false;

// Delta time
let lastTime = 0;

// Difficulty scaling
let difficultyMult = 1;

// Trampoline animation state
let trampolineAnims = [];

// --- Resize ---
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// --- Input ---
document.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key === ' ' || e.key.startsWith('Arrow')) {
        e.preventDefault();
    }
    if (e.key === ' ') {
        dashPressed = true;
    }
    if (e.key.toLowerCase() === 'e') {
        useStoredPressed = true;
    }
});
document.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
});

// Touch detection
function detectTouch() {
    isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
    document.getElementById('touch-controls').style.display = isTouchDevice ? 'block' : 'none';
}
detectTouch();

// Joystick
const joystickArea = document.getElementById('joystick-area');
joystickArea.addEventListener('touchstart', e => {
    e.preventDefault();
    joystick.active = true;
    const rect = joystickArea.getBoundingClientRect();
    joystick.startX = rect.left + rect.width / 2;
    joystick.startY = rect.top + rect.height / 2;
    joystick.dx = 0;
    joystick.dy = 0;
});
joystickArea.addEventListener('touchmove', e => {
    e.preventDefault();
    if (!joystick.active) return;
    const t = e.touches[0];
    joystick.dx = t.clientX - joystick.startX;
    joystick.dy = t.clientY - joystick.startY;
    const maxDist = 60;
    const d = Math.sqrt(joystick.dx * joystick.dx + joystick.dy * joystick.dy);
    if (d > maxDist) {
        joystick.dx = (joystick.dx / d) * maxDist;
        joystick.dy = (joystick.dy / d) * maxDist;
    }
});
joystickArea.addEventListener('touchend', e => {
    e.preventDefault();
    joystick.active = false;
    joystick.dx = 0;
    joystick.dy = 0;
});

// Dash button
const dashBtnTouch = document.getElementById('dash-btn-touch');
dashBtnTouch.addEventListener('touchstart', e => {
    e.preventDefault();
    touchDash = true;
});
dashBtnTouch.addEventListener('touchend', e => {
    e.preventDefault();
    touchDash = false;
});

// Use powerup button
const usePowerupTouch = document.getElementById('use-powerup-touch');
usePowerupTouch.addEventListener('touchstart', e => {
    e.preventDefault();
    touchUseStored = true;
});
usePowerupTouch.addEventListener('touchend', e => {
    e.preventDefault();
    touchUseStored = false;
});

// --- Utility ---
function dist(a, b) {
    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function distXY(x1, y1, x2, y2) {
    return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
}

function clamp(v, mn, mx) {
    return Math.max(mn, Math.min(mx, v));
}

function randRange(a, b) {
    return a + Math.random() * (b - a);
}

function rectContains(r, px, py, radius) {
    const cx = clamp(px, r.x, r.x + r.w);
    const cy = clamp(py, r.y, r.y + r.h);
    const dx = px - cx;
    const dy = py - cy;
    return dx * dx + dy * dy < radius * radius;
}

function pointInRect(px, py, r) {
    return px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h;
}

function pointInCircle(px, py, cx, cy, cr) {
    return distXY(px, py, cx, cy) < cr;
}

function resolveWallCollision(px, py, radius) {
    let nx = px, ny = py;
    for (const w of WALLS) {
        const cx = clamp(nx, w.x, w.x + w.w);
        const cy = clamp(ny, w.y, w.y + w.h);
        const dx = nx - cx;
        const dy = ny - cy;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < radius && d > 0) {
            nx = cx + (dx / d) * radius;
            ny = cy + (dy / d) * radius;
        } else if (d === 0) {
            const pushX = nx - (w.x + w.w / 2);
            const pushY = ny - (w.y + w.h / 2);
            const pd = Math.sqrt(pushX * pushX + pushY * pushY) || 1;
            nx += (pushX / pd) * (radius + 2);
            ny += (pushY / pd) * (radius + 2);
        }
    }
    return { x: nx, y: ny };
}

function findSpawnPoint(existingPositions) {
    for (let attempt = 0; attempt < 100; attempt++) {
        const x = randRange(60, ARENA_W - 60);
        const y = randRange(60, ARENA_H - 60);
        let valid = true;
        for (const w of WALLS) {
            if (rectContains(w, x, y, 30)) { valid = false; break; }
        }
        if (valid) {
            for (const lp of LAVA_POOLS) {
                if (pointInCircle(x, y, lp.x, lp.y, lp.radius + 20)) { valid = false; break; }
            }
        }
        if (valid) {
            for (const p of existingPositions) {
                if (dist({x, y}, p) < 80) { valid = false; break; }
            }
        }
        if (valid) return { x, y };
    }
    return { x: ARENA_W / 2, y: ARENA_H / 2 };
}

// --- Create entities ---
function createPlayer() {
    const pos = findSpawnPoint([]);
    return {
        x: pos.x, y: pos.y,
        vx: 0, vy: 0,
        radius: PLAYER_RADIUS,
        color: COLORS[0],
        dashCooldown: 0,
        isDashing: false,
        dashTimer: 0,
        dashDirX: 0, dashDirY: 0,
        faceDirX: 1, faceDirY: 0,
        survivalTime: 0,
        expression: 'normal',
        // Element interaction state
        portalCooldown: 0,
        speedBoostTimer: 0,
        onIce: false,
        onLava: false,
        lavaFlashTimer: 0,
        trampolineLaunchTimer: 0,
        trampolineDirX: 0, trampolineDirY: 0,
    };
}

function createAI(index, existingPositions, forceHunter) {
    const pos = findSpawnPoint(existingPositions);
    const basePers = ['chaser', 'flanker', 'patrol', 'coward', 'random', 'smart', 'speedy'];
    const baseSpeeds = [170, 160, 140, 180, 150, 165, 200];
    const personality = forceHunter ? 'hunter' : basePers[index % basePers.length];
    const baseSpd = forceHunter ? 190 : baseSpeeds[index % baseSpeeds.length];
    const isHunter = forceHunter || false;
    const colorIdx = (index + 1) % COLORS.length;
    const nameIdx = index % AI_NAMES.length;
    return {
        x: pos.x, y: pos.y,
        vx: 0, vy: 0,
        radius: isHunter ? 20 : AI_RADIUS,
        color: isHunter ? '#dc2626' : COLORS[colorIdx],
        name: isHunter ? 'HUNTER' : AI_NAMES[nameIdx],
        personality: personality,
        isHunter: isHunter,
        baseSpeed: baseSpd,
        speed: baseSpd,
        dashCooldown: 0,
        isDashing: false,
        dashTimer: 0,
        dashDirX: 0, dashDirY: 0,
        faceDirX: 1, faceDirY: 0,
        survivalTime: 0,
        expression: 'normal',
        targetX: pos.x, targetY: pos.y,
        retargetTimer: 0,
        patrolAngle: Math.random() * Math.PI * 2,
        // Element interaction state
        portalCooldown: 0,
        speedBoostTimer: 0,
        onIce: false,
        onLava: false,
        lavaFlashTimer: 0,
        trampolineLaunchTimer: 0,
        trampolineDirX: 0, trampolineDirY: 0,
    };
}

// --- Initialize round ---
function initRound() {
    const positions = [];
    player = createPlayer();
    positions.push({ x: player.x, y: player.y });

    aiChars = [];
    const numBots = getNumBots();
    // Create normal bots
    for (let i = 0; i < numBots; i++) {
        const ai = createAI(i, positions, false);
        positions.push({ x: ai.x, y: ai.y });
        aiChars.push(ai);
    }
    // Always add one hunter
    const hunter = createAI(numBots, positions, true);
    positions.push({ x: hunter.x, y: hunter.y });
    aiChars.push(hunter);

    // Reset hunter stun
    hunterStunTimer = 0;

    // Reset tag mode state
    tagMode = settings.tagType;
    balls = [];
    ballCooldown = 0;
    frozenPlayers = new Set();
    playerFrozen = false;
    zombies = new Set();
    playerIsZombie = false;
    teams = { blue: [], red: [] };
    frozenBy = new Map();
    playerFrozenBy = -2;
    bananaImmunity = new Map();
    playerBananaImmunity = 0;
    zombieBonus = 0;

    // Mode-specific IT assignment
    if (tagMode === 'banana') {
        // Everyone is IT ‚Äî no one starts frozen
        itIndex = 0; // Arbitrary, not really used in banana mode
        player.expression = 'normal';
        for (let i = 0; i < aiChars.length; i++) {
            if (!aiChars[i].isHunter) aiChars[i].expression = 'normal';
        }
    } else if (tagMode === 'freeze') {
        // Split bots into two teams, player joins chosen team
        const playerTeam = settings.freezeTeam || 'blue';
        let nonHunterBots = [];
        for (let i = 0; i < aiChars.length; i++) {
            if (!aiChars[i].isHunter) nonHunterBots.push(i);
        }
        // Shuffle
        for (let i = nonHunterBots.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [nonHunterBots[i], nonHunterBots[j]] = [nonHunterBots[j], nonHunterBots[i]];
        }
        // Player takes one slot on their team, so give the other team one more bot
        const halfCount = Math.floor(nonHunterBots.length / 2);
        if (playerTeam === 'blue') {
            teams.blue = nonHunterBots.slice(0, halfCount);
            teams.red = nonHunterBots.slice(halfCount);
        } else {
            teams.red = nonHunterBots.slice(0, halfCount);
            teams.blue = nonHunterBots.slice(halfCount);
        }
        // Mark team colors
        for (const idx of teams.blue) {
            aiChars[idx].team = 'blue';
            aiChars[idx].color = '#4d96ff';
        }
        for (const idx of teams.red) {
            aiChars[idx].team = 'red';
            aiChars[idx].color = '#ff4444';
            aiChars[idx].expression = 'it';
            aiChars[idx]._freezeChaseTarget = undefined;
        }
        player.team = playerTeam;
        itIndex = teams.red[0]; // Red team are all "IT"
        player.expression = playerTeam === 'red' ? 'it' : 'happy';
    } else if (tagMode === 'zombie') {
        // Pick one bot as initial zombie
        let candidates = [];
        for (let i = 0; i < aiChars.length; i++) {
            if (!aiChars[i].isHunter) candidates.push(i);
        }
        const zombieIdx = candidates[Math.floor(Math.random() * candidates.length)];
        zombies.add(zombieIdx);
        aiChars[zombieIdx].expression = 'it';
        itIndex = zombieIdx;
        player.expression = 'happy';
    } else {
        // Classic and Ball Tag: random IT assignment
        if (Math.random() < 0.3) {
            itIndex = -1;
            player.expression = 'it';
        } else {
            let candidates = [];
            for (let i = 0; i < aiChars.length; i++) {
                if (!aiChars[i].isHunter) candidates.push(i);
            }
            itIndex = candidates[Math.floor(Math.random() * candidates.length)];
            aiChars[itIndex].expression = 'it';
            player.expression = 'happy';
        }
    }

    immunityTimer = TAG_IMMUNITY_TIME;
    idleTimer = 0;
    roundTimer = ROUND_TIME;
    particles = [];
    dashTrails = [];
    confetti = [];
    trampolineAnims = [];
    ambientParticles = [];
    shockwaves = [];
    footsteps = [];
    emotionParticles = [];
    speedLines = [];
    shakeTimer = 0;
    powerups = [];
    powerupSpawnTimer = 5;
    playerInvincible = 0;
    playerSpeedSurge = 0;
    playerShrink = 0;
    freezeTimer = 0;
    storedPowerup = null;
    if (isTouchDevice) usePowerupTouch.style.display = 'none';

    camX = player.x - canvas.width / 2;
    camY = player.y - canvas.height / 2;

    difficultyMult = 1 + (currentRound * 0.15);

    // Mode-specific banners
    if (tagMode === 'banana') {
        showBanner('Banana Tag! Everyone is IT!', '#ffd700');
    } else if (tagMode === 'freeze') {
        showBanner('Freeze Tag! Blue vs Red!', '#4d96ff');
    } else if (tagMode === 'zombie') {
        showBanner(`Zombie Tag! ${aiChars[itIndex].name} is Patient Zero!`, '#22c55e');
    } else if (tagMode === 'ball') {
        showBanner(itIndex === -1 ? "Ball Tag! You have the ball!" : `Ball Tag! ${aiChars[itIndex].name} has the ball!`, '#ff6b6b');
    } else {
        showBanner(itIndex === -1 ? "You're IT!" : `${aiChars[itIndex].name} is IT!`, '#ff6b6b');
    }
}

function showBanner(text, color) {
    statusBanner.text = text;
    statusBanner.timer = 2;
    statusBanner.color = color || '#fff';
}

// --- Particle effects ---
function spawnTagParticles(x, y) {
    // Main burst ‚Äî more particles, varied sizes
    for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = randRange(60, 350);
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: randRange(0.3, 1.0),
            maxLife: randRange(0.3, 1.0),
            radius: randRange(2, 9),
            color: `hsl(${Math.random() * 60}, 100%, ${randRange(50, 75)}%)`,
        });
    }
    // Sparkle ring
    for (let i = 0; i < 12; i++) {
        const angle = i * Math.PI * 2 / 12;
        particles.push({
            x: x + Math.cos(angle) * 20, y: y + Math.sin(angle) * 20,
            vx: Math.cos(angle) * 180, vy: Math.sin(angle) * 180,
            life: 0.5, maxLife: 0.5, radius: 2,
            color: '#fff',
        });
    }
    // Shockwave
    spawnShockwave(x, y, '#ff6b6b');
    // Star emotion particles
    for (let i = 0; i < 5; i++) {
        spawnEmotionParticle(x, y - 10, 'star');
    }
    // Screen shake
    shakeTimer = 0.3;
    shakeIntensity = 6;
}

function spawnPortalParticles(x, y, color) {
    for (let i = 0; i < 15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = randRange(40, 150);
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: randRange(0.2, 0.5),
            maxLife: 0.5,
            radius: randRange(2, 5),
            color: color,
        });
    }
}

function spawnTrampolineParticles(x, y) {
    for (let i = 0; i < 10; i++) {
        const angle = randRange(-Math.PI, 0); // upward spray
        const speed = randRange(60, 180);
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: randRange(0.2, 0.5),
            maxLife: 0.5,
            radius: randRange(2, 4),
            color: `hsl(${180 + Math.random() * 40}, 100%, 65%)`,
        });
    }
}

function spawnBumperParticles(x, y) {
    for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = randRange(50, 120);
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: randRange(0.15, 0.35),
            maxLife: 0.35,
            radius: randRange(2, 4),
            color: '#f97316',
        });
    }
}

function spawnLavaBubble(pool) {
    const angle = Math.random() * Math.PI * 2;
    const r = Math.random() * pool.radius * 0.7;
    particles.push({
        x: pool.x + Math.cos(angle) * r,
        y: pool.y + Math.sin(angle) * r,
        vx: randRange(-10, 10),
        vy: randRange(-40, -80),
        life: randRange(0.3, 0.7),
        maxLife: 0.7,
        radius: randRange(2, 5),
        color: `hsl(${randRange(0, 30)}, 100%, ${randRange(45, 65)}%)`,
    });
}

function spawnDashTrail(x, y, color) {
    dashTrails.push({
        x, y,
        life: 0.3,
        maxLife: 0.3,
        radius: 12,
        color,
    });
}

function spawnConfetti() {
    for (let i = 0; i < 80; i++) {
        confetti.push({
            x: randRange(0, canvas.width),
            y: randRange(-canvas.height, 0),
            vx: randRange(-50, 50),
            vy: randRange(100, 300),
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: randRange(-5, 5),
            w: randRange(6, 12),
            h: randRange(4, 8),
            color: `hsl(${Math.random() * 360}, 80%, 60%)`,
            life: randRange(2, 4),
        });
    }
}

// --- Ambient particle management ---
function spawnAmbientParticle() {
    ambientParticles.push({
        x: Math.random() * ARENA_W,
        y: Math.random() * ARENA_H,
        vx: randRange(-8, 8),
        vy: randRange(-15, -5),
        size: randRange(1, 3),
        life: randRange(3, 8),
        maxLife: randRange(3, 8),
        hue: Math.random() < 0.3 ? randRange(90, 140) : randRange(30, 60), // warm or cool
        pulse: Math.random() * Math.PI * 2,
    });
}

function spawnShockwave(x, y, color) {
    shockwaves.push({
        x, y,
        radius: 10,
        maxRadius: 120,
        life: 0.5,
        maxLife: 0.5,
        color: color || '#ff6b6b',
        lineWidth: 4,
    });
}

function spawnFootstep(x, y, color, size) {
    footsteps.push({
        x, y,
        life: 0.6,
        maxLife: 0.6,
        radius: size || 3,
        color: color,
    });
}

function spawnEmotionParticle(x, y, type) {
    const p = { x, y, life: 0.8, maxLife: 0.8, type };
    if (type === 'sweat') {
        p.vx = randRange(-20, 20);
        p.vy = randRange(-60, -30);
        p.size = randRange(2, 4);
    } else if (type === 'steam') {
        p.vx = randRange(-15, 15);
        p.vy = randRange(-80, -40);
        p.size = randRange(4, 8);
        p.life = 0.6; p.maxLife = 0.6;
    } else if (type === 'star') {
        const angle = Math.random() * Math.PI * 2;
        p.vx = Math.cos(angle) * randRange(40, 80);
        p.vy = Math.sin(angle) * randRange(40, 80);
        p.size = randRange(3, 6);
        p.rotation = Math.random() * Math.PI;
    }
    emotionParticles.push(p);
}

function spawnSpeedLine(x, y, dirX, dirY) {
    speedLines.push({
        x: x + randRange(-15, 15),
        y: y + randRange(-15, 15),
        length: randRange(15, 35),
        angle: Math.atan2(-dirY, -dirX) + randRange(-0.3, 0.3),
        life: 0.2,
        maxLife: 0.2,
        width: randRange(1, 3),
    });
}

// --- Powerup functions ---
function spawnPowerup() {
    if (powerups.length >= MAX_POWERUPS) return;
    const type = POWERUP_KEYS[Math.floor(Math.random() * POWERUP_KEYS.length)];
    const info = POWERUP_TYPES[type];
    // Find a valid position
    let pos;
    for (let i = 0; i < 50; i++) {
        const x = randRange(100, ARENA_W - 100);
        const y = randRange(100, ARENA_H - 100);
        let ok = true;
        for (const w of WALLS) { if (rectContains(w, x, y, 25)) { ok = false; break; } }
        if (ok) for (const lp of LAVA_POOLS) { if (pointInCircle(x, y, lp.x, lp.y, lp.radius + 15)) { ok = false; break; } }
        if (ok) { pos = { x, y }; break; }
    }
    if (!pos) pos = { x: ARENA_W / 2 + randRange(-200, 200), y: ARENA_H / 2 + randRange(-200, 200) };
    powerups.push({
        x: pos.x, y: pos.y,
        type: type,
        name: info.name,
        color: info.color,
        icon: info.icon,
        radius: 16,
        spawnTime: gameTime,
        life: 20, // disappears after 20 seconds
    });
}

function collectPowerup(pu) {
    const type = pu.type;
    const info = POWERUP_TYPES[type];

    // Spawn flashy pickup particles
    for (let i = 0; i < 20; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = randRange(60, 200);
        particles.push({
            x: pu.x, y: pu.y,
            vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
            life: randRange(0.3, 0.7), maxLife: 0.7,
            radius: randRange(2, 5), color: info.color,
        });
    }
    spawnShockwave(pu.x, pu.y, info.color);

    if (info.stored) {
        // Store for later use
        storedPowerup = type;
        showBanner(`${info.icon} ${info.name} stored! Press E to use`, info.color);
        // Show touch button if on mobile
        if (isTouchDevice) usePowerupTouch.style.display = 'flex';
    } else {
        activatePowerup(type);
    }
}

function activatePowerup(type) {
    const info = POWERUP_TYPES[type];
    showBanner(`${info.icon} ${info.name}!`, info.color);
    shakeTimer = 0.15;
    shakeIntensity = 4;

    switch (type) {
        case 'invincible':
            playerInvincible = info.duration;
            break;
        case 'shield':
            playerInvincible = info.duration;
            storedPowerup = null;
            if (isTouchDevice) usePowerupTouch.style.display = 'none';
            break;
        case 'speed':
            playerSpeedSurge = info.duration;
            break;
        case 'freeze':
            freezeTimer = info.duration;
            break;
        case 'swap': {
            // Swap with a random non-hunter bot
            const candidates = aiChars.filter(a => !a.isHunter);
            if (candidates.length > 0) {
                const target = candidates[Math.floor(Math.random() * candidates.length)];
                const tmpX = player.x, tmpY = player.y;
                player.x = target.x; player.y = target.y;
                target.x = tmpX; target.y = tmpY;
                spawnShockwave(player.x, player.y, '#a855f7');
                spawnShockwave(target.x, target.y, '#a855f7');
            }
            break;
        }
        case 'shrink':
            playerShrink = info.duration;
            break;
    }
}

function updatePowerups(dt) {
    // Spawn timer
    powerupSpawnTimer -= dt;
    if (powerupSpawnTimer <= 0) {
        spawnPowerup();
        powerupSpawnTimer = POWERUP_SPAWN_INTERVAL + randRange(-2, 2);
    }

    // Update field powerups (lifetime)
    for (let i = powerups.length - 1; i >= 0; i--) {
        powerups[i].life -= dt;
        if (powerups[i].life <= 0) powerups.splice(i, 1);
    }

    // Check player collection
    for (let i = powerups.length - 1; i >= 0; i--) {
        const pu = powerups[i];
        if (dist(player, pu) < player.radius + pu.radius) {
            collectPowerup(pu);
            powerups.splice(i, 1);
        }
    }

    // Use stored powerup
    if ((useStoredPressed || touchUseStored) && storedPowerup) {
        activatePowerup(storedPowerup);
    }
    useStoredPressed = false;
    touchUseStored = false;

    // Tick active effect timers
    playerInvincible = Math.max(0, playerInvincible - dt);
    playerSpeedSurge = Math.max(0, playerSpeedSurge - dt);
    playerShrink = Math.max(0, playerShrink - dt);
    freezeTimer = Math.max(0, freezeTimer - dt);

    // Apply shrink to player radius
    player.radius = playerShrink > 0 ? 10 : PLAYER_RADIUS;
}

function drawPowerups() {
    for (const pu of powerups) {
        const t = gameTime - pu.spawnTime;
        const bobY = Math.sin(t * 3) * 4;
        const px = pu.x, py = pu.y + bobY;

        // Blinking when about to expire
        if (pu.life < 4 && Math.sin(pu.life * 10) < 0) continue;

        // Ground shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(pu.x, pu.y + pu.radius + 3, pu.radius * 0.7, 3, 0, 0, Math.PI * 2);
        ctx.fill();

        // Ambient glow
        ctx.globalAlpha = 0.25 + Math.sin(t * 4) * 0.1;
        const glow = ctx.createRadialGradient(px, py, 0, px, py, pu.radius * 3);
        glow.addColorStop(0, pu.color + '60');
        glow.addColorStop(1, pu.color + '00');
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(px, py, pu.radius * 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        // Rotating ring
        ctx.save();
        ctx.translate(px, py);
        ctx.rotate(t * 2);
        ctx.strokeStyle = pu.color;
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.5;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(0, 0, pu.radius + 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
        ctx.restore();

        // Body circle
        const bodyGrad = ctx.createRadialGradient(px - 3, py - 3, 0, px, py, pu.radius);
        bodyGrad.addColorStop(0, '#fff');
        bodyGrad.addColorStop(0.3, pu.color);
        bodyGrad.addColorStop(1, pu.color);
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.arc(px, py, pu.radius, 0, Math.PI * 2);
        ctx.fill();

        // Border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(px, py, pu.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Icon
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(pu.icon, px, py);

        // Orbiting sparkles
        for (let i = 0; i < 3; i++) {
            const a = t * 3 + i * Math.PI * 2 / 3;
            const ox = px + Math.cos(a) * (pu.radius + 8);
            const oy = py + Math.sin(a) * (pu.radius + 8);
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(ox, oy, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }
}

// --- Arena element interactions for any character ---
function handleElementInteractions(char, dt) {
    char.portalCooldown = Math.max(0, char.portalCooldown - dt);
    char.speedBoostTimer = Math.max(0, char.speedBoostTimer - dt);
    char.lavaFlashTimer = Math.max(0, char.lavaFlashTimer - dt);
    char.trampolineLaunchTimer = Math.max(0, char.trampolineLaunchTimer - dt);
    char.onIce = false;
    char.onLava = false;

    // --- Portals ---
    if (char.portalCooldown <= 0) {
        for (const p of PORTALS) {
            const dA = distXY(char.x, char.y, p.ax, p.ay);
            const dB = distXY(char.x, char.y, p.bx, p.by);
            if (dA < p.radius) {
                char.x = p.bx;
                char.y = p.by;
                char.portalCooldown = 1.5;
                spawnPortalParticles(p.ax, p.ay, p.color1);
                spawnPortalParticles(p.bx, p.by, p.color2);
                break;
            } else if (dB < p.radius) {
                char.x = p.ax;
                char.y = p.ay;
                char.portalCooldown = 1.5;
                spawnPortalParticles(p.bx, p.by, p.color2);
                spawnPortalParticles(p.ax, p.ay, p.color1);
                break;
            }
        }
    }

    // --- Trampolines ---
    if (char.trampolineLaunchTimer <= 0) {
        for (const t of TRAMPOLINES) {
            if (pointInRect(char.x, char.y, t)) {
                // Launch in the direction the character is moving, or upward if standing still
                let lx = char.faceDirX;
                let ly = char.faceDirY;
                const len = Math.sqrt(lx * lx + ly * ly);
                if (len < 0.1) { lx = 0; ly = -1; }
                else { lx /= len; ly /= len; }
                char.trampolineLaunchTimer = TRAMPOLINE_DURATION;
                char.trampolineDirX = lx;
                char.trampolineDirY = ly;
                spawnTrampolineParticles(t.x + t.w / 2, t.y + t.h / 2);
                trampolineAnims.push({ x: t.x, y: t.y, w: t.w, h: t.h, timer: 0.3 });
                break;
            }
        }
    }

    // --- Lava pools ---
    for (const lp of LAVA_POOLS) {
        if (pointInCircle(char.x, char.y, lp.x, lp.y, lp.radius)) {
            char.onLava = true;
            char.lavaFlashTimer = 0.15;
            break;
        }
    }

    // --- Speed pads ---
    for (const sp of SPEED_PADS) {
        // Check center of pad
        const cx = sp.x + sp.w / 2;
        const cy = sp.y + sp.h / 2;
        if (distXY(char.x, char.y, cx, cy) < 35) {
            if (char.speedBoostTimer <= 0) {
                spawnPortalParticles(cx, cy, '#facc15');
            }
            char.speedBoostTimer = SPEED_BOOST_DURATION;
            break;
        }
    }

    // --- Ice patches ---
    for (const ip of ICE_PATCHES) {
        if (pointInCircle(char.x, char.y, ip.x, ip.y, ip.radius)) {
            char.onIce = true;
            break;
        }
    }

    // --- Bumpers ---
    for (const b of BUMPERS) {
        const d = distXY(char.x, char.y, b.x, b.y);
        if (d < b.radius + char.radius) {
            // Push away from bumper
            const dx = char.x - b.x;
            const dy = char.y - b.y;
            const nd = Math.sqrt(dx * dx + dy * dy) || 1;
            char.vx = (dx / nd) * BUMPER_FORCE;
            char.vy = (dy / nd) * BUMPER_FORCE;
            // Push out of bumper
            char.x = b.x + (dx / nd) * (b.radius + char.radius + 1);
            char.y = b.y + (dy / nd) * (b.radius + char.radius + 1);
            spawnBumperParticles(b.x, b.y);
            break;
        }
    }
}

// --- Player update ---
function updatePlayer(dt) {
    // Frozen players can't move (banana/freeze tag)
    if (playerFrozen) {
        player.vx = 0;
        player.vy = 0;
        return;
    }

    let ix = 0, iy = 0;

    if (keys['w'] || keys['arrowup']) iy -= 1;
    if (keys['s'] || keys['arrowdown']) iy += 1;
    if (keys['a'] || keys['arrowleft']) ix -= 1;
    if (keys['d'] || keys['arrowright']) ix += 1;

    if (joystick.active) {
        const jDist = Math.sqrt(joystick.dx * joystick.dx + joystick.dy * joystick.dy);
        if (jDist > 10) {
            ix = joystick.dx / jDist;
            iy = joystick.dy / jDist;
        }
    }

    const inputLen = Math.sqrt(ix * ix + iy * iy);
    if (inputLen > 0) {
        ix /= inputLen;
        iy /= inputLen;
        player.faceDirX = ix;
        player.faceDirY = iy;
    }

    // Dash
    if ((dashPressed || touchDash) && player.dashCooldown <= 0 && !player.isDashing && inputLen > 0) {
        player.isDashing = true;
        player.dashTimer = DASH_DURATION;
        player.dashCooldown = DASH_COOLDOWN;
        player.dashDirX = ix;
        player.dashDirY = iy;
    }
    dashPressed = false;
    touchDash = false;

    // Calculate effective speed
    let effectiveSpeed = PLAYER_SPEED;
    if (playerIsZombie) effectiveSpeed *= 0.85; // Zombies are slower
    if (player.speedBoostTimer > 0) effectiveSpeed *= SPEED_BOOST_MULT;
    if (playerSpeedSurge > 0) effectiveSpeed *= 3;
    if (player.onLava) effectiveSpeed *= LAVA_SLOW_FACTOR;

    // Trampoline launch override
    if (player.trampolineLaunchTimer > 0) {
        player.vx = player.trampolineDirX * TRAMPOLINE_LAUNCH_SPEED;
        player.vy = player.trampolineDirY * TRAMPOLINE_LAUNCH_SPEED;
    } else if (player.isDashing) {
        player.dashTimer -= dt;
        if (player.dashTimer <= 0) player.isDashing = false;
        let dashSpd = DASH_SPEED;
        if (player.onLava) dashSpd *= LAVA_SLOW_FACTOR;
        player.vx = player.dashDirX * dashSpd;
        player.vy = player.dashDirY * dashSpd;
        spawnDashTrail(player.x, player.y, player.color);
    } else if (player.onIce) {
        // On ice: apply input as acceleration, velocity decays slowly
        player.vx += ix * effectiveSpeed * dt * 5;
        player.vy += iy * effectiveSpeed * dt * 5;
        // Clamp max speed on ice
        const iceMaxSpeed = effectiveSpeed * 1.3;
        const iceSpeed = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
        if (iceSpeed > iceMaxSpeed) {
            player.vx = (player.vx / iceSpeed) * iceMaxSpeed;
            player.vy = (player.vy / iceSpeed) * iceMaxSpeed;
        }
        player.vx *= ICE_FRICTION;
        player.vy *= ICE_FRICTION;
    } else {
        player.vx = ix * effectiveSpeed;
        player.vy = iy * effectiveSpeed;
    }

    player.dashCooldown = Math.max(0, player.dashCooldown - dt);

    // Move
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // Wall collision
    const resolved = resolveWallCollision(player.x, player.y, player.radius);
    player.x = resolved.x;
    player.y = resolved.y;

    player.x = clamp(player.x, player.radius, ARENA_W - player.radius);
    player.y = clamp(player.y, player.radius, ARENA_H - player.radius);

    // Element interactions
    handleElementInteractions(player, dt);

    // LAVA PENALTY: only in classic/ball modes
    if ((tagMode === 'classic' || tagMode === 'ball') && player.onLava && itIndex !== -1 && immunityTimer <= 0 && playerInvincible <= 0) {
        const oldItChar = aiChars[itIndex];
        oldItChar.expression = 'happy';
        itIndex = -1;
        player.expression = 'it';
        immunityTimer = TAG_IMMUNITY_TIME;
        spawnTagParticles(player.x, player.y);
        showBanner("Lava! You're IT!", '#ff4500');
    }

    // IDLE PENALTY: only in classic/ball modes (disabled in tutorial)
    if ((tagMode === 'classic' || tagMode === 'ball') && gameState !== 'tutorial') {
        if (inputLen > 0.1) {
            idleTimer = 0;
        } else {
            idleTimer += dt;
            if (idleTimer >= IDLE_TIMEOUT && itIndex !== -1 && immunityTimer <= 0 && playerInvincible <= 0) {
                const oldItChar = aiChars[itIndex];
                oldItChar.expression = 'happy';
                itIndex = -1;
                player.expression = 'it';
                immunityTimer = TAG_IMMUNITY_TIME;
                idleTimer = 0;
                spawnTagParticles(player.x, player.y);
                showBanner("Too slow! You're IT!", '#ff8c00');
            }
        }
    }

    // Survival time (mode-specific)
    if (tagMode === 'banana') {
        // Score = time unfrozen
        if (!playerFrozen) {
            player.survivalTime += dt;
        }
    } else if (tagMode === 'freeze') {
        // Blue: score = time unfrozen. Red: always scores (tagger role)
        if (player.team === 'red' || !playerFrozen) {
            player.survivalTime += dt;
        }
    } else if (tagMode === 'zombie') {
        // Score = time before becoming zombie
        if (!playerIsZombie) {
            player.survivalTime += dt;
        }
    } else {
        // Classic / Ball: time not IT
        if (itIndex !== -1) {
            player.survivalTime += dt;
        }
    }
}

// ============================================================
// AI HELPERS ‚Äî arena awareness
// ============================================================

// Find nearest portal exit that moves char away from a threat
function findEscapePortal(ax, ay, threatX, threatY) {
    let best = null, bestScore = -Infinity;
    for (const p of PORTALS) {
        // Check side A entrance -> B exit
        const dToA = distXY(ax, ay, p.ax, p.ay);
        if (dToA < 250) {
            const exitDist = distXY(p.bx, p.by, threatX, threatY);
            const score = exitDist - dToA * 0.5; // prefer close entrance + far exit
            if (score > bestScore) { bestScore = score; best = { x: p.ax, y: p.ay, exitDist }; }
        }
        // Check side B entrance -> A exit
        const dToB = distXY(ax, ay, p.bx, p.by);
        if (dToB < 250) {
            const exitDist = distXY(p.ax, p.ay, threatX, threatY);
            const score = exitDist - dToB * 0.5;
            if (score > bestScore) { bestScore = score; best = { x: p.bx, y: p.by, exitDist }; }
        }
    }
    return best;
}

// Find nearest portal that brings chaser closer to target
function findChasePortal(ax, ay, targetX, targetY) {
    let best = null, bestScore = Infinity;
    for (const p of PORTALS) {
        const dToA = distXY(ax, ay, p.ax, p.ay);
        const exitDistB = distXY(p.bx, p.by, targetX, targetY);
        if (dToA < 200 && exitDistB < bestScore) {
            bestScore = exitDistB; best = { x: p.ax, y: p.ay, exitDist: exitDistB };
        }
        const dToB = distXY(ax, ay, p.bx, p.by);
        const exitDistA = distXY(p.ax, p.ay, targetX, targetY);
        if (dToB < 200 && exitDistA < bestScore) {
            bestScore = exitDistA; best = { x: p.bx, y: p.by, exitDist: exitDistA };
        }
    }
    return best;
}

// Find nearest speed pad
function findNearestSpeedPad(ax, ay) {
    let best = null, bestDist = Infinity;
    for (const sp of SPEED_PADS) {
        const cx = sp.x + sp.w / 2, cy = sp.y + sp.h / 2;
        const d = distXY(ax, ay, cx, cy);
        if (d < bestDist) { bestDist = d; best = { x: cx, y: cy, dist: d }; }
    }
    return best;
}

// Find nearest trampoline
function findNearestTrampoline(ax, ay) {
    let best = null, bestDist = Infinity;
    for (const t of TRAMPOLINES) {
        const cx = t.x + t.w / 2, cy = t.y + t.h / 2;
        const d = distXY(ax, ay, cx, cy);
        if (d < bestDist) { bestDist = d; best = { x: cx, y: cy, dist: d }; }
    }
    return best;
}

// Check if a position is near a wall/corner (bad for fleeing)
function isNearWallOrCorner(x, y, margin) {
    if (x < margin || x > ARENA_W - margin || y < margin || y > ARENA_H - margin) return true;
    for (const w of WALLS) {
        if (x > w.x - margin && x < w.x + w.w + margin &&
            y > w.y - margin && y < w.y + w.h + margin) return true;
    }
    return false;
}

// Check if position is inside lava
function isInLava(x, y) {
    for (const lp of LAVA_POOLS) {
        if (distXY(x, y, lp.x, lp.y) < lp.radius + 15) return true;
    }
    return false;
}

// Score a flee direction ‚Äî higher = better escape route
function scoreFleeDirection(ax, ay, angle, threatX, threatY) {
    const testDist = 150;
    const tx = ax + Math.cos(angle) * testDist;
    const ty = ay + Math.sin(angle) * testDist;
    let score = 0;

    // Distance from threat at destination
    score += distXY(tx, ty, threatX, threatY) * 0.5;

    // Penalty for going out of bounds
    if (tx < 60 || tx > ARENA_W - 60) score -= 200;
    if (ty < 60 || ty > ARENA_H - 60) score -= 200;

    // Penalty for lava
    if (isInLava(tx, ty)) score -= 150;

    // Penalty for corners
    if (isNearWallOrCorner(tx, ty, 80)) score -= 80;

    // Bonus for open space (away from walls)
    const centerDist = distXY(tx, ty, ARENA_W / 2, ARENA_H / 2);
    score -= centerDist * 0.05;

    return score;
}

// Pick the best flee direction from multiple candidates
function bestFleeAngle(ax, ay, threatX, threatY) {
    const baseAngle = Math.atan2(ay - threatY, ax - threatX);
    let bestAngle = baseAngle, bestScore = -Infinity;

    // Test 8 directions centered around "directly away"
    for (let i = -3; i <= 4; i++) {
        const testAngle = baseAngle + i * Math.PI / 6;
        const score = scoreFleeDirection(ax, ay, testAngle, threatX, threatY);
        if (score > bestScore) {
            bestScore = score;
            bestAngle = testAngle;
        }
    }
    return bestAngle;
}

// Find weakest target (cornered, on lava, near wall)
function findWeakestTarget(itChar, itIdx) {
    let bestTarget = null, bestScore = -Infinity;
    const allTargets = [];

    // Add player
    allTargets.push({ char: player, idx: -1 });
    for (let i = 0; i < aiChars.length; i++) {
        if (i === itIdx) continue;
        allTargets.push({ char: aiChars[i], idx: i });
    }

    for (const t of allTargets) {
        const c = t.char;
        const d = dist(itChar, c);
        let score = -d; // closer = better base score

        // Bonuses for vulnerable targets
        if (c.onLava) score += 200;
        if (isNearWallOrCorner(c.x, c.y, 80)) score += 120;
        if (c.onIce) score += 60;

        // Penalty for boosted targets
        if (c.speedBoostTimer > 0) score -= 150;
        if (c.isDashing) score -= 100;

        // Proximity bonus (heavily weight close targets)
        if (d < 150) score += 300;
        else if (d < 300) score += 100;

        if (score > bestScore) {
            bestScore = score;
            bestTarget = c;
        }
    }
    return bestTarget || player;
}

// ============================================================
// AI UPDATE ‚Äî smarter behaviors
// ============================================================

function updateAI(ai, index, dt) {
    // Frozen bots don't move (banana/freeze tag)
    if (frozenPlayers.has(index)) {
        ai.vx = 0;
        ai.vy = 0;
        return;
    }

    const isIT = itIndex === index;
    let speed = ai.baseSpeed * difficultyMult;
    if (ai.speedBoostTimer > 0) speed *= SPEED_BOOST_MULT;
    if (ai.onLava) speed *= LAVA_SLOW_FACTOR;
    // Zombies are slower
    if (tagMode === 'zombie' && zombies.has(index)) speed *= 0.85;
    ai.speed = speed;

    ai.retargetTimer -= dt;
    ai.dashCooldown = Math.max(0, ai.dashCooldown - dt);

    // Trampoline launch override
    if (ai.trampolineLaunchTimer > 0) {
        ai.vx = ai.trampolineDirX * TRAMPOLINE_LAUNCH_SPEED;
        ai.vy = ai.trampolineDirY * TRAMPOLINE_LAUNCH_SPEED;
    } else if (ai.isDashing) {
        ai.dashTimer -= dt;
        if (ai.dashTimer <= 0) ai.isDashing = false;
        let dashSpd = DASH_SPEED * 0.9;
        if (ai.onLava) dashSpd *= LAVA_SLOW_FACTOR;
        ai.vx = ai.dashDirX * dashSpd;
        ai.vy = ai.dashDirY * dashSpd;
        spawnDashTrail(ai.x, ai.y, ai.color);
    } else {
        let tx, ty;

        // Hunter-specific behavior
        if (ai.isHunter) {
            if (hunterStunTimer > 0) {
                // Stunned: wander to random position
                if (ai.retargetTimer <= 0) {
                    ai.targetX = randRange(80, ARENA_W - 80);
                    ai.targetY = randRange(80, ARENA_H - 80);
                    ai.retargetTimer = randRange(1, 2);
                }
                tx = ai.targetX;
                ty = ai.targetY;
                ai.expression = 'scared';
            } else {
                // Normal: chase the player
                tx = player.x + player.vx * 0.3;
                ty = player.y + player.vy * 0.3;
                ai.expression = 'it';

                // Dash at player when close
                const d = dist(ai, player);
                if (d < 140 && d > 30 && ai.dashCooldown <= 0 && Math.random() < 0.04 * difficultyMult) {
                    const angle = Math.atan2(player.y - ai.y, player.x - ai.x);
                    ai.isDashing = true;
                    ai.dashTimer = DASH_DURATION;
                    ai.dashCooldown = DASH_COOLDOWN + randRange(0, 1.5);
                    ai.dashDirX = Math.cos(angle);
                    ai.dashDirY = Math.sin(angle);
                }
            }
        } else
        // Mode-specific AI behavior override
        if (tagMode === 'banana' && !ai.isHunter) {
            // Banana: everyone is IT ‚Äî chase nearest unfrozen target, dodge nearby threats
            let closest = null, closestDist = Infinity;
            // Find nearest unfrozen target to chase
            if (!playerFrozen) {
                const d = dist(ai, player);
                if (d < closestDist) { closestDist = d; closest = player; }
            }
            for (let i = 0; i < aiChars.length; i++) {
                if (i === index || aiChars[i].isHunter || frozenPlayers.has(i)) continue;
                const d = dist(ai, aiChars[i]);
                if (d < closestDist) { closestDist = d; closest = aiChars[i]; }
            }
            // Find nearest unfrozen threat chasing us
            let nearestThreat = null, threatDist = Infinity;
            if (!playerFrozen) {
                const d = dist(ai, player);
                if (d < threatDist && d < 150) { threatDist = d; nearestThreat = player; }
            }
            for (let i = 0; i < aiChars.length; i++) {
                if (i === index || aiChars[i].isHunter || frozenPlayers.has(i)) continue;
                const d = dist(ai, aiChars[i]);
                if (d < threatDist && d < 150) { threatDist = d; nearestThreat = aiChars[i]; }
            }
            if (nearestThreat && threatDist < 80) {
                // Dodge: flee from closest threat while angling toward target
                const fleeAngle = Math.atan2(ai.y - nearestThreat.y, ai.x - nearestThreat.x);
                tx = ai.x + Math.cos(fleeAngle) * 200;
                ty = ai.y + Math.sin(fleeAngle) * 200;
                ai.expression = 'scared';
            } else if (closest) {
                tx = closest.x + closest.vx * 0.25;
                ty = closest.y + closest.vy * 0.25;
                ai.expression = closestDist < 100 ? 'it' : 'normal';
            } else {
                // Everyone else is frozen, roam
                if (ai.retargetTimer <= 0) {
                    ai.targetX = randRange(80, ARENA_W - 80);
                    ai.targetY = randRange(80, ARENA_H - 80);
                    ai.retargetTimer = randRange(1, 3);
                }
                tx = ai.targetX; ty = ai.targetY;
                ai.expression = 'happy';
            }
        } else if (tagMode === 'freeze' && !ai.isHunter) {
            if (teams.red.includes(index)) {
                // Red team: chase unfrozen blue targets, spread out across different targets
                // Build list of unfrozen blue targets
                const blueTargets = [];
                if (player.team === 'blue' && !playerFrozen) blueTargets.push({ char: player, id: -1 });
                for (const bIdx of teams.blue) {
                    if (!frozenPlayers.has(bIdx)) blueTargets.push({ char: aiChars[bIdx], id: bIdx });
                }
                if (blueTargets.length > 0) {
                    // Count how many other reds are already chasing each target
                    const chaseCounts = new Map();
                    for (const t of blueTargets) chaseCounts.set(t.id, 0);
                    for (const rIdx of teams.red) {
                        if (rIdx === index) continue;
                        const otherAI = aiChars[rIdx];
                        if (otherAI._freezeChaseTarget !== undefined && chaseCounts.has(otherAI._freezeChaseTarget)) {
                            chaseCounts.set(otherAI._freezeChaseTarget, chaseCounts.get(otherAI._freezeChaseTarget) + 1);
                        }
                    }
                    // Pick closest target, but penalize already-chased targets so reds spread out
                    let best = null, bestScore = Infinity;
                    for (const t of blueTargets) {
                        const d = dist(ai, t.char);
                        const chasePenalty = chaseCounts.get(t.id) * 300; // 300px penalty per extra chaser
                        const score = d + chasePenalty;
                        if (score < bestScore) { bestScore = score; best = t; }
                    }
                    ai._freezeChaseTarget = best.id;
                    tx = best.char.x + best.char.vx * 0.3;
                    ty = best.char.y + best.char.vy * 0.3;
                } else {
                    // All blues frozen, wander
                    if (ai.retargetTimer <= 0) {
                        ai.targetX = randRange(80, ARENA_W - 80);
                        ai.targetY = randRange(80, ARENA_H - 80);
                        ai.retargetTimer = randRange(1, 3);
                    }
                    tx = ai.targetX; ty = ai.targetY;
                    ai._freezeChaseTarget = undefined;
                }
                ai.expression = 'it';
            } else {
                // Blue team: flee from nearest red (bots + player if on red), unfreeze frozen blues
                let nearestRed = null, nearRedDist = Infinity;
                for (const rIdx of teams.red) {
                    const d = dist(ai, aiChars[rIdx]);
                    if (d < nearRedDist) { nearRedDist = d; nearestRed = aiChars[rIdx]; }
                }
                // Also flee from player if player is on red team
                if (player.team === 'red') {
                    const d = dist(ai, player);
                    if (d < nearRedDist) { nearRedDist = d; nearestRed = player; }
                }
                if (nearestRed && nearRedDist < 200) {
                    const fleeAngle = Math.atan2(ai.y - nearestRed.y, ai.x - nearestRed.x);
                    tx = ai.x + Math.cos(fleeAngle) * 250;
                    ty = ai.y + Math.sin(fleeAngle) * 250;
                    ai.expression = 'scared';
                } else {
                    // Look for frozen blue teammates
                    let nearestFrozen = null, nearDist = Infinity;
                    if (player.team === 'blue' && playerFrozen) {
                        const d = dist(ai, player);
                        if (d < nearDist) { nearDist = d; nearestFrozen = player; }
                    }
                    for (const bIdx of teams.blue) {
                        if (!frozenPlayers.has(bIdx)) continue;
                        const d = dist(ai, aiChars[bIdx]);
                        if (d < nearDist) { nearDist = d; nearestFrozen = aiChars[bIdx]; }
                    }
                    if (nearestFrozen && nearDist < 400) {
                        tx = nearestFrozen.x;
                        ty = nearestFrozen.y;
                        ai.expression = 'happy';
                    } else {
                        if (ai.retargetTimer <= 0) {
                            ai.targetX = randRange(80, ARENA_W - 80);
                            ai.targetY = randRange(80, ARENA_H - 80);
                            ai.retargetTimer = randRange(1, 3);
                        }
                        tx = ai.targetX; ty = ai.targetY;
                        ai.expression = 'normal';
                    }
                }
            }
        } else if (tagMode === 'zombie' && !ai.isHunter) {
            if (zombies.has(index)) {
                // Zombie: chase non-zombies, spread across different targets
                const targets = [];
                if (!playerIsZombie) targets.push({ char: player, id: -1 });
                for (let i = 0; i < aiChars.length; i++) {
                    if (zombies.has(i) || aiChars[i].isHunter) continue;
                    targets.push({ char: aiChars[i], id: i });
                }
                if (targets.length > 0) {
                    // Count how many other zombies chase each target
                    const chaseCounts = new Map();
                    for (const t of targets) chaseCounts.set(t.id, 0);
                    for (const zIdx of zombies) {
                        if (zIdx === index) continue;
                        const otherAI = aiChars[zIdx];
                        if (otherAI._zombieChaseTarget !== undefined && chaseCounts.has(otherAI._zombieChaseTarget)) {
                            chaseCounts.set(otherAI._zombieChaseTarget, chaseCounts.get(otherAI._zombieChaseTarget) + 1);
                        }
                    }
                    // Pick target with lowest score (distance + chase penalty)
                    let best = null, bestScore = Infinity;
                    for (const t of targets) {
                        const d = dist(ai, t.char);
                        const chasePenalty = chaseCounts.get(t.id) * 250;
                        const score = d + chasePenalty;
                        if (score < bestScore) { bestScore = score; best = t; }
                    }
                    ai._zombieChaseTarget = best.id;
                    tx = best.char.x + best.char.vx * 0.2;
                    ty = best.char.y + best.char.vy * 0.2;
                } else {
                    ai._zombieChaseTarget = undefined;
                }
                ai.expression = 'it';
            } else {
                // Non-zombie: flee from nearest zombie
                let nearestZ = null, nearDist = Infinity;
                for (const zIdx of zombies) {
                    const d = dist(ai, aiChars[zIdx]);
                    if (d < nearDist) { nearDist = d; nearestZ = aiChars[zIdx]; }
                }
                if (playerIsZombie) {
                    const d = dist(ai, player);
                    if (d < nearDist) { nearDist = d; nearestZ = player; }
                }
                if (nearestZ && nearDist < 250) {
                    const fleeAngle = Math.atan2(ai.y - nearestZ.y, ai.x - nearestZ.x);
                    tx = ai.x + Math.cos(fleeAngle) * 250;
                    ty = ai.y + Math.sin(fleeAngle) * 250;
                    ai.expression = 'scared';
                } else {
                    if (ai.retargetTimer <= 0) {
                        ai.targetX = randRange(80, ARENA_W - 80);
                        ai.targetY = randRange(80, ARENA_H - 80);
                        ai.retargetTimer = randRange(1, 3);
                    }
                    tx = ai.targetX; ty = ai.targetY;
                    ai.expression = 'normal';
                }
            }
        } else if (tagMode === 'ball' && isIT && !ai.isHunter) {
            // Ball Tag IT AI: chase target and throw ball periodically
            let target = findClosestTarget(ai, index);
            const d = dist(ai, target);
            tx = target.x + target.vx * 0.3;
            ty = target.y + target.vy * 0.3;
            ai.expression = 'it';

            // Throw ball when in range
            if (balls.length < (settings.ballCount || 1) && ballCooldown <= 0 && d < 350 && d > 40) {
                if (Math.random() < 0.03 * difficultyMult) {
                    throwBall(ai, target.x + target.vx * 0.5, target.y + target.vy * 0.5, index);
                }
            }
        } else if (isIT) {
            // =============================================
            // IT BEHAVIOR ‚Äî smart chasing
            // =============================================
            ai.expression = 'it';

            // Pick target: closest for simple personalities, weakest for smart ones
            let target;
            if (ai.personality === 'smart' || ai.personality === 'flanker' || ai.personality === 'coward') {
                target = findWeakestTarget(ai, index);
            } else {
                target = findClosestTarget(ai, index);
            }

            const d = dist(ai, target);

            // All IT bots predict target movement (scaled by personality)
            const predictionStrength = (ai.personality === 'smart') ? 0.6 :
                (ai.personality === 'flanker') ? 0.5 :
                (ai.personality === 'speedy') ? 0.35 : 0.2;
            tx = target.x + target.vx * predictionStrength;
            ty = target.y + target.vy * predictionStrength;

            // Flanker: intercept from the side
            if (ai.personality === 'flanker' && d > 80) {
                const targetAngle = Math.atan2(target.vy, target.vx);
                const perpAngle = targetAngle + (Math.random() < 0.5 ? Math.PI / 2 : -Math.PI / 2);
                tx = target.x + Math.cos(perpAngle) * 60 + target.vx * 0.4;
                ty = target.y + Math.sin(perpAngle) * 60 + target.vy * 0.4;
            }

            // Check if a portal shortcut is closer
            if (d > 200) {
                const portalShortcut = findChasePortal(ai.x, ai.y, target.x, target.y);
                if (portalShortcut && portalShortcut.exitDist < d * 0.6 && ai.portalCooldown <= 0) {
                    tx = portalShortcut.x;
                    ty = portalShortcut.y;
                }
            }

            // Seek speed pads when far from target
            if (d > 350 && ai.speedBoostTimer <= 0) {
                const pad = findNearestSpeedPad(ai.x, ai.y);
                if (pad && pad.dist < 120) {
                    tx = pad.x;
                    ty = pad.y;
                }
            }

            // Smart dash: dash when in range and closing
            const dashChance = (ai.personality === 'smart') ? 0.06 :
                (ai.personality === 'speedy') ? 0.05 :
                (ai.personality === 'flanker') ? 0.04 : 0.025;
            if (d < 140 && d > 30 && ai.dashCooldown <= 0 && Math.random() < dashChance * difficultyMult) {
                const angle = Math.atan2(target.y - ai.y, target.x - ai.x);
                ai.isDashing = true;
                ai.dashTimer = DASH_DURATION;
                ai.dashCooldown = DASH_COOLDOWN + randRange(0, 1.5);
                ai.dashDirX = Math.cos(angle);
                ai.dashDirY = Math.sin(angle);
            }

            // Corner-cut: if target is near a wall, predict they'll run along it
            if (isNearWallOrCorner(target.x, target.y, 60) && d < 250) {
                // Aim slightly ahead of where they're going
                tx = target.x + target.vx * 0.8;
                ty = target.y + target.vy * 0.8;
            }

        } else {
            // =============================================
            // NON-IT BEHAVIOR ‚Äî smart fleeing
            // =============================================
            const itChar = getITChar();
            const distToIT = dist(ai, itChar);
            const dangerZone = 220 + difficultyMult * 30;

            if (distToIT < dangerZone * 0.6) {
                ai.expression = 'scared';
            } else if (distToIT < dangerZone) {
                ai.expression = 'normal';
            } else {
                ai.expression = 'happy';
            }

            // Shared smart fleeing logic
            const inDanger = distToIT < dangerZone;
            const inCriticalDanger = distToIT < dangerZone * 0.5;

            if (inDanger) {
                // --- Smart flee: pick best direction ---
                const fleeAngle = bestFleeAngle(ai.x, ai.y, itChar.x, itChar.y);
                tx = ai.x + Math.cos(fleeAngle) * 250;
                ty = ai.y + Math.sin(fleeAngle) * 250;

                // Personality-specific flee modifications
                switch (ai.personality) {
                    case 'flanker':
                        // Juke: alternate perpendicular direction
                        {
                            const juke = Math.sin(gameTime * 3 + index) > 0 ? Math.PI / 3 : -Math.PI / 3;
                            const jukeAngle = fleeAngle + juke;
                            tx = ai.x + Math.cos(jukeAngle) * 200;
                            ty = ai.y + Math.sin(jukeAngle) * 200;
                        }
                        break;

                    case 'smart':
                        // Seek portal escape if available and in danger
                        if (inCriticalDanger && ai.portalCooldown <= 0) {
                            const portal = findEscapePortal(ai.x, ai.y, itChar.x, itChar.y);
                            if (portal && portal.exitDist > distToIT * 1.5) {
                                tx = portal.x;
                                ty = portal.y;
                            }
                        }
                        // Also seek speed pads
                        if (ai.speedBoostTimer <= 0) {
                            const pad = findNearestSpeedPad(ai.x, ai.y);
                            if (pad && pad.dist < 100) {
                                tx = pad.x;
                                ty = pad.y;
                            }
                        }
                        break;

                    case 'coward':
                        // Maximum flee: always pick the direction furthest from IT
                        // and also seek portals aggressively
                        if (ai.portalCooldown <= 0) {
                            const portal = findEscapePortal(ai.x, ai.y, itChar.x, itChar.y);
                            if (portal) {
                                tx = portal.x;
                                ty = portal.y;
                            }
                        }
                        break;

                    case 'speedy':
                        // Use trampolines to launch away
                        {
                            const tramp = findNearestTrampoline(ai.x, ai.y);
                            if (tramp && tramp.dist < 120 && ai.trampolineLaunchTimer <= 0) {
                                tx = tramp.x;
                                ty = tramp.y;
                            }
                        }
                        break;
                }

                // --- Universal critical danger dash ---
                if (inCriticalDanger && ai.dashCooldown <= 0) {
                    const dashChance = (ai.personality === 'smart' || ai.personality === 'coward') ? 0.08 :
                        (ai.personality === 'speedy') ? 0.07 : 0.04;
                    if (Math.random() < dashChance * difficultyMult) {
                        ai.isDashing = true;
                        ai.dashTimer = DASH_DURATION;
                        ai.dashCooldown = DASH_COOLDOWN + randRange(0, 1);
                        ai.dashDirX = Math.cos(fleeAngle);
                        ai.dashDirY = Math.sin(fleeAngle);
                    }
                }

            } else {
                // --- Safe: roam strategically ---
                switch (ai.personality) {
                    case 'patrol':
                        ai.patrolAngle += dt * 0.8;
                        tx = ARENA_W / 2 + Math.cos(ai.patrolAngle) * 350;
                        ty = ARENA_H / 2 + Math.sin(ai.patrolAngle) * 250;
                        break;

                    case 'smart':
                        // When safe, position near portals/speed pads for quick escape
                        if (ai.retargetTimer <= 0) {
                            // Pick a strategic position near a portal or speed pad
                            if (Math.random() < 0.4) {
                                const portal = PORTALS[Math.floor(Math.random() * PORTALS.length)];
                                const side = Math.random() < 0.5;
                                ai.targetX = side ? portal.ax + randRange(-40, 40) : portal.bx + randRange(-40, 40);
                                ai.targetY = side ? portal.ay + randRange(-40, 40) : portal.by + randRange(-40, 40);
                            } else {
                                ai.targetX = randRange(100, ARENA_W - 100);
                                ai.targetY = randRange(100, ARENA_H - 100);
                            }
                            // Avoid lava
                            while (isInLava(ai.targetX, ai.targetY)) {
                                ai.targetX = randRange(100, ARENA_W - 100);
                                ai.targetY = randRange(100, ARENA_H - 100);
                            }
                            ai.retargetTimer = randRange(1.5, 3);
                        }
                        tx = ai.targetX; ty = ai.targetY;
                        break;

                    case 'coward':
                        // Stay far from IT, near edges with escape routes
                        if (ai.retargetTimer <= 0) {
                            const itChar2 = getITChar();
                            const awayAngle = Math.atan2(ai.y - itChar2.y, ai.x - itChar2.x);
                            ai.targetX = clamp(ARENA_W / 2 + Math.cos(awayAngle) * 500 + randRange(-100, 100), 80, ARENA_W - 80);
                            ai.targetY = clamp(ARENA_H / 2 + Math.sin(awayAngle) * 400 + randRange(-100, 100), 80, ARENA_H - 80);
                            if (isInLava(ai.targetX, ai.targetY)) {
                                ai.targetX = randRange(100, ARENA_W - 100);
                                ai.targetY = randRange(100, ARENA_H - 100);
                            }
                            ai.retargetTimer = randRange(1, 2.5);
                        }
                        tx = ai.targetX; ty = ai.targetY;
                        break;

                    case 'speedy':
                        // Roam fast, seek speed pads
                        if (ai.retargetTimer <= 0 || ai.speedBoostTimer <= 0.5) {
                            if (ai.speedBoostTimer <= 0.5 && Math.random() < 0.5) {
                                const pad = findNearestSpeedPad(ai.x, ai.y);
                                if (pad) { ai.targetX = pad.x; ai.targetY = pad.y; }
                                else { ai.targetX = randRange(80, ARENA_W - 80); ai.targetY = randRange(80, ARENA_H - 80); }
                            } else {
                                ai.targetX = randRange(80, ARENA_W - 80);
                                ai.targetY = randRange(80, ARENA_H - 80);
                            }
                            ai.retargetTimer = randRange(0.6, 1.2);
                        }
                        tx = ai.targetX; ty = ai.targetY;
                        break;

                    default:
                        // chaser, flanker, random ‚Äî roam but avoid lava
                        if (ai.retargetTimer <= 0) {
                            ai.targetX = randRange(80, ARENA_W - 80);
                            ai.targetY = randRange(80, ARENA_H - 80);
                            if (isInLava(ai.targetX, ai.targetY)) {
                                ai.targetX = randRange(80, ARENA_W - 80);
                                ai.targetY = randRange(80, ARENA_H - 80);
                            }
                            ai.retargetTimer = randRange(1, 3);
                        }
                        tx = ai.targetX; ty = ai.targetY;
                        break;
                }
            }
        }

        // --- Move toward target ---
        if (tx !== undefined) {
            const dx = tx - ai.x;
            const dy = ty - ai.y;
            const d = Math.sqrt(dx * dx + dy * dy);
            if (d > 5) {
                // Lava avoidance: steer around lava pools in path
                let steerX = dx / d, steerY = dy / d;
                for (const lp of LAVA_POOLS) {
                    const toLava = distXY(ai.x, ai.y, lp.x, lp.y);
                    if (toLava < lp.radius + 60 && toLava > 10) {
                        const avoidX = ai.x - lp.x;
                        const avoidY = ai.y - lp.y;
                        const avoidD = Math.sqrt(avoidX * avoidX + avoidY * avoidY) || 1;
                        const strength = (lp.radius + 60 - toLava) / (lp.radius + 60);
                        steerX += (avoidX / avoidD) * strength * 1.5;
                        steerY += (avoidY / avoidD) * strength * 1.5;
                    }
                }
                const steerLen = Math.sqrt(steerX * steerX + steerY * steerY) || 1;
                steerX /= steerLen;
                steerY /= steerLen;

                if (ai.onIce) {
                    ai.vx += steerX * speed * dt * 5;
                    ai.vy += steerY * speed * dt * 5;
                    const iceMax = speed * 1.3;
                    const iceSpd = Math.sqrt(ai.vx * ai.vx + ai.vy * ai.vy);
                    if (iceSpd > iceMax) {
                        ai.vx = (ai.vx / iceSpd) * iceMax;
                        ai.vy = (ai.vy / iceSpd) * iceMax;
                    }
                    ai.vx *= ICE_FRICTION;
                    ai.vy *= ICE_FRICTION;
                } else {
                    ai.vx = steerX * speed;
                    ai.vy = steerY * speed;
                }
                ai.faceDirX = steerX;
                ai.faceDirY = steerY;
            } else {
                ai.vx = 0;
                ai.vy = 0;
            }
        }
    }

    // Move
    ai.x += ai.vx * dt;
    ai.y += ai.vy * dt;

    // Wall collision
    const resolved = resolveWallCollision(ai.x, ai.y, ai.radius);
    ai.x = resolved.x;
    ai.y = resolved.y;

    ai.x = clamp(ai.x, ai.radius, ARENA_W - ai.radius);
    ai.y = clamp(ai.y, ai.radius, ARENA_H - ai.radius);

    // Element interactions
    handleElementInteractions(ai, dt);

    if (itIndex !== index) {
        ai.survivalTime += dt;
    }
}

function findClosestTarget(itChar, itIdx) {
    let closest = player;
    let closestDist = dist(itChar, player);

    for (let i = 0; i < aiChars.length; i++) {
        if (i === itIdx) continue;
        const d = dist(itChar, aiChars[i]);
        if (d < closestDist) {
            closestDist = d;
            closest = aiChars[i];
        }
    }
    return closest;
}

function getITChar() {
    if (itIndex === -1) return player;
    return aiChars[itIndex];
}

// --- Tag detection ---
function checkTags() {
    if (immunityTimer > 0) return;

    if (tagMode === 'classic' || tagMode === 'ball') {
        checkTagsClassic();
    } else if (tagMode === 'banana') {
        checkTagsBanana();
    } else if (tagMode === 'freeze') {
        checkTagsFreeze();
    } else if (tagMode === 'zombie') {
        checkTagsZombie();
    }
}

function checkTagsClassic() {
    // Ball tag with balls > 0: skip contact tagging (ball handles it)
    if (tagMode === 'ball' && (settings.ballCount || 1) > 0) return;

    // Hunter bot special ‚Äî skip if stunned
    if (playerInvincible <= 0 && hunterStunTimer <= 0) {
        for (let i = 0; i < aiChars.length; i++) {
            if (aiChars[i].isHunter && dist(aiChars[i], player) < TAG_DISTANCE && itIndex !== -1) {
                if (itIndex >= 0) aiChars[itIndex].expression = 'happy';
                itIndex = -1;
                player.expression = 'it';
                immunityTimer = TAG_IMMUNITY_TIME;
                spawnTagParticles(player.x, player.y);
                showBanner("HUNTED! You're IT!", '#dc2626');
                return;
            }
        }
    }

    if (itIndex === -1) {
        for (let i = 0; i < aiChars.length; i++) {
            // Allow tagging the hunter to stun it
            if (aiChars[i].isHunter) {
                if (dist(player, aiChars[i]) < TAG_DISTANCE && hunterStunTimer <= 0) {
                    hunterStunTimer = 5;
                    spawnTagParticles(aiChars[i].x, aiChars[i].y);
                    showBanner('Hunter stunned!', '#ffd93d');
                    immunityTimer = TAG_IMMUNITY_TIME;
                    // Transfer IT to a random non-hunter bot
                    const candidates = [];
                    for (let j = 0; j < aiChars.length; j++) {
                        if (!aiChars[j].isHunter) candidates.push(j);
                    }
                    if (candidates.length > 0) {
                        const pick = candidates[Math.floor(Math.random() * candidates.length)];
                        performTag(-1, pick);
                    }
                    return;
                }
                continue;
            }
            if (dist(player, aiChars[i]) < TAG_DISTANCE) {
                performTag(-1, i);
                return;
            }
        }
    } else {
        if (playerInvincible <= 0 && dist(aiChars[itIndex], player) < TAG_DISTANCE) {
            performTag(itIndex, -1);
            return;
        }
        for (let i = 0; i < aiChars.length; i++) {
            if (i === itIndex || aiChars[i].isHunter) continue;
            if (dist(aiChars[itIndex], aiChars[i]) < TAG_DISTANCE) {
                performTag(itIndex, i);
                return;
            }
        }
    }
}

function checkTagsBanana() {
    // Everyone is IT. When A tags B, B freezes. frozenBy[B] = A.
    // When C tags A, A freezes, and everyone frozen by A gets unfrozen.

    // Helper: freeze a target, unfreeze anyone that target had frozen
    function bananaFreeze(taggerIdx, targetIdx) {
        // taggerIdx/targetIdx: -1 = player, 0+ = bot index
        const targetChar = targetIdx === -1 ? player : aiChars[targetIdx];
        spawnTagParticles(targetChar.x, targetChar.y);

        // Freeze the target
        if (targetIdx === -1) {
            playerFrozen = true;
            playerFrozenBy = taggerIdx;
            player.vx = 0;
            player.vy = 0;
            const taggerName = taggerIdx === -1 ? 'You' : aiChars[taggerIdx].name;
            showBanner(`${taggerName} got you! üçå`, '#ffd700');
        } else {
            frozenPlayers.add(targetIdx);
            frozenBy.set(targetIdx, taggerIdx);
            aiChars[targetIdx].vx = 0;
            aiChars[targetIdx].vy = 0;
            showBanner(`${aiChars[targetIdx].name} is a banana! üçå`, '#ffd700');
        }

        // Unfreeze everyone that the newly-frozen target had previously frozen
        // Check bots frozen by target
        const toUnfreeze = [];
        for (const [frozenIdx, tagger] of frozenBy) {
            if (tagger === targetIdx) {
                toUnfreeze.push(frozenIdx);
            }
        }
        for (const frozenIdx of toUnfreeze) {
            frozenPlayers.delete(frozenIdx);
            frozenBy.delete(frozenIdx);
            bananaImmunity.set(frozenIdx, 1.0); // 1s immunity after unfreeze
            spawnTagParticles(aiChars[frozenIdx].x, aiChars[frozenIdx].y);
        }
        // Check if player was frozen by target
        if (playerFrozenBy === targetIdx && playerFrozen) {
            // Don't unfreeze if the player IS the target (just got frozen)
            if (targetIdx !== -1) {
                playerFrozen = false;
                playerFrozenBy = -2;
                playerBananaImmunity = 1.0; // 1s immunity
                spawnTagParticles(player.x, player.y);
                showBanner("You're free! üçå", '#6bcb77');
            }
        }
    }

    // Player tags bots
    if (!playerFrozen) {
        for (let i = 0; i < aiChars.length; i++) {
            if (aiChars[i].isHunter || frozenPlayers.has(i)) continue;
            if (bananaImmunity.has(i)) continue; // Immune after unfreeze
            if (dist(player, aiChars[i]) < TAG_DISTANCE) {
                bananaFreeze(-1, i);
                return;
            }
        }
    }

    // Bots tag player
    if (!playerFrozen && playerInvincible <= 0 && playerBananaImmunity <= 0) {
        for (let i = 0; i < aiChars.length; i++) {
            if (aiChars[i].isHunter || frozenPlayers.has(i)) continue;
            if (bananaImmunity.has(i)) continue; // Immune bot can't tag
            if (dist(aiChars[i], player) < TAG_DISTANCE) {
                bananaFreeze(i, -1);
                return;
            }
        }
    }

    // Bots tag other bots
    for (let i = 0; i < aiChars.length; i++) {
        if (aiChars[i].isHunter || frozenPlayers.has(i)) continue;
        if (bananaImmunity.has(i)) continue; // Immune after unfreeze
        for (let j = 0; j < aiChars.length; j++) {
            if (j === i || aiChars[j].isHunter || frozenPlayers.has(j)) continue;
            if (bananaImmunity.has(j)) continue; // Immune after unfreeze
            if (dist(aiChars[i], aiChars[j]) < TAG_DISTANCE) {
                // Resolve: the one moving faster toward the other is the tagger
                const vi = aiChars[i].vx * (aiChars[j].x - aiChars[i].x) + aiChars[i].vy * (aiChars[j].y - aiChars[i].y);
                const vj = aiChars[j].vx * (aiChars[i].x - aiChars[j].x) + aiChars[j].vy * (aiChars[i].y - aiChars[j].y);
                if (vi >= vj) {
                    bananaFreeze(i, j);
                } else {
                    bananaFreeze(j, i);
                }
                return;
            }
        }
    }
}

function checkBananaAllFrozen() {
    // Not used in new banana rules ‚Äî round just runs the timer
}

function checkTagsFreeze() {
    // Red touches blue ‚Üí blue freezes
    // Same-team touches frozen teammate ‚Üí unfreezes
    const playerOnRed = player.team === 'red';

    // --- Red tags blue ---
    // Red bots tag blue bots
    for (const redIdx of teams.red) {
        for (const blueIdx of teams.blue) {
            if (frozenPlayers.has(blueIdx)) continue;
            if (dist(aiChars[redIdx], aiChars[blueIdx]) < TAG_DISTANCE) {
                frozenPlayers.add(blueIdx);
                aiChars[blueIdx].vx = 0;
                aiChars[blueIdx].vy = 0;
                spawnTagParticles(aiChars[blueIdx].x, aiChars[blueIdx].y);
                showBanner(`${aiChars[blueIdx].name} frozen! ‚ùÑÔ∏è`, '#22d3ee');
                checkFreezeAllFrozen();
                return;
            }
        }
    }

    // Player-as-red tags blue bots
    if (playerOnRed) {
        for (const blueIdx of teams.blue) {
            if (frozenPlayers.has(blueIdx)) continue;
            if (dist(player, aiChars[blueIdx]) < TAG_DISTANCE) {
                frozenPlayers.add(blueIdx);
                aiChars[blueIdx].vx = 0;
                aiChars[blueIdx].vy = 0;
                spawnTagParticles(aiChars[blueIdx].x, aiChars[blueIdx].y);
                showBanner(`You froze ${aiChars[blueIdx].name}! ‚ùÑÔ∏è`, '#ff4444');
                checkFreezeAllFrozen();
                return;
            }
        }
    }

    // Red bots tag player-as-blue
    if (!playerOnRed && !playerFrozen && playerInvincible <= 0) {
        for (const redIdx of teams.red) {
            if (dist(aiChars[redIdx], player) < TAG_DISTANCE) {
                playerFrozen = true;
                player.vx = 0;
                player.vy = 0;
                spawnTagParticles(player.x, player.y);
                showBanner("You're frozen! ‚ùÑÔ∏è", '#22d3ee');
                checkFreezeAllFrozen();
                return;
            }
        }
    }

    // --- Blue unfreezes blue ---
    // Blue bots unfreeze other frozen blue bots
    for (const blueIdx of teams.blue) {
        if (frozenPlayers.has(blueIdx)) continue;
        for (const frozenIdx of teams.blue) {
            if (!frozenPlayers.has(frozenIdx)) continue;
            if (dist(aiChars[blueIdx], aiChars[frozenIdx]) < TAG_DISTANCE) {
                frozenPlayers.delete(frozenIdx);
                spawnTagParticles(aiChars[frozenIdx].x, aiChars[frozenIdx].y);
                showBanner(`${aiChars[frozenIdx].name} unfrozen!`, '#4d96ff');
                return;
            }
        }
    }

    // Player-as-blue unfreezes frozen blue bots
    if (!playerOnRed && !playerFrozen) {
        for (const blueIdx of teams.blue) {
            if (!frozenPlayers.has(blueIdx)) continue;
            if (dist(player, aiChars[blueIdx]) < TAG_DISTANCE) {
                frozenPlayers.delete(blueIdx);
                spawnTagParticles(aiChars[blueIdx].x, aiChars[blueIdx].y);
                showBanner(`${aiChars[blueIdx].name} unfrozen!`, '#4d96ff');
                return;
            }
        }
    }

    // Blue bots unfreeze player-as-blue
    if (!playerOnRed && playerFrozen) {
        for (const blueIdx of teams.blue) {
            if (frozenPlayers.has(blueIdx)) continue;
            if (dist(aiChars[blueIdx], player) < TAG_DISTANCE) {
                playerFrozen = false;
                spawnTagParticles(player.x, player.y);
                showBanner("You're unfrozen!", '#4d96ff');
                return;
            }
        }
    }
}

function checkFreezeAllFrozen() {
    // Check if all blue team members are frozen
    let allFrozen = player.team === 'blue' ? playerFrozen : true;
    for (const blueIdx of teams.blue) {
        if (!frozenPlayers.has(blueIdx)) { allFrozen = false; break; }
    }
    if (allFrozen) {
        showBanner("All blues frozen! Red wins! ‚ùÑÔ∏è", '#ff4444');
        roundTimer = 0;
    }
}

function checkTagsZombie() {
    // Zombies tag non-zombies ‚Üí they become zombies

    // Zombie bots tag player
    if (!playerIsZombie && playerInvincible <= 0) {
        for (const zIdx of zombies) {
            if (dist(aiChars[zIdx], player) < TAG_DISTANCE) {
                playerIsZombie = true;
                spawnTagParticles(player.x, player.y);
                showBanner("You're a zombie! üßü", '#22c55e');
                checkZombieAllConverted();
                return;
            }
        }
    }

    // Zombie bots tag non-zombie bots
    for (const zIdx of zombies) {
        for (let i = 0; i < aiChars.length; i++) {
            if (zombies.has(i) || aiChars[i].isHunter) continue;
            if (dist(aiChars[zIdx], aiChars[i]) < TAG_DISTANCE) {
                zombies.add(i);
                aiChars[i].expression = 'it';
                spawnTagParticles(aiChars[i].x, aiChars[i].y);
                showBanner(`${aiChars[i].name} is a zombie! üßü`, '#22c55e');
                checkZombieAllConverted();
                return;
            }
        }
    }

    // Player zombie tags non-zombie bots
    if (playerIsZombie) {
        for (let i = 0; i < aiChars.length; i++) {
            if (zombies.has(i) || aiChars[i].isHunter) continue;
            if (dist(player, aiChars[i]) < TAG_DISTANCE) {
                zombies.add(i);
                aiChars[i].expression = 'it';
                spawnTagParticles(aiChars[i].x, aiChars[i].y);
                showBanner(`${aiChars[i].name} is a zombie! üßü`, '#22c55e');
                checkZombieAllConverted();
                return;
            }
        }
    }
}

function checkZombieAllConverted() {
    // Check if all non-hunter bots + player are zombies
    let allZombies = playerIsZombie;
    for (let i = 0; i < aiChars.length; i++) {
        if (aiChars[i].isHunter) continue;
        if (!zombies.has(i)) { allZombies = false; break; }
    }
    if (allZombies) {
        showBanner("Everyone's a zombie! üßü", '#22c55e');
        roundTimer = 0;
    }
    // Check if player is last non-zombie standing
    if (!playerIsZombie) {
        let playerIsLast = true;
        for (let i = 0; i < aiChars.length; i++) {
            if (aiChars[i].isHunter) continue;
            if (!zombies.has(i)) { playerIsLast = false; break; }
        }
        if (playerIsLast) {
            showBanner("You're the last one! Survive!", '#ffd700');
        }
    }
}

function performTag(fromIdx, toIdx) {
    const taggedChar = toIdx === -1 ? player : aiChars[toIdx];
    spawnTagParticles(taggedChar.x, taggedChar.y);

    if (fromIdx === -1) player.expression = 'happy';
    else aiChars[fromIdx].expression = 'happy';

    itIndex = toIdx === -1 ? -1 : toIdx;
    if (toIdx === -1) {
        player.expression = 'it';
        showBanner("You're IT!", '#ff6b6b');
    } else {
        aiChars[toIdx].expression = 'it';
        showBanner(`${aiChars[toIdx].name} is IT!`, '#ffd93d');
    }

    immunityTimer = TAG_IMMUNITY_TIME;
}

// --- Ball Tag mechanics ---
function throwBall(fromChar, targetX, targetY, throwerIdx) {
    const maxBalls = settings.ballCount || 1;
    if (balls.length >= maxBalls || ballCooldown > 0) return;
    const dx = targetX - fromChar.x;
    const dy = targetY - fromChar.y;
    const d = Math.sqrt(dx * dx + dy * dy) || 1;
    balls.push({
        x: fromChar.x,
        y: fromChar.y,
        vx: (dx / d) * BALL_SPEED,
        vy: (dy / d) * BALL_SPEED,
        life: BALL_LIFETIME,
        throwerIdx: throwerIdx, // -1 = player
        bounced: false,
    });
    ballCooldown = BALL_COOLDOWN;
    spawnShockwave(fromChar.x, fromChar.y, '#ff6b6b');
}

function updateBall(dt) {
    for (let bi = balls.length - 1; bi >= 0; bi--) {
        const b = balls[bi];
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dt;

        // Wall bounce (once)
        if (!b.bounced) {
            if (b.x < 20 || b.x > ARENA_W - 20) { b.vx = -b.vx; b.bounced = true; }
            if (b.y < 20 || b.y > ARENA_H - 20) { b.vy = -b.vy; b.bounced = true; }
            for (const w of WALLS) {
                if (w.x === 0 && w.y === 0 && (w.w === ARENA_W || w.h === ARENA_H)) continue;
                if (b.x > w.x && b.x < w.x + w.w && b.y > w.y && b.y < w.y + w.h) {
                    const fromLeft = b.x - w.x;
                    const fromRight = w.x + w.w - b.x;
                    const fromTop = b.y - w.y;
                    const fromBottom = w.y + w.h - b.y;
                    const minH = Math.min(fromLeft, fromRight);
                    const minV = Math.min(fromTop, fromBottom);
                    if (minH < minV) b.vx = -b.vx;
                    else b.vy = -b.vy;
                    b.bounced = true;
                    break;
                }
            }
        }

        // Check collision with characters
        let hit = false;
        if (b.throwerIdx === -1) {
            for (let i = 0; i < aiChars.length; i++) {
                if (aiChars[i].isHunter) continue;
                if (distXY(b.x, b.y, aiChars[i].x, aiChars[i].y) < BALL_RADIUS + aiChars[i].radius) {
                    spawnTagParticles(aiChars[i].x, aiChars[i].y);
                    player.expression = 'happy';
                    itIndex = i;
                    aiChars[i].expression = 'it';
                    immunityTimer = TAG_IMMUNITY_TIME;
                    showBanner(`${aiChars[i].name} is IT!`, '#ffd93d');
                    hit = true;
                    break;
                }
            }
        } else {
            if (playerInvincible <= 0 && distXY(b.x, b.y, player.x, player.y) < BALL_RADIUS + player.radius) {
                spawnTagParticles(player.x, player.y);
                if (itIndex >= 0) aiChars[itIndex].expression = 'happy';
                itIndex = -1;
                player.expression = 'it';
                immunityTimer = TAG_IMMUNITY_TIME;
                showBanner("Ball hit! You're IT!", '#ff6b6b');
                hit = true;
            }
            if (!hit) {
                for (let i = 0; i < aiChars.length; i++) {
                    if (i === b.throwerIdx || aiChars[i].isHunter) continue;
                    if (distXY(b.x, b.y, aiChars[i].x, aiChars[i].y) < BALL_RADIUS + aiChars[i].radius) {
                        spawnTagParticles(aiChars[i].x, aiChars[i].y);
                        if (itIndex >= 0) aiChars[itIndex].expression = 'happy';
                        itIndex = i;
                        aiChars[i].expression = 'it';
                        immunityTimer = TAG_IMMUNITY_TIME;
                        showBanner(`${aiChars[i].name} is IT!`, '#ffd93d');
                        hit = true;
                        break;
                    }
                }
            }
        }

        // Remove ball on hit or expiry
        if (hit || b.life <= 0) {
            balls.splice(bi, 1);
        }
    }
}

function drawBall() {
    if (balls.length === 0) return;
    ctx.save();
    for (const b of balls) {
        // Motion trail
        const trailLen = 5;
        for (let i = trailLen; i > 0; i--) {
            const t = i / trailLen;
            ctx.globalAlpha = 0.15 * (1 - t);
            ctx.fillStyle = '#ff6b6b';
            ctx.beginPath();
            ctx.arc(b.x - b.vx * 0.003 * i, b.y - b.vy * 0.003 * i, BALL_RADIUS * (1 - t * 0.3), 0, Math.PI * 2);
            ctx.fill();
        }

        // Main ball
        ctx.globalAlpha = 1;
        const grad = ctx.createRadialGradient(b.x - 2, b.y - 2, 0, b.x, b.y, BALL_RADIUS);
        grad.addColorStop(0, '#ff8888');
        grad.addColorStop(0.6, '#ff4444');
        grad.addColorStop(1, '#cc0000');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(b.x, b.y, BALL_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        // Glow
        ctx.fillStyle = 'rgba(255,100,100,0.3)';
        ctx.beginPath();
        ctx.arc(b.x, b.y, BALL_RADIUS * 2, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
}

// Ball throw click/tap handler
canvas.addEventListener('click', (e) => {
    if (tagMode !== 'ball' || gameState !== 'playing') return;
    if (itIndex !== -1) return; // Player is not IT
    const maxBalls = settings.ballCount || 1;
    if (balls.length >= maxBalls || ballCooldown > 0) return;

    const rect = canvas.getBoundingClientRect();
    const clickX = e.clientX - rect.left + camX;
    const clickY = e.clientY - rect.top + camY;
    throwBall(player, clickX, clickY, -1);
});

canvas.addEventListener('touchend', (e) => {
    if (tagMode !== 'ball' || gameState !== 'playing') return;
    if (itIndex !== -1) return;
    const maxBalls = settings.ballCount || 1;
    if (balls.length >= maxBalls || ballCooldown > 0) return;

    // Use the last touch position
    if (e.changedTouches.length > 0) {
        const touch = e.changedTouches[0];
        // Don't throw if touch was on joystick or buttons
        const jRect = joystickArea.getBoundingClientRect();
        if (touch.clientX >= jRect.left && touch.clientX <= jRect.right &&
            touch.clientY >= jRect.top && touch.clientY <= jRect.bottom) return;

        const rect = canvas.getBoundingClientRect();
        const clickX = touch.clientX - rect.left + camX;
        const clickY = touch.clientY - rect.top + camY;
        throwBall(player, clickX, clickY, -1);
    }
});

// --- Particles update ---
function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.95;
        p.vy *= 0.95;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
    }

    for (let i = dashTrails.length - 1; i >= 0; i--) {
        const t = dashTrails[i];
        t.life -= dt;
        if (t.life <= 0) dashTrails.splice(i, 1);
    }

    for (let i = confetti.length - 1; i >= 0; i--) {
        const c = confetti[i];
        c.x += c.vx * dt;
        c.y += c.vy * dt;
        c.rotation += c.rotSpeed * dt;
        c.life -= dt;
        if (c.life <= 0) confetti.splice(i, 1);
    }

    for (let i = trampolineAnims.length - 1; i >= 0; i--) {
        trampolineAnims[i].timer -= dt;
        if (trampolineAnims[i].timer <= 0) trampolineAnims.splice(i, 1);
    }

    // Ambient particles
    while (ambientParticles.length < MAX_AMBIENT) spawnAmbientParticle();
    for (let i = ambientParticles.length - 1; i >= 0; i--) {
        const a = ambientParticles[i];
        a.x += a.vx * dt;
        a.y += a.vy * dt;
        a.vx += Math.sin(gameTime + a.pulse) * 2 * dt;
        a.pulse += dt;
        a.life -= dt;
        if (a.life <= 0 || a.y < -10) { ambientParticles.splice(i, 1); }
    }

    // Screen shake
    if (shakeTimer > 0) shakeTimer = Math.max(0, shakeTimer - dt);

    // Shockwaves
    for (let i = shockwaves.length - 1; i >= 0; i--) {
        const s = shockwaves[i];
        s.life -= dt;
        const progress = 1 - s.life / s.maxLife;
        s.radius = 10 + progress * s.maxRadius;
        s.lineWidth = 4 * (1 - progress);
        if (s.life <= 0) shockwaves.splice(i, 1);
    }

    // Footsteps
    for (let i = footsteps.length - 1; i >= 0; i--) {
        footsteps[i].life -= dt;
        if (footsteps[i].life <= 0) footsteps.splice(i, 1);
    }

    // Emotion particles
    for (let i = emotionParticles.length - 1; i >= 0; i--) {
        const e = emotionParticles[i];
        e.x += (e.vx || 0) * dt;
        e.y += (e.vy || 0) * dt;
        if (e.type === 'steam') e.size += dt * 6;
        if (e.type === 'sweat') e.vy += 100 * dt; // gravity
        if (e.type === 'star') e.rotation = (e.rotation || 0) + dt * 5;
        e.life -= dt;
        if (e.life <= 0) emotionParticles.splice(i, 1);
    }

    // Speed lines
    for (let i = speedLines.length - 1; i >= 0; i--) {
        speedLines[i].life -= dt;
        if (speedLines[i].life <= 0) speedLines.splice(i, 1);
    }

    // Spawn footsteps for moving characters
    playerFootstepTimer -= dt;
    const pSpd = Math.sqrt(player.vx * player.vx + player.vy * player.vy);
    if (pSpd > 50 && playerFootstepTimer <= 0) {
        spawnFootstep(player.x, player.y + player.radius, player.color + '60', 2.5);
        playerFootstepTimer = FOOTSTEP_INTERVAL;
    }
    for (const ai of aiChars) {
        const aiSpd = Math.sqrt(ai.vx * ai.vx + ai.vy * ai.vy);
        if (!ai._footTimer) ai._footTimer = 0;
        ai._footTimer -= dt;
        if (aiSpd > 50 && ai._footTimer <= 0) {
            spawnFootstep(ai.x, ai.y + ai.radius, ai.color + '40', 2);
            ai._footTimer = FOOTSTEP_INTERVAL;
        }
    }

    // Spawn speed lines when dashing
    if (player.isDashing) {
        spawnSpeedLine(player.x, player.y, player.vx, player.vy);
    }
    for (const ai of aiChars) {
        if (ai.isDashing) spawnSpeedLine(ai.x, ai.y, ai.vx, ai.vy);
    }

    // Spawn emotion particles for characters
    if (Math.random() < 0.15) {
        // Scared characters emit sweat drops
        for (const ai of aiChars) {
            if (ai.expression === 'scared' && Math.random() < 0.3) {
                spawnEmotionParticle(ai.x + randRange(-8, 8), ai.y - ai.radius, 'sweat');
            }
        }
        if (player.expression === 'scared' && Math.random() < 0.3) {
            spawnEmotionParticle(player.x + randRange(-8, 8), player.y - player.radius, 'sweat');
        }
        // IT characters emit steam/anger
        if (itIndex >= 0 && Math.random() < 0.25) {
            const itChar = aiChars[itIndex];
            spawnEmotionParticle(itChar.x + randRange(-5, 5), itChar.y - itChar.radius - 5, 'steam');
        }
        if (itIndex === -1 && Math.random() < 0.25) {
            spawnEmotionParticle(player.x + randRange(-5, 5), player.y - player.radius - 5, 'steam');
        }
    }
}

// --- Camera ---
function updateCamera() {
    const targetX = player.x - canvas.width / 2;
    const targetY = player.y - canvas.height / 2;
    camX += (targetX - camX) * CAMERA_LERP;
    camY += (targetY - camY) * CAMERA_LERP;

    camX = clamp(camX, 0, Math.max(0, ARENA_W - canvas.width));
    camY = clamp(camY, 0, Math.max(0, ARENA_H - canvas.height));
}

// ============================================================
// DRAWING ‚Äî Enhanced Graphics
// ============================================================

// Pre-generate floor tile pattern offcanvas
let floorPattern = null;
function generateFloorPattern() {
    const pc = document.createElement('canvas');
    pc.width = 80; pc.height = 80;
    const px = pc.getContext('2d');
    // Base tile ‚Äî bright grass-like
    px.fillStyle = '#7cc87a';
    px.fillRect(0, 0, 80, 80);
    // Subtle checker
    px.fillStyle = '#72c070';
    px.fillRect(0, 0, 40, 40);
    px.fillRect(40, 40, 40, 40);
    // Tiny dot texture for grass feel
    px.fillStyle = 'rgba(255,255,255,0.06)';
    for (let i = 0; i < 15; i++) {
        const dx = (i * 13 + 3) % 80, dy = (i * 19 + 7) % 80;
        px.fillRect(dx, dy, 1, 1);
    }
    // Cross-hatch subtle pattern
    px.strokeStyle = 'rgba(0,0,0,0.03)';
    px.lineWidth = 0.5;
    for (let i = 0; i < 80; i += 20) {
        px.beginPath(); px.moveTo(i, 0); px.lineTo(i, 80); px.stroke();
        px.beginPath(); px.moveTo(0, i); px.lineTo(80, i); px.stroke();
    }
    // Grid line
    px.strokeStyle = 'rgba(0,0,0,0.04)';
    px.lineWidth = 1;
    px.strokeRect(0.5, 0.5, 79, 79);
    // Small diamond accent in center
    px.fillStyle = 'rgba(255,255,255,0.04)';
    px.beginPath();
    px.moveTo(40, 36); px.lineTo(44, 40); px.lineTo(40, 44); px.lineTo(36, 40);
    px.closePath(); px.fill();
    floorPattern = ctx.createPattern(pc, 'repeat');
}

function drawArena() {
    if (!floorPattern) generateFloorPattern();
    // Tiled floor
    ctx.fillStyle = floorPattern;
    ctx.fillRect(0, 0, ARENA_W, ARENA_H);

    // Subtle radial vignette on arena (light)
    const vig = ctx.createRadialGradient(ARENA_W/2, ARENA_H/2, 200, ARENA_W/2, ARENA_H/2, ARENA_W * 0.7);
    vig.addColorStop(0, 'rgba(255,255,255,0)');
    vig.addColorStop(1, 'rgba(0,0,0,0.08)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, ARENA_W, ARENA_H);

    // Decorative corner markings
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 2;
    const cm = 60;
    // Top-left
    ctx.beginPath(); ctx.moveTo(20, 20 + cm); ctx.lineTo(20, 20); ctx.lineTo(20 + cm, 20); ctx.stroke();
    // Top-right
    ctx.beginPath(); ctx.moveTo(ARENA_W - 20 - cm, 20); ctx.lineTo(ARENA_W - 20, 20); ctx.lineTo(ARENA_W - 20, 20 + cm); ctx.stroke();
    // Bottom-left
    ctx.beginPath(); ctx.moveTo(20, ARENA_H - 20 - cm); ctx.lineTo(20, ARENA_H - 20); ctx.lineTo(20 + cm, ARENA_H - 20); ctx.stroke();
    // Bottom-right
    ctx.beginPath(); ctx.moveTo(ARENA_W - 20, ARENA_H - 20 - cm); ctx.lineTo(ARENA_W - 20, ARENA_H - 20); ctx.lineTo(ARENA_W - 20 - cm, ARENA_H - 20); ctx.stroke();

    // Center circle decoration
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(ARENA_W/2, ARENA_H/2, 100, 0, Math.PI * 2);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(ARENA_W/2, ARENA_H/2, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fill();
}

function drawWalls() {
    for (const w of WALLS) {
        const isHoriz = w.w > w.h;
        const isBorder = w.x <= 0 || w.y <= 0 || w.x + w.w >= ARENA_W || w.y + w.h >= ARENA_H;

        // Wall shadow
        if (!isBorder) {
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.fillRect(w.x + 4, w.y + 4, w.w, w.h);
        }

        // Wall body gradient
        if (isBorder) {
            ctx.fillStyle = '#8b7355';
        } else {
            const wg = isHoriz
                ? ctx.createLinearGradient(w.x, w.y, w.x, w.y + w.h)
                : ctx.createLinearGradient(w.x, w.y, w.x + w.w, w.y);
            wg.addColorStop(0, '#c4a97d');
            wg.addColorStop(0.5, '#b09060');
            wg.addColorStop(1, '#9a7b50');
            ctx.fillStyle = wg;
        }
        ctx.fillRect(w.x, w.y, w.w, w.h);

        // Brick pattern (only non-border, large enough walls)
        if (!isBorder && (w.w > 40 || w.h > 40)) {
            ctx.fillStyle = 'rgba(0,0,0,0.08)';
            if (isHoriz) {
                for (let bx = w.x + 15; bx < w.x + w.w - 5; bx += 30) {
                    ctx.fillRect(bx, w.y, 1, w.h);
                }
            } else {
                for (let by = w.y + 15; by < w.y + w.h - 5; by += 30) {
                    ctx.fillRect(w.x, by, w.w, 1);
                }
            }
        }

        // Top/left highlight
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.fillRect(w.x, w.y, w.w, 2);
        ctx.fillRect(w.x, w.y, 2, w.h);
        // Bottom/right shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fillRect(w.x, w.y + w.h - 2, w.w, 2);
        ctx.fillRect(w.x + w.w - 2, w.y, 2, w.h);

        // Edge outline
        if (!isBorder) {
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(w.x + 0.5, w.y + 0.5, w.w - 1, w.h - 1);
        }
    }
}

function drawPortals() {
    for (const p of PORTALS) {
        // Draw connection beam between paired portals
        ctx.save();
        ctx.globalAlpha = 0.04 + Math.sin(gameTime * 2) * 0.02;
        ctx.strokeStyle = p.color1;
        ctx.lineWidth = 3;
        ctx.setLineDash([8, 12]);
        ctx.beginPath();
        ctx.moveTo(p.ax, p.ay);
        ctx.lineTo(p.bx, p.by);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
        ctx.restore();

        drawSinglePortal(p.ax, p.ay, p.radius, p.color1);
        drawSinglePortal(p.bx, p.by, p.radius, p.color2);
    }
}

function drawSinglePortal(x, y, r, color) {
    ctx.save();
    const t = gameTime;

    // Large ambient glow
    const glow = ctx.createRadialGradient(x, y, 0, x, y, r * 2.5);
    glow.addColorStop(0, color + '30');
    glow.addColorStop(0.4, color + '15');
    glow.addColorStop(1, color + '00');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(x, y, r * 2.5, 0, Math.PI * 2);
    ctx.fill();

    // Dark inner void
    const voidGrad = ctx.createRadialGradient(x, y, 0, x, y, r);
    voidGrad.addColorStop(0, '#1a3a5a');
    voidGrad.addColorStop(0.6, '#2a4a6a80');
    voidGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = voidGrad;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fill();

    // Multiple swirl rings with different speeds
    for (let i = 0; i < 5; i++) {
        const angle = t * (1.5 + i * 0.7) + i * Math.PI * 2 / 5;
        const ringR = r * (0.35 + i * 0.13);
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.5 - i * 0.08;
        ctx.lineWidth = 3 - i * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, ringR, angle, angle + Math.PI * (0.8 + i * 0.15));
        ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // Floating orbs around portal
    for (let i = 0; i < 4; i++) {
        const orbAngle = t * 2 + i * Math.PI / 2;
        const orbR = r * 0.85;
        const ox = x + Math.cos(orbAngle) * orbR;
        const oy = y + Math.sin(orbAngle) * orbR;
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(ox, oy, 2.5, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Bright center core
    const coreGrad = ctx.createRadialGradient(x, y, 0, x, y, r * 0.25);
    coreGrad.addColorStop(0, '#fff');
    coreGrad.addColorStop(0.5, color);
    coreGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = coreGrad;
    ctx.globalAlpha = 0.5 + Math.sin(t * 4) * 0.2;
    ctx.beginPath();
    ctx.arc(x, y, r * 0.25, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    ctx.restore();
}

function drawTrampolines() {
    for (const t of TRAMPOLINES) {
        const cx = t.x + t.w / 2;
        const cy = t.y + t.h / 2;

        let squish = 0;
        for (const a of trampolineAnims) {
            if (a.x === t.x && a.y === t.y) { squish = a.timer / 0.3; break; }
        }

        ctx.save();

        // Ground shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(cx, cy + t.h / 2 + 3, t.w / 2 + 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.translate(cx, cy);
        if (squish > 0) ctx.scale(1 + squish * 0.35, 1 - squish * 0.4);

        // Spring coils underneath
        ctx.strokeStyle = '#0e7490';
        ctx.lineWidth = 2.5;
        const coilY = t.h / 2 - 2;
        for (let i = 0; i < 3; i++) {
            const sx = -10 + i * 10;
            const springBounce = Math.sin(gameTime * 5 + i) * 1.5;
            ctx.beginPath();
            ctx.moveTo(sx, coilY);
            ctx.bezierCurveTo(sx - 4, coilY - 5 + springBounce, sx + 4, coilY - 10 + springBounce, sx, coilY - 14);
            ctx.stroke();
        }

        // Pad body
        const grad = ctx.createLinearGradient(0, -t.h / 2, 0, t.h / 2 - 8);
        grad.addColorStop(0, '#67e8f9');
        grad.addColorStop(0.5, '#22d3ee');
        grad.addColorStop(1, '#0891b2');
        ctx.fillStyle = grad;
        const hw = t.w / 2, hh = t.h / 2 - 6, rr = 8;
        ctx.beginPath();
        ctx.moveTo(-hw + rr, -hh); ctx.lineTo(hw - rr, -hh);
        ctx.quadraticCurveTo(hw, -hh, hw, -hh + rr);
        ctx.lineTo(hw, hh - rr); ctx.quadraticCurveTo(hw, hh, hw - rr, hh);
        ctx.lineTo(-hw + rr, hh); ctx.quadraticCurveTo(-hw, hh, -hw, hh - rr);
        ctx.lineTo(-hw, -hh + rr); ctx.quadraticCurveTo(-hw, -hh, -hw + rr, -hh);
        ctx.closePath();
        ctx.fill();

        // Shine stripe
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(-hw + 4, -hh + 2, hw * 2 - 8, 4);

        // Animated up-arrow
        const bounce = Math.sin(gameTime * 5) * 3;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2.5;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(-8, 2 + bounce);
        ctx.lineTo(0, -6 + bounce);
        ctx.lineTo(8, 2 + bounce);
        ctx.stroke();

        // Border glow
        ctx.shadowColor = '#22d3ee';
        ctx.shadowBlur = 8;
        ctx.strokeStyle = '#a5f3fc';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-hw + rr, -hh); ctx.lineTo(hw - rr, -hh);
        ctx.quadraticCurveTo(hw, -hh, hw, -hh + rr);
        ctx.lineTo(hw, hh - rr); ctx.quadraticCurveTo(hw, hh, hw - rr, hh);
        ctx.lineTo(-hw + rr, hh); ctx.quadraticCurveTo(-hw, hh, -hw, hh - rr);
        ctx.lineTo(-hw, -hh + rr); ctx.quadraticCurveTo(-hw, -hh, -hw + rr, -hh);
        ctx.closePath();
        ctx.stroke();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

function drawLavaPools() {
    for (const lp of LAVA_POOLS) {
        ctx.save();

        // Large ambient glow
        const glow2 = ctx.createRadialGradient(lp.x, lp.y, lp.radius * 0.3, lp.x, lp.y, lp.radius * 2);
        glow2.addColorStop(0, 'rgba(255,60,0,0.12)');
        glow2.addColorStop(0.5, 'rgba(255,30,0,0.06)');
        glow2.addColorStop(1, 'rgba(255,0,0,0)');
        ctx.fillStyle = glow2;
        ctx.beginPath();
        ctx.arc(lp.x, lp.y, lp.radius * 2, 0, Math.PI * 2);
        ctx.fill();

        // Rocky rim
        ctx.fillStyle = '#3d2b1f';
        ctx.beginPath();
        ctx.arc(lp.x, lp.y, lp.radius + 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#5c3d2e';
        for (let i = 0; i < 10; i++) {
            const a = i * Math.PI * 2 / 10 + 0.2;
            const bx = lp.x + Math.cos(a) * (lp.radius + 3 + Math.sin(i * 2.3) * 3);
            const by = lp.y + Math.sin(a) * (lp.radius + 3 + Math.cos(i * 1.7) * 3);
            ctx.beginPath();
            ctx.arc(bx, by, 5 + (i % 3), 0, Math.PI * 2);
            ctx.fill();
        }

        // Lava body with animated color shifts
        const lavaGrad = ctx.createRadialGradient(
            lp.x + Math.sin(gameTime) * 5, lp.y + Math.cos(gameTime * 1.3) * 5, 0,
            lp.x, lp.y, lp.radius
        );
        lavaGrad.addColorStop(0, '#ffaa00');
        lavaGrad.addColorStop(0.3, '#ff6600');
        lavaGrad.addColorStop(0.6, '#dc2626');
        lavaGrad.addColorStop(0.85, '#991b1b');
        lavaGrad.addColorStop(1, '#5c1010');
        ctx.fillStyle = lavaGrad;
        ctx.beginPath();
        ctx.arc(lp.x, lp.y, lp.radius, 0, Math.PI * 2);
        ctx.fill();

        // Animated flowing veins
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4 + Math.sin(gameTime * 2.5) * 0.15;
        for (let i = 0; i < 6; i++) {
            const a = gameTime * 0.4 + i * Math.PI / 3;
            const r1 = lp.radius * 0.1;
            const r2 = lp.radius * 0.75;
            ctx.beginPath();
            ctx.moveTo(lp.x + Math.cos(a) * r1, lp.y + Math.sin(a) * r1);
            ctx.quadraticCurveTo(
                lp.x + Math.cos(a + 0.4) * lp.radius * 0.5,
                lp.y + Math.sin(a + 0.3) * lp.radius * 0.5,
                lp.x + Math.cos(a + 0.7) * r2,
                lp.y + Math.sin(a + 0.6) * r2
            );
            ctx.stroke();
        }
        ctx.globalAlpha = 1;

        // Hot bright spots
        for (let i = 0; i < 3; i++) {
            const sa = gameTime * 0.6 + i * 2.1;
            const sr = lp.radius * 0.3 * (0.5 + (i % 2) * 0.3);
            const sx = lp.x + Math.cos(sa) * sr;
            const sy = lp.y + Math.sin(sa) * sr;
            const spotGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, 8);
            spotGrad.addColorStop(0, 'rgba(255,255,150,0.6)');
            spotGrad.addColorStop(1, 'rgba(255,100,0,0)');
            ctx.fillStyle = spotGrad;
            ctx.beginPath();
            ctx.arc(sx, sy, 8, 0, Math.PI * 2);
            ctx.fill();
        }

        // Danger symbol
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = 'rgba(255,200,0,0.3)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('!', lp.x, lp.y);

        ctx.restore();
    }

    // Spawn lava bubbles more frequently for richer effect
    if (Math.random() < 0.4) {
        const pool = LAVA_POOLS[Math.floor(Math.random() * LAVA_POOLS.length)];
        spawnLavaBubble(pool);
    }
    // Spawn ember particles that rise from lava
    if (Math.random() < 0.15) {
        const pool = LAVA_POOLS[Math.floor(Math.random() * LAVA_POOLS.length)];
        const a = Math.random() * Math.PI * 2;
        const r = Math.random() * pool.radius * 0.6;
        particles.push({
            x: pool.x + Math.cos(a) * r,
            y: pool.y + Math.sin(a) * r,
            vx: randRange(-5, 5),
            vy: randRange(-25, -50),
            life: randRange(1, 2.5),
            maxLife: 2.5,
            radius: randRange(1, 2.5),
            color: `hsl(${randRange(15, 45)}, 100%, ${randRange(55, 75)}%)`,
        });
    }
}

function drawSpeedPads() {
    for (const sp of SPEED_PADS) {
        ctx.save();
        const cx = sp.x + sp.w / 2;
        const cy = sp.y + sp.h / 2;
        ctx.translate(cx, cy);
        ctx.rotate(sp.angle);

        // Neon glow under pad
        ctx.shadowColor = '#facc15';
        ctx.shadowBlur = 15;

        // Pad body
        const grad = ctx.createLinearGradient(-sp.w / 2, 0, sp.w / 2, 0);
        grad.addColorStop(0, '#fbbf24');
        grad.addColorStop(0.5, '#f59e0b');
        grad.addColorStop(1, '#d97706');
        ctx.fillStyle = grad;

        // Rounded pad shape
        const rr = 5;
        ctx.beginPath();
        ctx.moveTo(-sp.w/2 + rr, -sp.h/2);
        ctx.lineTo(sp.w/2 - rr, -sp.h/2);
        ctx.quadraticCurveTo(sp.w/2, -sp.h/2, sp.w/2, -sp.h/2 + rr);
        ctx.lineTo(sp.w/2, sp.h/2 - rr);
        ctx.quadraticCurveTo(sp.w/2, sp.h/2, sp.w/2 - rr, sp.h/2);
        ctx.lineTo(-sp.w/2 + rr, sp.h/2);
        ctx.quadraticCurveTo(-sp.w/2, sp.h/2, -sp.w/2, sp.h/2 - rr);
        ctx.lineTo(-sp.w/2, -sp.h/2 + rr);
        ctx.quadraticCurveTo(-sp.w/2, -sp.h/2, -sp.w/2 + rr, -sp.h/2);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;

        // Chevron arrows (animated)
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        const arrowOffset = (gameTime * 60) % 16;
        for (let i = -2; i <= 2; i++) {
            const ax = i * 14 - arrowOffset + 7;
            ctx.beginPath();
            ctx.moveTo(ax - 4, -5);
            ctx.lineTo(ax + 4, 0);
            ctx.lineTo(ax - 4, 5);
            ctx.lineTo(ax - 1, 0);
            ctx.closePath();
            ctx.fill();
        }

        // Bright edge
        ctx.strokeStyle = '#fde68a';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-sp.w/2 + rr, -sp.h/2);
        ctx.lineTo(sp.w/2 - rr, -sp.h/2);
        ctx.quadraticCurveTo(sp.w/2, -sp.h/2, sp.w/2, -sp.h/2 + rr);
        ctx.lineTo(sp.w/2, sp.h/2 - rr);
        ctx.quadraticCurveTo(sp.w/2, sp.h/2, sp.w/2 - rr, sp.h/2);
        ctx.lineTo(-sp.w/2 + rr, sp.h/2);
        ctx.quadraticCurveTo(-sp.w/2, sp.h/2, -sp.w/2, sp.h/2 - rr);
        ctx.lineTo(-sp.w/2, -sp.h/2 + rr);
        ctx.quadraticCurveTo(-sp.w/2, -sp.h/2, -sp.w/2 + rr, -sp.h/2);
        ctx.closePath();
        ctx.stroke();

        ctx.restore();
    }
}

function drawIcePatches() {
    for (const ip of ICE_PATCHES) {
        ctx.save();

        // Ice surface ‚Äî layered translucent fill
        const iceGrad = ctx.createRadialGradient(ip.x - ip.radius * 0.2, ip.y - ip.radius * 0.2, 0, ip.x, ip.y, ip.radius);
        iceGrad.addColorStop(0, 'rgba(200,225,255,0.4)');
        iceGrad.addColorStop(0.4, 'rgba(147,197,253,0.3)');
        iceGrad.addColorStop(0.8, 'rgba(96,165,250,0.2)');
        iceGrad.addColorStop(1, 'rgba(59,130,246,0.05)');
        ctx.fillStyle = iceGrad;
        ctx.beginPath();
        ctx.arc(ip.x, ip.y, ip.radius, 0, Math.PI * 2);
        ctx.fill();

        // Crack lines
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        const cracks = [
            [0.0, 0.0, 0.5, -0.4], [0.0, 0.0, -0.3, 0.6], [0.0, 0.0, 0.6, 0.3],
            [0.5, -0.4, 0.7, -0.2], [-0.3, 0.6, -0.5, 0.3], [0.6, 0.3, 0.4, 0.7]
        ];
        for (const [x1, y1, x2, y2] of cracks) {
            ctx.beginPath();
            ctx.moveTo(ip.x + x1 * ip.radius, ip.y + y1 * ip.radius);
            ctx.lineTo(ip.x + x2 * ip.radius, ip.y + y2 * ip.radius);
            ctx.stroke();
        }

        // Reflective highlight
        ctx.fillStyle = 'rgba(255,255,255,0.12)';
        ctx.beginPath();
        ctx.ellipse(ip.x - ip.radius * 0.2, ip.y - ip.radius * 0.25, ip.radius * 0.5, ip.radius * 0.25, -0.3, 0, Math.PI * 2);
        ctx.fill();

        // Animated sparkles
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 8; i++) {
            const sa = gameTime * 0.4 + i * Math.PI / 4;
            const sr = ip.radius * (0.2 + (i % 4) * 0.18);
            const sx = ip.x + Math.cos(sa) * sr;
            const sy = ip.y + Math.sin(sa * 1.3) * sr;
            const sz = 1.2 + Math.sin(gameTime * 4 + i * 1.5) * 1;
            if (sz > 0.5) {
                ctx.globalAlpha = sz / 2.2;
                // Draw 4-point star
                ctx.beginPath();
                ctx.moveTo(sx, sy - sz); ctx.lineTo(sx + sz * 0.3, sy);
                ctx.lineTo(sx, sy + sz); ctx.lineTo(sx - sz * 0.3, sy);
                ctx.closePath();
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(sx - sz, sy); ctx.lineTo(sx, sy + sz * 0.3);
                ctx.lineTo(sx + sz, sy); ctx.lineTo(sx, sy - sz * 0.3);
                ctx.closePath();
                ctx.fill();
            }
        }
        ctx.globalAlpha = 1;

        // Dashed edge
        ctx.strokeStyle = 'rgba(186,220,255,0.25)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 6]);
        ctx.beginPath();
        ctx.arc(ip.x, ip.y, ip.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.restore();
    }
}

function drawBumpers() {
    for (const b of BUMPERS) {
        ctx.save();

        const pulse = 1 + Math.sin(gameTime * 5) * 0.08;

        // Ground shadow
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.beginPath();
        ctx.ellipse(b.x + 2, b.y + b.radius + 4, b.radius * 0.9, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Outer glow rings
        ctx.shadowColor = '#f97316';
        ctx.shadowBlur = 12;
        for (let i = 2; i >= 0; i--) {
            const ringR = b.radius * pulse + i * 4;
            ctx.strokeStyle = `rgba(249,115,22,${0.08 - i * 0.02})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(b.x, b.y, ringR, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;

        // Body with 3D sphere look
        const bodyGrad = ctx.createRadialGradient(b.x - b.radius * 0.3, b.y - b.radius * 0.3, 0, b.x, b.y, b.radius * pulse);
        bodyGrad.addColorStop(0, '#fcd34d');
        bodyGrad.addColorStop(0.3, '#fb923c');
        bodyGrad.addColorStop(0.7, '#f97316');
        bodyGrad.addColorStop(1, '#c2410c');
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius * pulse, 0, Math.PI * 2);
        ctx.fill();

        // Glass highlight
        ctx.fillStyle = 'rgba(255,255,255,0.45)';
        ctx.beginPath();
        ctx.ellipse(b.x - 3, b.y - 5, b.radius * 0.3, b.radius * 0.2, -0.4, 0, Math.PI * 2);
        ctx.fill();

        // Ring border
        ctx.strokeStyle = '#fed7aa';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius * pulse, 0, Math.PI * 2);
        ctx.stroke();

        // Inner ring
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius * pulse * 0.6, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
    }
}

function drawCharacter(char, isIT, isPlayer) {
    const x = char.x;
    const y = char.y;
    const r = char.radius;
    // Bounce animation based on movement speed
    const spd = Math.sqrt(char.vx * char.vx + char.vy * char.vy);
    const bounceY = spd > 30 ? Math.sin(gameTime * 12) * 2.5 : Math.sin(gameTime * 3) * 0.8;
    const squishX = spd > 30 ? 1 + Math.sin(gameTime * 12) * 0.04 : 1;
    const squishY = spd > 30 ? 1 - Math.sin(gameTime * 12) * 0.04 : 1;

    ctx.save();

    // Character color aura glow (always present, subtle)
    const auraAlpha = 0.08 + Math.sin(gameTime * 2 + x * 0.01) * 0.03;
    const auraGrad = ctx.createRadialGradient(x, y + bounceY, r * 0.5, x, y + bounceY, r * 2.2);
    auraGrad.addColorStop(0, (isIT ? '#ff4444' : char.color) + '25');
    auraGrad.addColorStop(1, (isIT ? '#ff4444' : char.color) + '00');
    ctx.globalAlpha = auraAlpha + (isIT ? 0.08 : 0);
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.arc(x, y + bounceY, r * 2.2, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Speed boost aura ‚Äî spinning particles
    if (char.speedBoostTimer > 0) {
        for (let i = 0; i < 6; i++) {
            const aAngle = gameTime * 6 + i * Math.PI / 3;
            const aR = r + 8 + Math.sin(gameTime * 4 + i) * 3;
            const ax = x + Math.cos(aAngle) * aR;
            const ay = y + bounceY + Math.sin(aAngle) * aR;
            ctx.fillStyle = '#ffd700';
            ctx.globalAlpha = 0.3 + Math.sin(gameTime * 5 + i) * 0.15;
            ctx.beginPath();
            ctx.arc(ax, ay, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // Freeze effect on bots
    if (!isPlayer && freezeTimer > 0) {
        ctx.globalAlpha = 0.3;
        ctx.fillStyle = '#88ddff';
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        // Snowflake particles
        ctx.fillStyle = '#fff';
        for (let i = 0; i < 3; i++) {
            const sa = gameTime * 0.5 + i * Math.PI * 2 / 3;
            ctx.globalAlpha = 0.5;
            ctx.beginPath();
            ctx.arc(x + Math.cos(sa) * (r + 6), y + bounceY + Math.sin(sa) * (r + 6), 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // Lava burn flash
    if (char.lavaFlashTimer > 0) {
        ctx.globalAlpha = char.lavaFlashTimer / 0.15 * 0.3;
        ctx.fillStyle = '#ff4500';
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }

    // IT glow ‚Äî pulsing
    if (isIT) {
        const glowSize = r * (2.5 + Math.sin(gameTime * 4) * 0.5);
        const gradient = ctx.createRadialGradient(x, y + bounceY, r * 0.5, x, y + bounceY, glowSize);
        gradient.addColorStop(0, 'rgba(255,40,40,0.35)');
        gradient.addColorStop(0.5, 'rgba(255,40,40,0.1)');
        gradient.addColorStop(1, 'rgba(255,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(x, y + bounceY, glowSize, 0, Math.PI * 2);
        ctx.fill();
    }

    // Shadow ‚Äî scales with bounce
    const shadowScale = 1 - bounceY * 0.02;
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.beginPath();
    ctx.ellipse(x, y + r + 5, r * 0.85 * shadowScale, r * 0.25 * shadowScale, 0, 0, Math.PI * 2);
    ctx.fill();

    // Dash afterimage trail
    if (char.isDashing) {
        for (let i = 1; i <= 3; i++) {
            ctx.globalAlpha = 0.15 / i;
            ctx.fillStyle = char.color;
            ctx.beginPath();
            ctx.arc(x - char.vx * 0.015 * i, y + bounceY - char.vy * 0.015 * i, r * (1 - i * 0.1), 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // Body with squish transform
    ctx.save();
    ctx.translate(x, y + bounceY);
    ctx.scale(squishX, squishY);

    // Main body
    const bodyColor = isIT ? '#ff4444' : char.color;
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    // Body gradient shine
    const shineGrad = ctx.createRadialGradient(-r * 0.3, -r * 0.35, 0, 0, 0, r);
    shineGrad.addColorStop(0, 'rgba(255,255,255,0.45)');
    shineGrad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
    shineGrad.addColorStop(1, 'rgba(0,0,0,0.1)');
    ctx.fillStyle = shineGrad;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fill();

    // Colored outline
    ctx.strokeStyle = isIT ? '#ff0000' : bodyColor;
    ctx.lineWidth = isIT ? 3 : 2;
    ctx.globalAlpha = isIT ? 1 : 0.5;
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Eyes ‚Äî larger, more expressive
    const eyeOffsetX = char.faceDirX * 3.5;
    const eyeOffsetY = char.faceDirY * 3;
    const eyeSpacing = r * 0.38;
    const eyeW = r * 0.32;
    const eyeH = r * 0.36;

    // Eye whites (slightly oval)
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.ellipse(-eyeSpacing + eyeOffsetX, -2 + eyeOffsetY, eyeW, eyeH, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(eyeSpacing + eyeOffsetX, -2 + eyeOffsetY, eyeW, eyeH, 0, 0, Math.PI * 2);
    ctx.fill();

    // Pupils
    const pupilOff = 2;
    const pupilR = r * 0.18;
    ctx.fillStyle = '#2d3748';
    ctx.beginPath();
    ctx.arc(-eyeSpacing + eyeOffsetX + char.faceDirX * pupilOff,
            -2 + eyeOffsetY + char.faceDirY * pupilOff,
            pupilR, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(eyeSpacing + eyeOffsetX + char.faceDirX * pupilOff,
            -2 + eyeOffsetY + char.faceDirY * pupilOff,
            pupilR, 0, Math.PI * 2);
    ctx.fill();

    // Eye shine dots
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(-eyeSpacing + eyeOffsetX + char.faceDirX * pupilOff - 1.5,
            -3 + eyeOffsetY + char.faceDirY * pupilOff, 1.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(eyeSpacing + eyeOffsetX + char.faceDirX * pupilOff - 1.5,
            -3 + eyeOffsetY + char.faceDirY * pupilOff, 1.5, 0, Math.PI * 2);
    ctx.fill();

    // Expression mouth
    const mouthY = r * 0.4;
    ctx.strokeStyle = '#2d3748';
    ctx.lineWidth = 1.8;
    ctx.lineCap = 'round';

    if (char.expression === 'it') {
        // Gritted teeth
        ctx.beginPath();
        ctx.moveTo(-6, mouthY);
        ctx.lineTo(6, mouthY);
        ctx.stroke();
        // Teeth
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 1;
        for (let i = -4; i <= 4; i += 4) {
            ctx.beginPath();
            ctx.moveTo(i, mouthY - 1.5);
            ctx.lineTo(i, mouthY + 1.5);
            ctx.stroke();
        }
        // Angry eyebrows
        ctx.strokeStyle = '#2d3748';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(-eyeSpacing - 4 + eyeOffsetX, -7 + eyeOffsetY);
        ctx.lineTo(-eyeSpacing + 4 + eyeOffsetX, -10 + eyeOffsetY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(eyeSpacing + 4 + eyeOffsetX, -7 + eyeOffsetY);
        ctx.lineTo(eyeSpacing - 4 + eyeOffsetX, -10 + eyeOffsetY);
        ctx.stroke();
    } else if (char.expression === 'scared') {
        // Wide O mouth
        ctx.fillStyle = '#2d3748';
        ctx.beginPath();
        ctx.ellipse(0, mouthY, 4, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#400';
        ctx.beginPath();
        ctx.ellipse(0, mouthY, 2.5, 3.5, 0, 0, Math.PI * 2);
        ctx.fill();
        // Worry brows
        ctx.strokeStyle = '#2d3748';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-eyeSpacing - 3 + eyeOffsetX, -9 + eyeOffsetY);
        ctx.lineTo(-eyeSpacing + 3 + eyeOffsetX, -7 + eyeOffsetY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(eyeSpacing + 3 + eyeOffsetX, -9 + eyeOffsetY);
        ctx.lineTo(eyeSpacing - 3 + eyeOffsetX, -7 + eyeOffsetY);
        ctx.stroke();
    } else if (char.expression === 'happy') {
        // Wide smile with blush
        ctx.strokeStyle = '#2d3748';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, mouthY - 3, 6, 0.15 * Math.PI, 0.85 * Math.PI);
        ctx.stroke();
        // Blush circles
        ctx.fillStyle = 'rgba(255,100,100,0.2)';
        ctx.beginPath();
        ctx.arc(-r * 0.5, mouthY - 4, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(r * 0.5, mouthY - 4, 4, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Neutral slight smile
        ctx.beginPath();
        ctx.moveTo(-4, mouthY);
        ctx.quadraticCurveTo(0, mouthY + 3, 4, mouthY);
        ctx.stroke();
    }

    ctx.restore(); // undo squish transform

    // Hunter special visuals ‚Äî crosshair ring + danger aura
    if (char.isHunter && !isPlayer) {
        const isStunned = hunterStunTimer > 0;

        // Stun flash ‚Äî blink the hunter's opacity
        if (isStunned) {
            ctx.globalAlpha = 0.3 + Math.abs(Math.sin(gameTime * 8)) * 0.4;
            // Dizzy stars around the hunter
            ctx.save();
            ctx.translate(x, y + bounceY);
            for (let i = 0; i < 3; i++) {
                const starAngle = gameTime * 3 + i * Math.PI * 2 / 3;
                const starR = r + 14;
                const sx = Math.cos(starAngle) * starR;
                const sy = Math.sin(starAngle) * starR - 6;
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#ffd700';
                ctx.globalAlpha = 0.7;
                ctx.fillText('‚òÖ', sx, sy);
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        if (!isStunned) {
            // Rotating crosshair around the hunter (only when active)
            ctx.save();
            ctx.translate(x, y + bounceY);
            ctx.rotate(gameTime * 1.5);
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.6 + Math.sin(gameTime * 4) * 0.2;
            // Crosshair lines
            const chR = r + 8;
            ctx.beginPath(); ctx.moveTo(0, -chR); ctx.lineTo(0, -chR + 6); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0, chR); ctx.lineTo(0, chR - 6); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(-chR, 0); ctx.lineTo(-chR + 6, 0); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(chR, 0); ctx.lineTo(chR - 6, 0); ctx.stroke();
            // Rotating circle segments
            for (let i = 0; i < 4; i++) {
                const a = i * Math.PI / 2;
                ctx.beginPath();
                ctx.arc(0, 0, chR, a + 0.2, a + Math.PI / 2 - 0.2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        // Label ‚Äî shows STUNNED or HUNTER
        const hunterLabelY = y + bounceY - r - 18;
        ctx.fillStyle = isStunned ? 'rgba(255,180,0,0.9)' : 'rgba(220,38,38,0.9)';
        ctx.font = 'bold 9px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const hlLabel = isStunned ? 'STUNNED' : 'HUNTER';
        const hlW = isStunned ? 52 : 46, hlH = 13;
        ctx.beginPath();
        drawRoundRect(x - hlW/2, hunterLabelY - hlH/2, hlW, hlH, 4);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.fillText(hlLabel, x, hunterLabelY);
        ctx.globalAlpha = 1;
    }

    // --- Tag mode visual overlays ---
    const charIdx = isPlayer ? -1 : aiChars.indexOf(char);

    // Banana tag: frozen banana visual
    if (tagMode === 'banana' && ((isPlayer && playerFrozen) || (!isPlayer && frozenPlayers.has(charIdx)))) {
        // Yellow tint overlay
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        // Banana emoji above
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('üçå', x, y + bounceY - r - 4);
    }

    // Freeze tag: frozen ice visual
    if (tagMode === 'freeze' && ((isPlayer && playerFrozen) || (!isPlayer && frozenPlayers.has(charIdx)))) {
        // Ice crystal overlay
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = '#88ddff';
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 3, 0, Math.PI * 2);
        ctx.fill();
        // Ice crystal ring
        ctx.strokeStyle = '#44bbff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.6;
        for (let i = 0; i < 6; i++) {
            const a = gameTime * 0.5 + i * Math.PI / 3;
            const cr = r + 5;
            ctx.beginPath();
            ctx.moveTo(x + Math.cos(a) * cr, y + bounceY + Math.sin(a) * cr);
            ctx.lineTo(x + Math.cos(a) * (cr + 4), y + bounceY + Math.sin(a) * (cr + 4));
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        // Snowflake emoji above
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('‚ùÑÔ∏è', x, y + bounceY - r - 4);
    }

    // Freeze tag: team color ring
    if (tagMode === 'freeze' && !char.isHunter) {
        const teamColor = isPlayer ? '#4d96ff' : (char.team === 'red' ? '#ff4444' : '#4d96ff');
        ctx.strokeStyle = teamColor;
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
    }

    // Zombie tag: zombie visual
    if (tagMode === 'zombie' && ((isPlayer && playerIsZombie) || (!isPlayer && zombies.has(charIdx)))) {
        // Green tint overlay
        ctx.globalAlpha = 0.35;
        ctx.fillStyle = '#22c55e';
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        // Wobble animation (slight rotation)
        // Zombie emoji above
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('üßü', x, y + bounceY - r - 4);
    }

    // IT label ‚Äî badge style
    if (isIT) {
        const labelY = y + bounceY - r - 12;
        ctx.fillStyle = 'rgba(255,0,0,0.85)';
        const tw = 22, th = 14;
        ctx.beginPath();
        ctx.moveTo(x - tw/2 + 4, labelY - th/2);
        ctx.lineTo(x + tw/2 - 4, labelY - th/2);
        ctx.quadraticCurveTo(x + tw/2, labelY - th/2, x + tw/2, labelY - th/2 + 4);
        ctx.lineTo(x + tw/2, labelY + th/2 - 4);
        ctx.quadraticCurveTo(x + tw/2, labelY + th/2, x + tw/2 - 4, labelY + th/2);
        ctx.lineTo(x - tw/2 + 4, labelY + th/2);
        ctx.quadraticCurveTo(x - tw/2, labelY + th/2, x - tw/2, labelY + th/2 - 4);
        ctx.lineTo(x - tw/2, labelY - th/2 + 4);
        ctx.quadraticCurveTo(x - tw/2, labelY - th/2, x - tw/2 + 4, labelY - th/2);
        ctx.closePath();
        ctx.fill();
        ctx.font = 'bold 10px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('IT!', x, labelY);
    }

    // Name label ‚Äî with background pill
    const nameY = y + r + 15;
    const name = isPlayer ? 'YOU' : char.name;
    ctx.font = isPlayer ? 'bold 10px Arial' : '9px Arial';
    const nameWidth = ctx.measureText(name).width;
    ctx.fillStyle = isPlayer ? 'rgba(77,150,255,0.5)' : 'rgba(0,0,0,0.4)';
    const pillW = nameWidth + 10, pillH = 14;
    ctx.beginPath();
    ctx.moveTo(x - pillW/2 + 4, nameY - pillH/2);
    ctx.lineTo(x + pillW/2 - 4, nameY - pillH/2);
    ctx.quadraticCurveTo(x + pillW/2, nameY - pillH/2, x + pillW/2, nameY);
    ctx.quadraticCurveTo(x + pillW/2, nameY + pillH/2, x + pillW/2 - 4, nameY + pillH/2);
    ctx.lineTo(x - pillW/2 + 4, nameY + pillH/2);
    ctx.quadraticCurveTo(x - pillW/2, nameY + pillH/2, x - pillW/2, nameY);
    ctx.quadraticCurveTo(x - pillW/2, nameY - pillH/2, x - pillW/2 + 4, nameY - pillH/2);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(name, x, nameY);

    // Immunity flash
    if (immunityTimer > 0 && isIT) {
        ctx.globalAlpha = 0.25 + Math.sin(immunityTimer * 15) * 0.25;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
    }

    // Invincible golden shield (player only)
    if (isPlayer && playerInvincible > 0) {
        const shieldPulse = 0.5 + Math.sin(gameTime * 6) * 0.2;
        // Golden aura
        const shieldGrad = ctx.createRadialGradient(x, y + bounceY, r, x, y + bounceY, r + 12);
        shieldGrad.addColorStop(0, 'rgba(255,215,0,0.3)');
        shieldGrad.addColorStop(1, 'rgba(255,215,0,0)');
        ctx.fillStyle = shieldGrad;
        ctx.beginPath();
        ctx.arc(x, y + bounceY, r + 12, 0, Math.PI * 2);
        ctx.fill();
        // Spinning golden ring
        ctx.save();
        ctx.translate(x, y + bounceY);
        ctx.rotate(gameTime * 3);
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2.5;
        ctx.globalAlpha = shieldPulse;
        for (let i = 0; i < 3; i++) {
            const a = i * Math.PI * 2 / 3;
            ctx.beginPath();
            ctx.arc(0, 0, r + 6, a, a + Math.PI * 0.5);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }

    // Shrink sparkles (player only)
    if (isPlayer && playerShrink > 0) {
        ctx.fillStyle = '#34d399';
        for (let i = 0; i < 4; i++) {
            const sa = gameTime * 4 + i * Math.PI / 2;
            const sr = r + 6;
            ctx.globalAlpha = 0.5 + Math.sin(gameTime * 5 + i) * 0.3;
            ctx.beginPath();
            ctx.arc(x + Math.cos(sa) * sr, y + bounceY + Math.sin(sa) * sr, 1.5, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // Speed surge flames (player only)
    if (isPlayer && playerSpeedSurge > 0) {
        for (let i = 0; i < 5; i++) {
            const fa = Math.random() * Math.PI * 2;
            const fr = r + Math.random() * 4;
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = i % 2 === 0 ? '#facc15' : '#f97316';
            ctx.beginPath();
            ctx.arc(x + Math.cos(fa) * fr, y + bounceY + Math.sin(fa) * fr, 2 + Math.random() * 2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    ctx.restore();
}

function drawDashTrails() {
    for (const t of dashTrails) {
        const alpha = t.life / t.maxLife;
        // Large outer glow
        ctx.globalAlpha = alpha * 0.3;
        const outerGrad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, t.radius * 2 * alpha);
        outerGrad.addColorStop(0, t.color + '80');
        outerGrad.addColorStop(1, t.color + '00');
        ctx.fillStyle = outerGrad;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius * 2 * alpha, 0, Math.PI * 2);
        ctx.fill();
        // Inner bright trail
        ctx.globalAlpha = alpha * 0.7;
        const grad = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, t.radius * alpha);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.3, t.color);
        grad.addColorStop(1, t.color + '00');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(t.x, t.y, t.radius * alpha, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function drawParticles() {
    for (const p of particles) {
        const alpha = p.life / p.maxLife;
        const sz = p.radius * (0.5 + alpha * 0.5);
        // Outer glow for larger particles
        if (p.radius > 2) {
            ctx.globalAlpha = alpha * 0.2;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, sz * 2, 0, Math.PI * 2);
            ctx.fill();
        }
        // Core
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, sz, 0, Math.PI * 2);
        ctx.fill();
        // White-hot center for large particles
        if (p.radius > 4) {
            ctx.globalAlpha = alpha * 0.6;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(p.x, p.y, sz * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1;
}

function drawConfetti() {
    for (const c of confetti) {
        ctx.save();
        ctx.translate(c.x, c.y);
        ctx.rotate(c.rotation);
        const alpha = Math.min(1, c.life);
        ctx.globalAlpha = alpha;
        // Drop shadow
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(-c.w / 2 + 1, -c.h / 2 + 1, c.w, c.h);
        // Main piece
        ctx.fillStyle = c.color;
        ctx.fillRect(-c.w / 2, -c.h / 2, c.w, c.h);
        // Shine highlight
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fillRect(-c.w / 2, -c.h / 2, c.w * 0.4, c.h * 0.4);
        // Edge accent
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(-c.w / 2, -c.h / 2, c.w, c.h);
        ctx.restore();
    }
    ctx.globalAlpha = 1;
}

// --- New visual effect drawing functions ---

function drawAmbientParticles() {
    for (const a of ambientParticles) {
        const alpha = (a.life / a.maxLife) * 0.5;
        const glow = 1 + Math.sin(a.pulse * 2) * 0.4;
        ctx.globalAlpha = alpha * glow;
        const grad = ctx.createRadialGradient(a.x, a.y, 0, a.x, a.y, a.size * 3);
        grad.addColorStop(0, `hsla(${a.hue}, 80%, 75%, 0.8)`);
        grad.addColorStop(1, `hsla(${a.hue}, 80%, 75%, 0)`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(a.x, a.y, a.size * 3, 0, Math.PI * 2);
        ctx.fill();
        // Bright core
        ctx.fillStyle = `hsla(${a.hue}, 100%, 90%, 1)`;
        ctx.beginPath();
        ctx.arc(a.x, a.y, a.size * 0.5, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function drawShockwaves() {
    for (const s of shockwaves) {
        const alpha = s.life / s.maxLife;
        ctx.globalAlpha = alpha * 0.7;
        ctx.strokeStyle = s.color;
        ctx.lineWidth = s.lineWidth;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.stroke();
        // Inner fading fill
        ctx.globalAlpha = alpha * 0.08;
        ctx.fillStyle = s.color;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function drawFootsteps() {
    for (const f of footsteps) {
        const alpha = f.life / f.maxLife;
        ctx.globalAlpha = alpha * 0.35;
        ctx.fillStyle = f.color;
        ctx.beginPath();
        ctx.arc(f.x, f.y, f.radius * (1 + (1 - alpha) * 0.5), 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function drawEmotionParticles() {
    for (const e of emotionParticles) {
        const alpha = e.life / e.maxLife;
        ctx.globalAlpha = alpha;

        if (e.type === 'sweat') {
            // Teardrop shape
            ctx.fillStyle = '#6bc5ff';
            ctx.beginPath();
            ctx.moveTo(e.x, e.y - e.size);
            ctx.quadraticCurveTo(e.x + e.size, e.y, e.x, e.y + e.size * 0.8);
            ctx.quadraticCurveTo(e.x - e.size, e.y, e.x, e.y - e.size);
            ctx.fill();
            // Shine
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.beginPath();
            ctx.arc(e.x - 0.5, e.y - e.size * 0.3, e.size * 0.25, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'steam') {
            // Cloud puff
            ctx.fillStyle = `rgba(255,100,50,${alpha * 0.35})`;
            ctx.beginPath();
            ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = `rgba(255,180,100,${alpha * 0.2})`;
            ctx.beginPath();
            ctx.arc(e.x + e.size * 0.3, e.y - e.size * 0.2, e.size * 0.7, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'star') {
            // 4-point star
            ctx.save();
            ctx.translate(e.x, e.y);
            ctx.rotate(e.rotation || 0);
            ctx.fillStyle = '#ffd700';
            const s = e.size * alpha;
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                const a = i * Math.PI / 4;
                const r = i % 2 === 0 ? s : s * 0.4;
                if (i === 0) ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
                else ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
            }
            ctx.closePath();
            ctx.fill();
            // Glow
            ctx.fillStyle = `rgba(255,215,0,${alpha * 0.3})`;
            ctx.beginPath();
            ctx.arc(0, 0, s * 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }
    ctx.globalAlpha = 1;
}

function drawSpeedLines() {
    for (const l of speedLines) {
        const alpha = l.life / l.maxLife;
        ctx.globalAlpha = alpha * 0.6;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = l.width;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(l.x, l.y);
        ctx.lineTo(l.x + Math.cos(l.angle) * l.length, l.y + Math.sin(l.angle) * l.length);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

function drawArenaBorder() {
    // Pulsing neon border around the arena
    const pulse = 0.4 + Math.sin(gameTime * 2) * 0.15;
    const borderColor = itIndex === -1
        ? `rgba(255,80,80,${pulse})` // red when player is IT
        : `rgba(100,200,255,${pulse * 0.6})`; // blue otherwise

    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 3;
    ctx.strokeRect(2, 2, ARENA_W - 4, ARENA_H - 4);

    // Corner accent lights
    const cornerGlow = 0.15 + Math.sin(gameTime * 3) * 0.1;
    const cornerR = 60;
    const corners = [[0, 0], [ARENA_W, 0], [0, ARENA_H], [ARENA_W, ARENA_H]];
    const cornerColors = ['#ff6b6b', '#ffd93d', '#6bcb77', '#4d96ff'];
    for (let i = 0; i < 4; i++) {
        const [cx, cy] = corners[i];
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, cornerR);
        grad.addColorStop(0, cornerColors[i] + '40');
        grad.addColorStop(1, cornerColors[i] + '00');
        ctx.fillStyle = grad;
        ctx.globalAlpha = cornerGlow;
        ctx.beginPath();
        ctx.arc(cx, cy, cornerR, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function drawPortalLightBeams() {
    for (const p of PORTALS) {
        const drawBeam = (x, y, color) => {
            const beamH = 40 + Math.sin(gameTime * 3) * 10;
            ctx.globalAlpha = 0.06 + Math.sin(gameTime * 2) * 0.02;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.moveTo(x - 3, y);
            ctx.lineTo(x - 15, y - beamH);
            ctx.lineTo(x + 15, y - beamH);
            ctx.lineTo(x + 3, y);
            ctx.closePath();
            ctx.fill();
            // Downward beam too
            ctx.beginPath();
            ctx.moveTo(x - 3, y);
            ctx.lineTo(x - 12, y + beamH * 0.7);
            ctx.lineTo(x + 12, y + beamH * 0.7);
            ctx.lineTo(x + 3, y);
            ctx.closePath();
            ctx.fill();
        };
        drawBeam(p.ax, p.ay, p.color1);
        drawBeam(p.bx, p.by, p.color2);
    }
    ctx.globalAlpha = 1;
}

// HUD helper: draw rounded rect
function drawRoundRect(x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

function drawHUD() {
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    const pad = 14;

    // === TOP CENTER: Timer panel ===
    const timerW = 120, timerH = 52;
    const timerX = canvas.width / 2 - timerW / 2, timerY = 8;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    drawRoundRect(timerX, timerY, timerW, timerH, 12);
    ctx.fill();
    ctx.strokeStyle = roundTimer < 10 ? 'rgba(255,107,107,0.5)' : 'rgba(0,0,0,0.1)';
    ctx.lineWidth = 1;
    drawRoundRect(timerX, timerY, timerW, timerH, 12);
    ctx.stroke();

    ctx.font = 'bold 26px Arial';
    ctx.fillStyle = roundTimer < 10 ? '#ff6b6b' : '#2d3748';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(Math.ceil(roundTimer) + 's', canvas.width / 2, timerY + 22);
    ctx.font = '11px Arial';
    ctx.fillStyle = '#666';
    ctx.fillText(`Round ${currentRound + 1} / ${TOTAL_ROUNDS}`, canvas.width / 2, timerY + 42);

    // === TOP LEFT: Score panel ===
    const scoreW = 160, scoreH = 50;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    drawRoundRect(pad, 8, scoreW, scoreH, 10);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1;
    drawRoundRect(pad, 8, scoreW, scoreH, 10);
    ctx.stroke();

    ctx.textAlign = 'left';
    ctx.font = 'bold 17px Arial';
    ctx.fillStyle = '#6bcb77';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${player.survivalTime.toFixed(1)}s`, pad + 10, 28);

    ctx.font = '11px Arial';
    if (tagMode === 'banana') {
        if (playerFrozen) {
            ctx.fillStyle = '#ffd700';
            ctx.fillText('You are a banana! üçå', pad + 10, 46);
        } else {
            ctx.fillStyle = '#8bd89a';
            ctx.fillText('Tag others!', pad + 10, 46);
        }
    } else if (tagMode === 'freeze') {
        if (playerFrozen) {
            ctx.fillStyle = '#22d3ee';
            ctx.fillText('You are frozen! ‚ùÑÔ∏è', pad + 10, 46);
        } else if (player.team === 'red') {
            ctx.fillStyle = '#ff4444';
            ctx.fillText('Red Team (Tagger)', pad + 10, 46);
        } else {
            ctx.fillStyle = '#4d96ff';
            ctx.fillText('Blue Team (Runner)', pad + 10, 46);
        }
    } else if (tagMode === 'zombie') {
        if (playerIsZombie) {
            ctx.fillStyle = '#22c55e';
            ctx.fillText('You are a zombie! üßü', pad + 10, 46);
        } else {
            ctx.fillStyle = '#8bd89a';
            ctx.fillText('Survive!', pad + 10, 46);
        }
    } else if (tagMode === 'ball') {
        const maxBalls = settings.ballCount || 1;
        if (itIndex === -1) {
            ctx.fillStyle = '#ff6b6b';
            if (balls.length > 0) ctx.fillText(`Balls: ${balls.length}/${maxBalls}`, pad + 10, 46);
            else if (ballCooldown > 0) ctx.fillText(`Ball ${ballCooldown.toFixed(1)}s`, pad + 10, 46);
            else ctx.fillText('Click to throw!', pad + 10, 46);
        } else {
            ctx.fillStyle = '#8bd89a';
            ctx.fillText(`${aiChars[itIndex].name} has ball`, pad + 10, 46);
        }
    } else {
        if (itIndex === -1) {
            ctx.fillStyle = '#ff6b6b';
            ctx.fillText("You're IT!", pad + 10, 46);
        } else {
            ctx.fillStyle = '#8bd89a';
            ctx.fillText(`${aiChars[itIndex].name} is IT`, pad + 10, 46);
        }
    }

    // === TOP RIGHT: Dash panel ===
    const dashW = 130, dashH = 44;
    const dashX = canvas.width - pad - dashW;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    drawRoundRect(dashX, 8, dashW, dashH, 10);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.08)';
    ctx.lineWidth = 1;
    drawRoundRect(dashX, 8, dashW, dashH, 10);
    ctx.stroke();

    ctx.textAlign = 'right';
    if (player.dashCooldown > 0) {
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = '#888';
        ctx.textBaseline = 'middle';
        ctx.fillText(`Dash ${player.dashCooldown.toFixed(1)}s`, canvas.width - pad - 10, 24);

        // Cooldown bar
        const barW = dashW - 20, barH = 5, barRad = 3;
        const barX2 = dashX + 10, barY2 = 38;
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        drawRoundRect(barX2, barY2, barW, barH, barRad);
        ctx.fill();
        const fillW = barW * (1 - player.dashCooldown / DASH_COOLDOWN);
        if (fillW > 0) {
            ctx.fillStyle = '#4d96ff';
            drawRoundRect(barX2, barY2, fillW, barH, barRad);
            ctx.fill();
        }
    } else {
        ctx.font = 'bold 14px Arial';
        ctx.fillStyle = '#6bcb77';
        ctx.textBaseline = 'middle';
        ctx.fillText('Dash Ready!', canvas.width - pad - 10, 30);
    }

    // === Active effects (below score) ===
    let effectY = 68;
    ctx.textAlign = 'left';
    ctx.font = 'bold 11px Arial';
    ctx.textBaseline = 'top';
    if (player.speedBoostTimer > 0) {
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        drawRoundRect(pad, effectY - 2, 150, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#ffd700';
        ctx.fillText(`SPEED BOOST ${player.speedBoostTimer.toFixed(1)}s`, pad + 6, effectY);
        effectY += 20;
    }
    if (player.onLava) {
        ctx.fillStyle = 'rgba(180,0,0,0.5)';
        drawRoundRect(pad, effectY - 2, 130, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#ff6b6b';
        ctx.fillText(itIndex === -1 ? 'ON LAVA - SLOWED!' : 'LAVA - GET OUT!', pad + 6, effectY);
        effectY += 20;
    }
    if (player.onIce) {
        ctx.fillStyle = 'rgba(0,40,120,0.5)';
        drawRoundRect(pad, effectY - 2, 130, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#93c5fd';
        ctx.fillText('ON ICE - SLIPPERY!', pad + 6, effectY);
        effectY += 20;
    }
    if (idleTimer > 1 && itIndex !== -1) {
        const remaining = Math.max(0, IDLE_TIMEOUT - idleTimer).toFixed(1);
        const urgency = idleTimer / IDLE_TIMEOUT;
        ctx.fillStyle = `rgba(180,80,0,${0.4 + urgency * 0.3})`;
        drawRoundRect(pad, effectY - 2, 150, 16, 4);
        ctx.fill();
        ctx.fillStyle = urgency > 0.7 ? '#ff4444' : '#ff8c00';
        ctx.fillText(`MOVE! IT in ${remaining}s`, pad + 6, effectY);
        effectY += 20;
    }
    // Powerup effect indicators
    if (playerInvincible > 0) {
        ctx.fillStyle = 'rgba(200,170,0,0.55)';
        drawRoundRect(pad, effectY - 2, 160, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#ffd700';
        ctx.fillText(`‚òÖ INVINCIBLE ${playerInvincible.toFixed(1)}s`, pad + 6, effectY);
        effectY += 20;
    }
    if (playerSpeedSurge > 0) {
        ctx.fillStyle = 'rgba(200,170,0,0.55)';
        drawRoundRect(pad, effectY - 2, 160, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#facc15';
        ctx.fillText(`‚ö° SPEED SURGE ${playerSpeedSurge.toFixed(1)}s`, pad + 6, effectY);
        effectY += 20;
    }
    if (playerShrink > 0) {
        ctx.fillStyle = 'rgba(0,100,80,0.55)';
        drawRoundRect(pad, effectY - 2, 160, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#34d399';
        ctx.fillText(`‚óÜ SHRUNK ${playerShrink.toFixed(1)}s`, pad + 6, effectY);
        effectY += 20;
    }
    if (freezeTimer > 0) {
        ctx.fillStyle = 'rgba(0,80,120,0.55)';
        drawRoundRect(pad, effectY - 2, 160, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#22d3ee';
        ctx.fillText(`‚ùÑ BOTS FROZEN ${freezeTimer.toFixed(1)}s`, pad + 6, effectY);
        effectY += 20;
    }
    // Stored powerup indicator
    if (storedPowerup) {
        const spInfo = POWERUP_TYPES[storedPowerup];
        ctx.fillStyle = 'rgba(220,235,255,0.8)';
        drawRoundRect(pad, effectY - 2, 180, 18, 4);
        ctx.fill();
        ctx.strokeStyle = spInfo.color;
        ctx.lineWidth = 1.5;
        drawRoundRect(pad, effectY - 2, 180, 18, 4);
        ctx.stroke();
        ctx.fillStyle = spInfo.color;
        ctx.fillText(`${spInfo.icon} ${spInfo.name} ‚Äî press E`, pad + 6, effectY);
        effectY += 22;
    }

    // === Mode-specific HUD info ===
    if (tagMode === 'banana' || tagMode === 'freeze') {
        const totalCount = tagMode === 'banana'
            ? aiChars.filter(a => !a.isHunter).length + 1
            : teams.blue.length + (player.team === 'blue' ? 1 : 0);
        const frozenCount = frozenPlayers.size + (playerFrozen ? 1 : 0);
        ctx.fillStyle = 'rgba(0,100,180,0.55)';
        drawRoundRect(pad, effectY - 2, 160, 16, 4);
        ctx.fill();
        ctx.fillStyle = tagMode === 'banana' ? '#ffd700' : '#22d3ee';
        const icon = tagMode === 'banana' ? 'üçå' : '‚ùÑÔ∏è';
        ctx.fillText(`${icon} Frozen: ${frozenCount}/${totalCount}`, pad + 6, effectY);
        effectY += 20;
    }
    if (tagMode === 'zombie') {
        const totalChars = aiChars.filter(a => !a.isHunter).length + 1;
        const zombieCount = zombies.size + (playerIsZombie ? 1 : 0);
        ctx.fillStyle = 'rgba(0,100,50,0.55)';
        drawRoundRect(pad, effectY - 2, 160, 16, 4);
        ctx.fill();
        ctx.fillStyle = '#22c55e';
        ctx.fillText(`üßü Zombies: ${zombieCount}/${totalChars}`, pad + 6, effectY);
        effectY += 20;
    }
    if (tagMode === 'ball' && itIndex === -1) {
        const maxBalls = settings.ballCount || 1;
        ctx.fillStyle = 'rgba(180,50,50,0.55)';
        drawRoundRect(pad, effectY - 2, 180, 16, 4);
        ctx.fill();
        if (balls.length > 0 && balls.length < maxBalls) {
            ctx.fillStyle = '#ff6b6b';
            ctx.fillText(`Balls: ${balls.length}/${maxBalls} ‚Äî Click for more`, pad + 6, effectY);
        } else if (balls.length >= maxBalls) {
            ctx.fillStyle = '#888';
            ctx.fillText(`Balls: ${balls.length}/${maxBalls} ‚Äî All thrown`, pad + 6, effectY);
        } else if (ballCooldown > 0) {
            ctx.fillStyle = '#888';
            ctx.fillText(`Ball cooldown ${ballCooldown.toFixed(1)}s`, pad + 6, effectY);
        } else {
            ctx.fillStyle = '#6bcb77';
            ctx.fillText(maxBalls > 1 ? `${maxBalls} balls ‚Äî Click to throw` : 'Ball Ready! Click to throw', pad + 6, effectY);
        }
        effectY += 20;
    }
    // Mode label
    if (tagMode !== 'classic') {
        ctx.font = '9px Arial';
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(TAG_TYPE_DEFS[tagMode].label.toUpperCase(), canvas.width / 2, 62);
        ctx.textAlign = 'left';
        ctx.font = 'bold 11px Arial';
        ctx.textBaseline = 'top';
    }

    // === Status banner with backdrop ===
    if (statusBanner.timer > 0) {
        const alpha = Math.min(1, statusBanner.timer);
        const bannerY = canvas.height / 2 - 90;
        ctx.globalAlpha = alpha * 0.6;
        ctx.fillStyle = 'rgba(255,255,255,0.85)';
        drawRoundRect(canvas.width / 2 - 160, bannerY - 24, 320, 50, 14);
        ctx.fill();
        ctx.globalAlpha = alpha;
        ctx.font = 'bold 32px Arial';
        ctx.fillStyle = statusBanner.color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(statusBanner.text, canvas.width / 2, bannerY);
        ctx.globalAlpha = 1;
    }

    drawMiniMap();

    if (isTouchDevice && joystick.active) drawJoystick();
    else if (isTouchDevice) drawJoystickBase();

    ctx.restore();
}

function drawMiniMap() {
    const mapW = 140;
    const mapH = mapW * (ARENA_H / ARENA_W);
    const mapX = canvas.width - mapW - 12;
    const mapY = canvas.height - mapH - 12;

    // Background with rounded corners
    ctx.fillStyle = 'rgba(240,245,255,0.85)';
    drawRoundRect(mapX - 2, mapY - 2, mapW + 4, mapH + 4, 6);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 1;
    drawRoundRect(mapX - 2, mapY - 2, mapW + 4, mapH + 4, 6);
    ctx.stroke();
    // Inner fill
    ctx.fillStyle = 'rgba(245,248,255,0.9)';
    ctx.fillRect(mapX, mapY, mapW, mapH);

    const scaleX = mapW / ARENA_W;
    const scaleY = mapH / ARENA_H;

    // Walls
    ctx.fillStyle = 'rgba(150,150,150,0.5)';
    for (const w of WALLS) {
        ctx.fillRect(mapX + w.x * scaleX, mapY + w.y * scaleY,
            Math.max(1, w.w * scaleX), Math.max(1, w.h * scaleY));
    }

    // Lava pools on minimap
    for (const lp of LAVA_POOLS) {
        ctx.fillStyle = 'rgba(255,69,0,0.4)';
        ctx.beginPath();
        ctx.arc(mapX + lp.x * scaleX, mapY + lp.y * scaleY, Math.max(2, lp.radius * scaleX), 0, Math.PI * 2);
        ctx.fill();
    }

    // Ice patches on minimap
    for (const ip of ICE_PATCHES) {
        ctx.fillStyle = 'rgba(147,197,253,0.3)';
        ctx.beginPath();
        ctx.arc(mapX + ip.x * scaleX, mapY + ip.y * scaleY, Math.max(2, ip.radius * scaleX), 0, Math.PI * 2);
        ctx.fill();
    }

    // Portals on minimap
    for (const p of PORTALS) {
        ctx.fillStyle = p.color1;
        ctx.beginPath();
        ctx.arc(mapX + p.ax * scaleX, mapY + p.ay * scaleY, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = p.color2;
        ctx.beginPath();
        ctx.arc(mapX + p.bx * scaleX, mapY + p.by * scaleY, 3, 0, Math.PI * 2);
        ctx.fill();
        // Connection line
        ctx.strokeStyle = p.color1 + '60';
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(mapX + p.ax * scaleX, mapY + p.ay * scaleY);
        ctx.lineTo(mapX + p.bx * scaleX, mapY + p.by * scaleY);
        ctx.stroke();
    }

    // Camera view
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(
        mapX + camX * scaleX, mapY + camY * scaleY,
        canvas.width * scaleX, canvas.height * scaleY
    );

    // AI dots with glow for IT/mode-specific
    for (let i = 0; i < aiChars.length; i++) {
        const ai = aiChars[i];
        const dx = mapX + ai.x * scaleX, dy = mapY + ai.y * scaleY;
        let isITDot = itIndex === i;
        if (tagMode === 'zombie') isITDot = zombies.has(i);
        else if (tagMode === 'banana') isITDot = false; // Everyone is IT in banana, no special glow
        else if (tagMode === 'freeze') isITDot = teams.red.includes(i);
        let dotColor = ai.color;
        if (isITDot) dotColor = tagMode === 'zombie' ? '#22c55e' : '#ff4444';
        if (frozenPlayers.has(i)) dotColor = tagMode === 'banana' ? '#ffd700' : '#88ddff';
        if (isITDot) {
            const glowColor = tagMode === 'zombie' ? 'rgba(34,197,94,' : 'rgba(255,0,0,';
            ctx.fillStyle = glowColor + (0.3 + Math.sin(gameTime * 6) * 0.15) + ')';
            ctx.beginPath(); ctx.arc(dx, dy, 7, 0, Math.PI * 2); ctx.fill();
        }
        ctx.fillStyle = dotColor;
        ctx.beginPath();
        ctx.arc(dx, dy, isITDot ? 4 : 2.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Powerups on minimap
    for (const pu of powerups) {
        ctx.fillStyle = pu.color;
        ctx.globalAlpha = 0.6 + Math.sin(gameTime * 4) * 0.2;
        ctx.beginPath();
        ctx.arc(mapX + pu.x * scaleX, mapY + pu.y * scaleY, 3, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Player dot with glow
    const px = mapX + player.x * scaleX, py = mapY + player.y * scaleY;
    let playerIsITDot = itIndex === -1;
    if (tagMode === 'freeze') playerIsITDot = player.team === 'red';
    else if (tagMode === 'zombie') playerIsITDot = playerIsZombie;
    if (playerIsITDot) {
        const glowC = (tagMode === 'zombie') ? 'rgba(34,197,94,' : 'rgba(255,0,0,';
        ctx.fillStyle = glowC + (0.3 + Math.sin(gameTime * 6) * 0.15) + ')';
        ctx.beginPath(); ctx.arc(px, py, 8, 0, Math.PI * 2); ctx.fill();
    } else {
        ctx.fillStyle = 'rgba(100,200,255,0.3)';
        ctx.beginPath(); ctx.arc(px, py, 7, 0, Math.PI * 2); ctx.fill();
    }
    let playerDotColor = '#fff';
    if (playerIsITDot) playerDotColor = tagMode === 'zombie' ? '#22c55e' : '#ff4444';
    if (tagMode === 'freeze') playerDotColor = player.team === 'red' ? '#ff4444' : '#4d96ff';
    ctx.fillStyle = playerDotColor;
    ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI * 2); ctx.fill();
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(px, py, 4, 0, Math.PI * 2); ctx.stroke();

    // "MAP" label
    ctx.font = '8px Arial';
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    ctx.fillText('MAP', mapX + mapW - 3, mapY - 4);
}

function drawJoystickBase() {
    const rect = joystickArea.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    ctx.fillStyle = 'rgba(0,0,0,0.08)';
    ctx.beginPath();
    ctx.arc(cx, cy, 60, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.beginPath();
    ctx.arc(cx, cy, 20, 0, Math.PI * 2);
    ctx.fill();
}

function drawJoystick() {
    const rect = joystickArea.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.beginPath();
    ctx.arc(cx, cy, 60, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.beginPath();
    ctx.arc(cx + joystick.dx, cy + joystick.dy, 22, 0, Math.PI * 2);
    ctx.fill();
}

// ============================================================
// MAIN LOOP
// ============================================================

function update(dt) {
    // Tutorial state ‚Äî game is paused, just tick gameTime for animations
    if (gameState === 'tutorial') {
        gameTime += dt;
        return;
    }

    if (gameState !== 'playing') return;

    gameTime += dt;

    roundTimer -= dt;
    if (roundTimer <= 0) {
        roundTimer = 0;
        endRound();
        return;
    }

    immunityTimer = Math.max(0, immunityTimer - dt);
    hunterStunTimer = Math.max(0, hunterStunTimer - dt);
    statusBanner.timer = Math.max(0, statusBanner.timer - dt);

    // Banana immunity timers
    if (tagMode === 'banana') {
        playerBananaImmunity = Math.max(0, playerBananaImmunity - dt);
        for (const [idx, timer] of bananaImmunity) {
            const newTimer = timer - dt;
            if (newTimer <= 0) bananaImmunity.delete(idx);
            else bananaImmunity.set(idx, newTimer);
        }
    }

    updatePowerups(dt);
    updatePlayer(dt);

    // Update ball (ball tag mode)
    if (tagMode === 'ball') {
        updateBall(dt);
        ballCooldown = Math.max(0, ballCooldown - dt);
    }

    for (let i = 0; i < aiChars.length; i++) {
        if (freezeTimer > 0) {
            // Bots are frozen ‚Äî only update element timers, don't move
            aiChars[i].vx = 0;
            aiChars[i].vy = 0;
        } else {
            updateAI(aiChars[i], i, dt);
        }
    }

    checkTags();
    updateParticles(dt);
    updateCamera();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#87ceeb';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState !== 'playing' && gameState !== 'tutorial') return;

    ctx.save();

    // Screen shake offset
    let shakeX = 0, shakeY = 0;
    if (shakeTimer > 0) {
        const shakeMag = shakeIntensity * (shakeTimer / 0.3);
        shakeX = (Math.random() - 0.5) * shakeMag * 2;
        shakeY = (Math.random() - 0.5) * shakeMag * 2;
    }
    ctx.translate(-camX + shakeX, -camY + shakeY);

    // Arena layers (bottom to top)
    drawArena();
    drawArenaBorder();
    drawFootsteps();
    drawIcePatches();
    drawLavaPools();
    drawSpeedPads();
    drawPortalLightBeams();
    drawTrampolines();
    drawPortals();
    drawWalls();
    drawBumpers();
    drawPowerups();
    if (tagMode === 'ball') drawBall();
    drawAmbientParticles();
    drawDashTrails();
    drawSpeedLines();
    drawParticles();
    drawShockwaves();

    // Characters (sort by y for depth)
    const allChars = aiChars.map((c, i) => {
        let charIsIT = itIndex === i;
        if (tagMode === 'banana') charIsIT = false; // Everyone is IT in banana, show normal
        else if (tagMode === 'freeze') charIsIT = teams.red.includes(i);
        else if (tagMode === 'zombie') charIsIT = zombies.has(i);
        return { char: c, isIT: charIsIT, isPlayer: false };
    });
    let playerIsIT = itIndex === -1;
    if (tagMode === 'zombie') playerIsIT = playerIsZombie;
    else if (tagMode === 'banana') playerIsIT = false;
    else if (tagMode === 'freeze') playerIsIT = player.team === 'red';
    allChars.push({ char: player, isIT: playerIsIT, isPlayer: true });
    allChars.sort((a, b) => a.char.y - b.char.y);
    for (const { char, isIT, isPlayer } of allChars) {
        drawCharacter(char, isIT, isPlayer);
    }

    drawEmotionParticles();

    ctx.restore();

    drawConfetti();
    drawHUD();
}

function gameLoop(timestamp) {
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    update(dt);
    draw();

    requestAnimationFrame(gameLoop);
}

// --- Round/Game flow ---
// ============================================================
// SETTINGS SYSTEM
// ============================================================

const TAG_TYPE_DEFS = {
    classic: { label: 'Classic', desc: 'Tag transfers on touch' },
    ball:    { label: 'Ball Tag', desc: 'Throw ball to tag' },
    banana:  { label: 'Banana', desc: 'Tagged = frozen banana' },
    freeze:  { label: 'Freeze Tag', desc: 'Blue vs Red teams' },
    zombie:  { label: 'Zombie', desc: 'Zombies spread!' },
};

const ARENA_SIZE_DEFS = {
    tiny:    { label: 'Tiny',    desc: 'Screen size',   areaMult: 1 },
    small:   { label: 'Small',   desc: '1.5√ó Tiny',     areaMult: 1.5 },
    medium:  { label: 'Medium',  desc: '2√ó Tiny ‚ñ°',     areaMult: 2, square: true },
    large:   { label: 'Large',   desc: '3√ó Small',      areaMult: 4.5 },
    huge:    { label: 'Huge',    desc: '2√ó Medium ‚ñ°',   areaMult: 4, square: true },
    giant:   { label: 'Giant',   desc: '4√ó Medium ‚ñ°',   areaMult: 8, square: true },
    massive: { label: 'Massive', desc: '12√ó Tiny',      areaMult: 12 },
};

const ELEMENT_DEFS = {
    portals:     { label: 'Portals',     color: '#a855f7' },
    trampolines: { label: 'Trampolines', color: '#22d3ee' },
    lava:        { label: 'Lava Pools',  color: '#ef4444' },
    speed:       { label: 'Speed Pads',  color: '#facc15' },
    ice:         { label: 'Ice Patches', color: '#93c5fd' },
    bumpers:     { label: 'Bumpers',     color: '#f97316' },
};

// Settings state (defaults)
let settings = {
    tagType: 'classic',
    ballCount: 1,
    freezeTeam: 'blue',
    arenaSize: 'medium',
    powerups: { invincible: true, shield: true, speed: true, freeze: true, swap: true, shrink: true },
    elements: { portals: true, trampolines: true, lava: true, speed: true, ice: true, bumpers: true },
};

// Load saved settings
try {
    const saved = JSON.parse(localStorage.getItem('tag-game-settings'));
    if (saved) {
        if (saved.tagType) settings.tagType = saved.tagType;
        if (saved.ballCount !== undefined) settings.ballCount = saved.ballCount;
        if (saved.freezeTeam) settings.freezeTeam = saved.freezeTeam;
        if (saved.arenaSize) settings.arenaSize = saved.arenaSize;
        if (saved.powerups) Object.assign(settings.powerups, saved.powerups);
        if (saved.elements) Object.assign(settings.elements, saved.elements);
    }
} catch(e) {}

function saveSettings() {
    localStorage.setItem('tag-game-settings', JSON.stringify(settings));
}

function getArenaDimensions() {
    const baseW = window.innerWidth;
    const baseH = window.innerHeight;
    const def = ARENA_SIZE_DEFS[settings.arenaSize];
    if (def.square) {
        const side = Math.round(Math.sqrt(def.areaMult * baseW * baseH));
        return { w: side, h: side };
    }
    const scale = Math.sqrt(def.areaMult);
    return { w: Math.round(baseW * scale), h: Math.round(baseH * scale) };
}

function getTiniesCount() {
    return Math.max(1, Math.round(ARENA_SIZE_DEFS[settings.arenaSize].areaMult));
}

function generateArena() {
    const dims = getArenaDimensions();
    ARENA_W = dims.w;
    ARENA_H = dims.h;
    const n = getTiniesCount(); // element/bot multiplier

    // Border walls always
    WALLS = [
        { x: 0, y: 0, w: ARENA_W, h: 20 },
        { x: 0, y: ARENA_H - 20, w: ARENA_W, h: 20 },
        { x: 0, y: 0, w: 20, h: ARENA_H },
        { x: ARENA_W - 20, y: 0, w: 20, h: ARENA_H },
    ];
    // Interior walls: ~3-4 per tiny
    const numWalls = Math.max(2, n * 3);
    for (let i = 0; i < numWalls; i++) {
        const isHoriz = Math.random() < 0.5;
        const x = randRange(80, ARENA_W - 250);
        const y = randRange(80, ARENA_H - 250);
        const w = isHoriz ? randRange(120, 250) : 30;
        const h = isHoriz ? 30 : randRange(120, 250);
        // Check doesn't overlap center too much
        const cx = x + w/2, cy = y + h/2;
        if (Math.abs(cx - ARENA_W/2) < 100 && Math.abs(cy - ARENA_H/2) < 100) continue;
        WALLS.push({ x, y, w, h });
    }

    // Generate elements based on settings and count
    const portalColors = [
        ['#a855f7', '#7c3aed'], ['#ec4899', '#db2777'], ['#06b6d4', '#0891b2'],
        ['#f59e0b', '#d97706'], ['#10b981', '#059669'], ['#8b5cf6', '#6d28d9'],
    ];
    PORTALS = [];
    if (settings.elements.portals) {
        const numPortals = Math.max(1, Math.round(n * 0.8));
        for (let i = 0; i < numPortals && i < portalColors.length; i++) {
            PORTALS.push({
                ax: randRange(100, ARENA_W / 2 - 50),
                ay: randRange(100, ARENA_H - 100),
                bx: randRange(ARENA_W / 2 + 50, ARENA_W - 100),
                by: randRange(100, ARENA_H - 100),
                radius: 30,
                color1: portalColors[i][0],
                color2: portalColors[i][1],
            });
        }
    }

    TRAMPOLINES = [];
    if (settings.elements.trampolines) {
        const num = Math.max(1, n);
        for (let i = 0; i < num; i++) {
            TRAMPOLINES.push({
                x: randRange(80, ARENA_W - 130),
                y: randRange(80, ARENA_H - 130),
                w: 50, h: 50,
            });
        }
    }

    LAVA_POOLS = [];
    if (settings.elements.lava) {
        const num = Math.max(1, Math.round(n * 0.8));
        for (let i = 0; i < num; i++) {
            LAVA_POOLS.push({
                x: randRange(120, ARENA_W - 120),
                y: randRange(120, ARENA_H - 120),
                radius: randRange(40, 60),
            });
        }
    }

    SPEED_PADS = [];
    if (settings.elements.speed) {
        const num = Math.max(1, n);
        for (let i = 0; i < num; i++) {
            SPEED_PADS.push({
                x: randRange(80, ARENA_W - 140),
                y: randRange(80, ARENA_H - 100),
                w: 60, h: 25,
                angle: Math.random() * Math.PI * 2,
            });
        }
    }

    ICE_PATCHES = [];
    if (settings.elements.ice) {
        const num = Math.max(1, Math.round(n * 0.6));
        for (let i = 0; i < num; i++) {
            ICE_PATCHES.push({
                x: randRange(120, ARENA_W - 120),
                y: randRange(120, ARENA_H - 120),
                radius: randRange(45, 65),
            });
        }
    }

    BUMPERS = [];
    if (settings.elements.bumpers) {
        const num = Math.max(1, n);
        for (let i = 0; i < num; i++) {
            BUMPERS.push({
                x: randRange(80, ARENA_W - 80),
                y: randRange(80, ARENA_H - 80),
                radius: 22,
            });
        }
    }

    // Update powerup keys based on settings
    POWERUP_KEYS = Object.keys(POWERUP_TYPES).filter(k => settings.powerups[k]);

    // Reset floor pattern for new arena size
    floorPattern = null;
}

function getNumBots() {
    // Number of bots = total elements on the arena
    const total = PORTALS.length + TRAMPOLINES.length + LAVA_POOLS.length +
                  SPEED_PADS.length + ICE_PATCHES.length + BUMPERS.length;
    return Math.max(3, total); // minimum 3 bots
}

// --- Settings UI ---
function buildSettingsUI() {
    // Tag type grid
    const tagGrid = document.getElementById('tagTypeGrid');
    tagGrid.innerHTML = '';
    for (const [key, def] of Object.entries(TAG_TYPE_DEFS)) {
        const btn = document.createElement('div');
        btn.className = 'size-btn' + (settings.tagType === key ? ' selected' : '');
        btn.dataset.tagtype = key;
        btn.innerHTML = `${def.label}<small>${def.desc}</small>`;
        btn.addEventListener('click', () => {
            settings.tagType = key;
            tagGrid.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            updateBallCountVisibility();
            updateFreezeTeamVisibility();
        });
        tagGrid.appendChild(btn);
    }

    // Ball count controls
    updateBallCountVisibility();
    updateBallCountDisplay();
    document.getElementById('ballCountDown').onclick = () => {
        settings.ballCount = Math.max(0, (settings.ballCount || 1) - 1);
        updateBallCountDisplay();
    };
    document.getElementById('ballCountUp').onclick = () => {
        settings.ballCount = Math.min(10, (settings.ballCount || 1) + 1);
        updateBallCountDisplay();
    };

    // Freeze team chooser
    updateFreezeTeamVisibility();
    updateFreezeTeamButtons();
    document.getElementById('teamBlueBtn').onclick = () => {
        settings.freezeTeam = 'blue';
        updateFreezeTeamButtons();
    };
    document.getElementById('teamRedBtn').onclick = () => {
        settings.freezeTeam = 'red';
        updateFreezeTeamButtons();
    };

    // Size grid
    const sizeGrid = document.getElementById('sizeGrid');
    sizeGrid.innerHTML = '';
    for (const [key, def] of Object.entries(ARENA_SIZE_DEFS)) {
        const btn = document.createElement('div');
        btn.className = 'size-btn' + (settings.arenaSize === key ? ' selected' : '');
        btn.dataset.size = key;
        btn.innerHTML = `${def.label}<small>${def.desc}</small>`;
        btn.addEventListener('click', () => {
            settings.arenaSize = key;
            sizeGrid.querySelectorAll('.size-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            updateSizeInfo();
        });
        sizeGrid.appendChild(btn);
    }
    updateSizeInfo();

    // Powerup grid
    const puGrid = document.getElementById('powerupGrid');
    puGrid.innerHTML = '';
    for (const [key, info] of Object.entries(POWERUP_TYPES)) {
        const btn = document.createElement('div');
        btn.className = 'toggle-btn' + (settings.powerups[key] ? ' on' : '');
        btn.style.setProperty('--tc', info.color);
        btn.textContent = `${info.icon} ${info.name}`;
        btn.addEventListener('click', () => {
            settings.powerups[key] = !settings.powerups[key];
            btn.classList.toggle('on');
        });
        puGrid.appendChild(btn);
    }

    // Element grid
    const elGrid = document.getElementById('elementGrid');
    elGrid.innerHTML = '';
    for (const [key, info] of Object.entries(ELEMENT_DEFS)) {
        const btn = document.createElement('div');
        btn.className = 'toggle-btn' + (settings.elements[key] ? ' on' : '');
        btn.style.setProperty('--tc', info.color);
        btn.textContent = info.label;
        btn.addEventListener('click', () => {
            settings.elements[key] = !settings.elements[key];
            btn.classList.toggle('on');
        });
        elGrid.appendChild(btn);
    }
}

function updateBallCountVisibility() {
    const section = document.getElementById('ballCountSection');
    section.style.display = settings.tagType === 'ball' ? 'block' : 'none';
}

function updateBallCountDisplay() {
    const count = settings.ballCount || 1;
    document.getElementById('ballCountDisplay').textContent = count;
    const info = document.getElementById('ballCountInfo');
    if (count === 0) info.textContent = 'No balls ‚Äî contact tag only';
    else if (count === 1) info.textContent = '1 ball at a time';
    else info.textContent = `Up to ${count} balls at once`;
}

function updateFreezeTeamVisibility() {
    const section = document.getElementById('freezeTeamSection');
    section.style.display = settings.tagType === 'freeze' ? 'block' : 'none';
}

function updateFreezeTeamButtons() {
    const blueBtn = document.getElementById('teamBlueBtn');
    const redBtn = document.getElementById('teamRedBtn');
    blueBtn.classList.toggle('selected', settings.freezeTeam === 'blue');
    redBtn.classList.toggle('selected', settings.freezeTeam === 'red');
}

function updateSizeInfo() {
    const def = ARENA_SIZE_DEFS[settings.arenaSize];
    const n = Math.max(1, Math.round(def.areaMult));
    // Count enabled element types
    const enabledTypes = Object.values(settings.elements).filter(v => v).length;
    const totalElements = enabledTypes * n;
    const bots = Math.max(3, totalElements);
    document.getElementById('sizeInfo').textContent =
        `~${totalElements} elements ¬∑ ${bots} bots + hunter ¬∑ ${def.areaMult}√ó area`;
}

function openSettings() {
    buildSettingsUI();
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('settingsScreen').classList.remove('hidden');
}

function closeSettings(save) {
    if (save) saveSettings();
    document.getElementById('settingsScreen').classList.add('hidden');
    // During tutorial, don't show start screen
    if (gameState !== 'tutorial') {
        document.getElementById('startScreen').classList.remove('hidden');
    }
}

function startGame() {
    generateArena();
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('roundEndScreen').classList.add('hidden');
    document.getElementById('gameOverScreen').classList.add('hidden');
    gameState = 'playing';
    currentRound = 0;
    roundScores = [];
    totalScore = 0;
    gameTime = 0;
    initRound();
}

function endRound() {
    gameState = 'roundEnd';
    let score = parseFloat(player.survivalTime.toFixed(1));

    // Zombie bonus: +15s if player was never tagged (last standing)
    if (tagMode === 'zombie' && !playerIsZombie) {
        zombieBonus = 15;
        score += zombieBonus;
    }

    roundScores.push(score);
    totalScore += score;

    spawnConfetti();

    // Mode-specific score description
    let scoreDesc = 'seconds not being IT';
    if (tagMode === 'banana') scoreDesc = 'seconds unfrozen';
    else if (tagMode === 'freeze') scoreDesc = player.team === 'red' ? 'seconds as tagger' : 'seconds unfrozen';
    else if (tagMode === 'zombie') scoreDesc = zombieBonus > 0 ? `seconds survived (+${zombieBonus}s bonus!)` : 'seconds before turning zombie';
    else if (tagMode === 'ball') scoreDesc = 'seconds not being IT';

    if (currentRound >= TOTAL_ROUNDS - 1) {
        showGameOver();
    } else {
        document.getElementById('roundScore').textContent = score.toFixed(1);
        document.getElementById('roundScoreDesc').textContent = scoreDesc;
        document.getElementById('roundEndTitle').textContent = `Round ${currentRound + 1} Complete!`;
        document.getElementById('roundEndInfo').textContent = `${TOTAL_ROUNDS - currentRound - 1} round${TOTAL_ROUNDS - currentRound - 1 > 1 ? 's' : ''} remaining`;
        document.getElementById('roundEndScreen').classList.remove('hidden');
    }
}

function nextRound() {
    document.getElementById('roundEndScreen').classList.add('hidden');
    currentRound++;
    gameState = 'playing';
    initRound();
}

function showGameOver() {
    gameState = 'gameOver';

    if (totalScore > highScore) {
        highScore = totalScore;
        localStorage.setItem('tag-game-highscore', Math.floor(highScore));
    }

    document.getElementById('finalScore').textContent = totalScore.toFixed(1);

    const breakdown = document.getElementById('roundBreakdown');
    breakdown.innerHTML = '';
    roundScores.forEach((s, i) => {
        const row = document.createElement('div');
        row.className = 'score-row';
        row.innerHTML = `<span>Round ${i + 1}</span><span>${s}s</span>`;
        breakdown.appendChild(row);
    });

    document.getElementById('endHighScore').textContent = `Best: ${highScore.toFixed(1)}s`;
    document.getElementById('gameOverScreen').classList.remove('hidden');

    spawnConfetti();
}

function restartGame() {
    document.getElementById('gameOverScreen').classList.add('hidden');
    startGame();
}

// ============================================================
// TUTORIAL SYSTEM
// ============================================================

let tutorialStep = -1;
let tutorialActive = false;
let tutorialPaused = false;
let tutorialArrowTarget = null;
let tutorialSavedSettings = null;

const TUTORIAL_STEPS = [
    // Phase: Intro
    {
        phase: 'intro', id: 'welcome', title: 'Welcome!', icon: 'üëã',
        text: 'This tutorial will teach you everything about Tag!',
        hint: '', manualNext: true, pauseGame: true,
    },
    // Phase: Controls
    {
        phase: 'controls', id: 'move', title: 'Movement', icon: 'üèÉ',
        text: 'Use WASD or Arrow keys to move around the arena.',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'controls', id: 'dash', title: 'Dash', icon: 'üí®',
        text: 'Press Space to dash! It gives you a burst of speed. 3-second cooldown.',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'controls', id: 'tag-it', title: 'Being IT', icon: 'üè∑Ô∏è',
        text: 'When YOU are IT (red glow), run into a bot to tag them and pass IT along!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'controls', id: 'tag-notit', title: 'Not IT', icon: 'üèÉ‚Äç‚ôÇÔ∏è',
        text: 'When someone else is IT, run away! Your score is time spent NOT being IT.',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'controls', id: 'stored', title: 'Stored Powerup', icon: 'üõ°Ô∏è',
        text: 'Some powerups are stored. Press E to activate them when you need them!',
        hint: '', manualNext: true, pauseGame: true,
    },
    // Phase: HUD Tour (paused, with highlights)
    {
        phase: 'hud', id: 'hud-timer', title: 'Timer', icon: '‚è±Ô∏è',
        text: 'This shows the round timer. Each round lasts 60 seconds, 3 rounds per game.',
        hint: '', manualNext: true, pauseGame: true,
        highlight() {
            return { x: canvas.width / 2 - 70, y: 4, w: 140, h: 60 };
        },
    },
    {
        phase: 'hud', id: 'hud-score', title: 'Score', icon: '‚≠ê',
        text: 'Your survival score ‚Äî time spent NOT being IT.',
        hint: '', manualNext: true, pauseGame: true,
        highlight() {
            return { x: 10, y: 4, w: 170, h: 58 };
        },
    },
    {
        phase: 'hud', id: 'hud-dash', title: 'Dash Cooldown', icon: 'üí®',
        text: 'Shows when your dash is ready or cooling down.',
        hint: '', manualNext: true, pauseGame: true,
        highlight() {
            return { x: canvas.width - 148, y: 4, w: 140, h: 52 };
        },
    },
    {
        phase: 'hud', id: 'hud-minimap', title: 'Minimap', icon: 'üó∫Ô∏è',
        text: 'The minimap shows everyone\'s position in the arena.',
        hint: '', manualNext: true, pauseGame: true,
        highlight() {
            return { x: canvas.width - 164, y: canvas.height - 164, w: 160, h: 160 };
        },
    },
    // Phase: Elements
    {
        phase: 'elements', id: 'portal', title: 'Portal', icon: 'üåÄ',
        text: 'Walk into a portal to teleport to its partner portal across the arena!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'elements', id: 'trampoline', title: 'Trampoline', icon: 'ü¶ò',
        text: 'Step on a trampoline to launch into the air at high speed!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'elements', id: 'lava', title: 'Lava Pool', icon: 'üî•',
        text: 'Lava pools slow you down. If you linger too long, you become IT!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'elements', id: 'speed', title: 'Speed Pad', icon: '‚ö°',
        text: 'Run over a speed pad for a temporary speed boost!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'elements', id: 'ice', title: 'Ice Patch', icon: 'üßä',
        text: 'Ice patches make you slide ‚Äî momentum carries you and steering is harder!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'elements', id: 'bumper', title: 'Bumper', icon: 'üî¥',
        text: 'Walk into a bumper and get knocked back! Use them to escape or surprise enemies.',
        hint: '', manualNext: true, pauseGame: true,
    },
    // Phase: Powerups
    {
        phase: 'powerups', id: 'pu-invincible', title: 'Invincible', icon: '‚òÖ',
        text: 'The gold star makes you invincible for 8 seconds ‚Äî you can\'t become IT!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'powerups', id: 'pu-shield', title: 'Shield', icon: 'üõ°Ô∏è',
        text: 'The shield is stored ‚Äî press E to activate it when needed! Blocks tags for 8 seconds.',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'powerups', id: 'pu-speed', title: 'Speed Surge', icon: '‚ö°',
        text: 'Speed surge gives you 3x speed for 5 seconds!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'powerups', id: 'pu-freeze', title: 'Freeze Blast', icon: '‚ùÑÔ∏è',
        text: 'Freeze blast freezes ALL bots in place for 3 seconds!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'powerups', id: 'pu-swap', title: 'Swap', icon: '‚ÜîÔ∏è',
        text: 'Swap instantly teleports you to a random bot\'s position!',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'powerups', id: 'pu-shrink', title: 'Shrink', icon: '‚óÜ',
        text: 'Shrink makes you tiny for 6 seconds ‚Äî much harder to tag!',
        hint: '', manualNext: true, pauseGame: true,
    },
    // Phase: Special
    {
        phase: 'special', id: 'hunter', title: 'The Hunter', icon: 'üéØ',
        text: 'The HUNTER always chases you! Tag it to stun it for 5 seconds.',
        hint: '', manualNext: true, pauseGame: true,
    },
    {
        phase: 'special', id: 'idle', title: 'Idle Warning', icon: '‚ö†Ô∏è',
        text: 'Don\'t stand still for 3 seconds or you\'ll automatically become IT!',
        hint: '', manualNext: true, pauseGame: true,
    },
    // Phase: Settings
    {
        phase: 'settings', id: 'set-tagtype', title: 'Tag Modes', icon: 'üè∑Ô∏è',
        text: 'Choose from Classic, Ball Tag, Banana, Freeze Tag, or Zombie mode!',
        hint: '', manualNext: true, pauseGame: true,
        highlightSelector: '.settings-section:nth-child(1)',
    },
    {
        phase: 'settings', id: 'set-arena', title: 'Arena Size', icon: 'üìê',
        text: 'Pick how big the arena should be ‚Äî from tiny to massive!',
        hint: '', manualNext: true, pauseGame: true,
        highlightSelector: '.settings-section:nth-child(2)',
    },
    {
        phase: 'settings', id: 'set-powerups', title: 'Powerup Toggles', icon: '‚ö°',
        text: 'Enable or disable individual powerups to customize your game.',
        hint: '', manualNext: true, pauseGame: true,
        highlightSelector: '.settings-section:nth-child(3)',
    },
    {
        phase: 'settings', id: 'set-elements', title: 'Element Toggles', icon: 'üß±',
        text: 'Toggle arena elements like portals, lava, ice, and more!',
        hint: '', manualNext: true, pauseGame: true,
        highlightSelector: '.settings-section:nth-child(4)',
    },
    // Phase: Complete
    {
        phase: 'complete', id: 'done', title: "You're Ready!", icon: 'üéâ',
        text: 'You know everything! Go have fun playing Tag!',
        hint: '', manualNext: true, pauseGame: true,
        manualNextLabel: 'Finish',
    },
];

const Tutorial = {
    start() {
        // Save current settings
        tutorialSavedSettings = JSON.parse(JSON.stringify(settings));

        // Set up a simple arena so HUD highlights render correctly
        settings.arenaSize = 'tiny';
        settings.tagType = 'classic';
        generateArena();
        initRound();
        roundTimer = 60; // Show a realistic timer in HUD
        tutorialPaused = true; // Game is always paused in non-interactive tutorial

        // Hide all screens
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('tutorialScreen').classList.add('hidden');
        document.getElementById('settingsScreen').classList.add('hidden');
        document.getElementById('roundEndScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');

        gameState = 'tutorial';
        tutorialActive = true;
        tutorialStep = -1;
        tutorialArrowTarget = null;
        gameTime = 0;

        this.nextStep();
    },

    nextStep() {
        tutorialStep++;
        tutorialArrowTarget = null;
        tutorialPaused = false;

        // Remove any settings highlights
        document.querySelectorAll('.tutorial-highlight-section').forEach(el => {
            el.classList.remove('tutorial-highlight-section');
        });

        // Hide highlight overlay
        document.getElementById('tutorialHighlight').style.display = 'none';

        if (tutorialStep >= TUTORIAL_STEPS.length) {
            this.end();
            return;
        }

        const step = TUTORIAL_STEPS[tutorialStep];

        // Handle settings phase ‚Äî open settings screen
        if (step.phase === 'settings') {
            if (!document.getElementById('settingsScreen').classList.contains('hidden')) {
                // Already open
            } else {
                buildSettingsUI();
                document.getElementById('settingsScreen').classList.remove('hidden');
            }
            tutorialPaused = true;

            // Highlight the section
            if (step.highlightSelector) {
                const panel = document.querySelector('#settingsScreen .panel');
                if (panel) {
                    const section = panel.querySelector(step.highlightSelector);
                    if (section) {
                        section.classList.add('tutorial-highlight-section');
                        section.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }
            }
        } else {
            // Close settings if open
            document.getElementById('settingsScreen').classList.add('hidden');
        }

        // Handle pause
        if (step.pauseGame) {
            tutorialPaused = true;
        }

        // Handle highlight rect (HUD tour)
        if (step.highlight) {
            this.showHighlightRect(step.highlight());
        }

        // Run setup
        if (step.setup) {
            step.setup();
        }

        // Show tooltip
        this.showTooltip(step);
    },

    end() {
        tutorialActive = false;
        tutorialStep = -1;
        tutorialPaused = false;
        tutorialArrowTarget = null;

        // Hide tutorial UI
        document.getElementById('tutorialTooltip').style.display = 'none';
        document.getElementById('tutorialHighlight').style.display = 'none';
        document.getElementById('settingsScreen').classList.add('hidden');
        document.querySelectorAll('.tutorial-highlight-section').forEach(el => {
            el.classList.remove('tutorial-highlight-section');
        });

        // Restore settings
        if (tutorialSavedSettings) {
            settings = tutorialSavedSettings;
            tutorialSavedSettings = null;
            saveSettings();
        }

        // Mark tutorial as done
        localStorage.setItem('tag-game-tutorial-done', '1');

        // Return to start screen
        gameState = 'start';
        document.getElementById('startScreen').classList.remove('hidden');
    },

    showTooltip(step) {
        const tt = document.getElementById('tutorialTooltip');
        document.getElementById('ttIcon').textContent = step.icon || '';
        document.getElementById('ttTitle').textContent = step.title || '';
        document.getElementById('ttText').textContent = step.text || '';
        document.getElementById('ttHint').textContent = step.hint || '';

        // Progress bar
        const progress = ((tutorialStep + 1) / TUTORIAL_STEPS.length) * 100;
        document.getElementById('ttProgressBar').style.width = progress + '%';

        // Next button
        const nextBtn = document.getElementById('ttNext');
        if (step.manualNext) {
            nextBtn.style.display = 'inline-block';
            nextBtn.textContent = step.manualNextLabel || 'Next';
        } else {
            nextBtn.style.display = 'none';
        }

        tt.style.display = 'block';

        // Position tooltip
        tt.style.left = '50%';
        tt.style.transform = 'translateX(-50%)';
        if (step.phase === 'hud' || step.phase === 'settings') {
            // Bottom so it doesn't overlap highlights
            tt.style.top = 'auto';
            tt.style.bottom = '20px';
        } else {
            // Center of screen
            tt.style.top = '50%';
            tt.style.bottom = 'auto';
        }
    },

    showHighlightRect(rect) {
        const overlay = document.getElementById('tutorialHighlight');
        const hCanvas = document.getElementById('highlightCanvas');
        overlay.style.display = 'block';
        hCanvas.width = window.innerWidth;
        hCanvas.height = window.innerHeight;
        const hCtx = hCanvas.getContext('2d');

        // Dark overlay with cutout
        hCtx.fillStyle = 'rgba(0,0,0,0.5)';
        hCtx.fillRect(0, 0, hCanvas.width, hCanvas.height);

        // Clear the highlight area
        hCtx.clearRect(rect.x - 4, rect.y - 4, rect.w + 8, rect.h + 8);

        // Draw pulsing border
        hCtx.strokeStyle = '#4d96ff';
        hCtx.lineWidth = 3;
        hCtx.setLineDash([6, 4]);
        hCtx.strokeRect(rect.x - 4, rect.y - 4, rect.w + 8, rect.h + 8);
        hCtx.setLineDash([]);
    },
};

// --- Event bindings ---
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('nextRoundBtn').addEventListener('click', nextRound);
document.getElementById('playAgainBtn').addEventListener('click', restartGame);
document.getElementById('openSettingsBtn').addEventListener('click', openSettings);
document.getElementById('settingsBackBtn').addEventListener('click', () => closeSettings(false));
document.getElementById('settingsSaveBtn').addEventListener('click', () => closeSettings(true));

// Tutorial buttons
document.getElementById('openTutorialBtn').addEventListener('click', () => {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('tutorialScreen').classList.remove('hidden');
});
document.getElementById('tutorialStartBtn').addEventListener('click', () => {
    Tutorial.start();
});
document.getElementById('tutorialSkipBtn').addEventListener('click', () => {
    document.getElementById('tutorialScreen').classList.add('hidden');
    document.getElementById('startScreen').classList.remove('hidden');
});
document.getElementById('ttNext').addEventListener('click', () => {
    Tutorial.nextStep();
});
document.getElementById('ttSkip').addEventListener('click', () => {
    Tutorial.end();
});

// High score display
function updateStartHighScore() {
    const el = document.getElementById('startHighScore');
    el.textContent = highScore > 0 ? `Best Score: ${highScore.toFixed(1)}s` : '';
}
updateStartHighScore();

// First-time tutorial prompt
if (!localStorage.getItem('tag-game-tutorial-done')) {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('tutorialScreen').classList.remove('hidden');
}

// --- Start ---
lastTime = performance.now();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>

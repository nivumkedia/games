<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Adventure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #B8E6F8 0%, #D8F0FA 40%, #F0F8EC 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameContainer { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #gameCanvas {
            border: 4px solid #5D9E3C;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(93, 158, 60, 0.4);
        }
        #ui { display: flex; gap: 30px; color: #2d5016; font-size: 18px; align-items: center; flex-wrap: wrap; justify-content: center; }
        #ui span { background: rgba(255,255,255,0.7); padding: 8px 16px; border-radius: 20px; border: 2px solid #5D9E3C; }
        #ui button { background: #5D9E3C; color: white; border: none; padding: 8px 16px; border-radius: 20px; font-size: 14px; font-weight: bold; cursor: pointer; transition: background 0.2s; }
        #ui button:hover { background: #4a8030; }
        #instructions { color: #4a7030; font-size: 14px; text-align: center; }
        #message { position: absolute; color: #2d5016; font-size: 32px; font-weight: bold; text-shadow: 2px 2px 4px rgba(255,255,255,0.8); display: none; }
        #wordPopup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: none; justify-content: center;
            align-items: center; z-index: 500;
        }
        #wordPopup .popup-card {
            background: white; border-radius: 15px; padding: 30px 40px;
            text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border: 3px solid #5D9E3C;
        }
        #wordPopup .popup-word { font-size: 48px; font-weight: bold; color: #2d5016; margin: 10px 0 8px; }
        #wordPopup .popup-question { font-size: 18px; color: #4a7030; margin-bottom: 20px; }
        #wordPopup .popup-buttons { display: flex; gap: 20px; justify-content: center; }
        #wordPopup .popup-buttons button {
            padding: 12px 30px; font-size: 20px; font-weight: bold; border: none;
            border-radius: 10px; cursor: pointer; transition: transform 0.1s;
        }
        #wordPopup .popup-buttons button:hover { transform: scale(1.05); }
        #wordPopup .btn-correct { background: #22C55E; color: white; }
        #wordPopup .btn-incorrect { background: #EF4444; color: white; }
        #wordPopup .popup-result { font-size: 22px; font-weight: bold; margin-top: 15px; min-height: 30px; }
        #greetPopup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.7); display: none; justify-content: center;
            align-items: center; z-index: 450;
        }
        #greetPopup .greet-card {
            background: linear-gradient(135deg, #ff6b35, #f7c948, #ff6b35);
            border-radius: 24px; padding: 50px 70px; text-align: center;
            animation: greetBounce 0.5s cubic-bezier(0.17, 0.67, 0.35, 1.5) forwards;
            box-shadow: 0 0 80px rgba(255,107,53,0.6), 0 0 160px rgba(247,201,72,0.3);
        }
        @keyframes greetBounce {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }
        #greetPopup .greet-text {
            font-size: 64px; font-weight: 900; color: #fff;
            text-shadow: 3px 3px 0 #c0392b, 6px 6px 20px rgba(0,0,0,0.4);
            letter-spacing: 3px;
        }
        #greetPopup .greet-btn {
            margin-top: 25px; padding: 14px 50px; font-size: 22px; font-weight: bold;
            border: none; border-radius: 12px; background: #fff; color: #ff6b35;
            cursor: pointer; transition: transform 0.15s;
        }
        #greetPopup .greet-btn:hover { transform: scale(1.1); }
        #startPopup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: flex; justify-content: center;
            align-items: center; z-index: 400;
        }
        #startPopup .popup-card {
            background: white; border-radius: 15px; padding: 30px 40px;
            text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border: 3px solid #5D9E3C;
        }
        #startPopup h2 { color: #2d5016; margin-bottom: 10px; }
        #startPopup p { color: #4a7030; margin-bottom: 20px; font-size: 16px; }
        #startPopup .syl-buttons { display: flex; gap: 15px; justify-content: center; }
        #startPopup .syl-buttons button {
            padding: 15px 30px; font-size: 22px; font-weight: bold; border: none;
            border-radius: 10px; cursor: pointer; background: #5D9E3C; color: white;
            transition: transform 0.1s;
        }
        #startPopup .syl-buttons button:hover { transform: scale(1.05); background: #4a8030; }
        #startPopup .pattern-buttons { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 15px; }
        #startPopup .pattern-buttons button {
            padding: 12px 20px; font-size: 16px; font-weight: bold; border: 3px solid #5D9E3C;
            border-radius: 10px; cursor: pointer; background: white; color: #2d5016;
            transition: all 0.2s;
        }
        #startPopup .pattern-buttons button:hover { background: #E8F5E0; }
        #startPopup .pattern-buttons button.selected { background: #5D9E3C; color: white; border-color: #4a8030; }
        #startPopup .syl-buttons button.disabled { opacity: 0.3; cursor: not-allowed; }
        #savePopup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; justify-content: center;
            align-items: center; z-index: 300;
        }
        #savePopup .popup-card {
            background: white; border-radius: 15px; padding: 30px 40px;
            text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border: 3px solid #5D9E3C; min-width: 400px; max-width: 550px;
        }
        #savePopup h2 { color: #2d5016; margin-bottom: 6px; }
        #savePopup .save-subtitle { color: #4a7030; margin-bottom: 18px; font-size: 14px; }
        #savePopup .save-list {
            max-height: 300px; overflow-y: auto; margin-bottom: 18px;
            border: 1px solid #e0e0e0; border-radius: 10px;
        }
        #savePopup .save-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 16px; border-bottom: 1px solid #f0f0f0;
            cursor: pointer; transition: background 0.15s;
        }
        #savePopup .save-item:last-child { border-bottom: none; }
        #savePopup .save-item:hover { background: #E8F5E0; }
        #savePopup .save-info { text-align: left; flex: 1; }
        #savePopup .save-name { font-weight: bold; color: #2d5016; font-size: 16px; }
        #savePopup .save-details { font-size: 12px; color: #888; margin-top: 2px; }
        #savePopup .save-delete {
            background: #EF4444; color: white; border: none; border-radius: 8px;
            padding: 6px 12px; font-size: 13px; font-weight: bold; cursor: pointer;
            margin-left: 12px; transition: background 0.15s; flex-shrink: 0;
        }
        #savePopup .save-delete:hover { background: #DC2626; }
        #savePopup .save-empty { padding: 30px; color: #999; font-style: italic; }
        #savePopup .save-actions { display: flex; gap: 12px; justify-content: center; }
        #savePopup .save-actions button {
            padding: 10px 24px; font-size: 16px; font-weight: bold; border: none;
            border-radius: 10px; cursor: pointer; transition: transform 0.1s;
        }
        #savePopup .save-actions button:hover { transform: scale(1.05); }
        #savePopup .btn-new-save { background: #5D9E3C; color: white; }
        #savePopup .btn-close { background: #6B7280; color: white; }
        #saveNamePopup {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; justify-content: center;
            align-items: center; z-index: 310;
        }
        #saveNamePopup .popup-card {
            background: white; border-radius: 15px; padding: 30px 40px;
            text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            border: 3px solid #5D9E3C;
        }
        #saveNamePopup h2 { color: #2d5016; margin-bottom: 15px; }
        #saveNamePopup input {
            padding: 10px 18px; font-size: 18px; border: 2px solid #4a7030;
            border-radius: 10px; text-align: center; width: 280px; outline: none; margin-bottom: 15px;
        }
        #saveNamePopup .save-actions { display: flex; gap: 12px; justify-content: center; }
        #saveNamePopup .save-actions button {
            padding: 10px 24px; font-size: 16px; font-weight: bold; border: none;
            border-radius: 10px; cursor: pointer; transition: transform 0.1s;
        }
        #saveNamePopup .save-actions button:hover { transform: scale(1.05); }
        .tab-bar {
            display: flex;
            justify-content: center;
            gap: 0;
            margin-bottom: 15px;
            width: 100%;
            max-width: 820px;
        }
        .tab-bar button {
            flex: 1;
            padding: 12px 24px;
            font-size: 18px;
            font-weight: bold;
            border: 3px solid #5D9E3C;
            cursor: pointer;
            transition: all 0.2s;
            background: #e8f5e0;
            color: #4a7030;
        }
        .tab-bar button:first-child { border-radius: 10px 0 0 10px; }
        .tab-bar button:last-child { border-radius: 0 10px 10px 0; }
        .tab-bar button.active {
            background: #5D9E3C;
            color: white;
        }
        .tab-bar button:hover:not(.active) { background: #d0ebca; }
        #hopFrame {
            display: none;
            border: 4px solid #5D9E3C;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(93,158,60,0.4);
            width: 800px;
            height: 560px;
            position: relative;
            z-index: 1;
        }
    </style>
</head>
<body>
    <button id="backBtn" onclick="switchTab('platformer')" style="display:none; position:fixed; top:15px; left:15px; z-index:400; padding:10px 20px; font-size:16px; font-weight:bold; background:#5D9E3C; color:white; border:none; border-radius:10px; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.3);">Back to Menu</button>
    <iframe id="hopFrame" src="platform-hop.html" tabindex="0"></iframe>
    <div id="gameContainer">
        <div id="ui">
            <span>Score: <b id="score">0</b></span>
            <span style="color:green;">Correct: <b id="correctCount">0</b></span>
            <span style="color:red;">Incorrect: <b id="incorrectCount">0</b></span>
            <span>Level: <b id="level">1</b></span>
            <span>Lives: <b id="lives">3</b></span>
            <button onclick="saveGame()">Save</button>
            <button onclick="loadGame()">Load</button>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="instructions">Arrow Keys/WASD to move | SPACE to jump | Collect coins, find water to heal, avoid lava!</div>
        <div id="message"></div>
        <div id="savePopup">
            <div class="popup-card">
                <h2 id="savePopupTitle">Load Game</h2>
                <p class="save-subtitle" id="savePopupSubtitle">Choose a save to load</p>
                <div class="save-list" id="saveList"></div>
                <div class="save-actions">
                    <button class="btn-new-save" id="savePopupNewBtn" onclick="showSaveNamePopup()">New Save</button>
                    <button class="btn-close" onclick="closeSavePopup()">Cancel</button>
                </div>
            </div>
        </div>
        <div id="saveNamePopup">
            <div class="popup-card">
                <h2>Name Your Save</h2>
                <input type="text" id="saveNameInput" placeholder="Enter save name..." maxlength="30"><br>
                <div class="save-actions">
                    <button class="btn-new-save" onclick="confirmSave()">Save</button>
                    <button class="btn-close" onclick="closeSaveNamePopup()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <div id="startPopup">
        <div class="popup-card">
            <h2 style="margin-bottom:10px;">Choose a Game</h2>
            <div class="tab-bar" style="margin-bottom:20px;">
                <button class="active" onclick="switchTab('platformer')">Speech Therapy Platformer</button>
                <button onclick="switchTab('hop')">Platform Hop</button>
            </div>
            <h2 style="margin-bottom:10px;">What's Your Name?</h2>
            <input type="text" id="playerNameInput" placeholder="Type your name..." style="padding:10px 18px; font-size:18px; border:2px solid #4a7030; border-radius:10px; text-align:center; width:250px; outline:none; margin-bottom:15px;">
            <h2>Choose Word Pattern</h2>
            <p>What type of words do you want to practice?</p>
            <div class="pattern-buttons">
                <button onclick="choosePattern('shortVowels', this)">Short Vowels</button>
                <button onclick="choosePattern('vowelTeams', this)">Vowel Teams</button>
                <button onclick="choosePattern('magicE', this)">Magic E</button>
                <button onclick="choosePattern('prefixSuffix', this)">Prefixes &amp; Suffixes</button>
                <button onclick="choosePattern('fakeBase', this)">Fake Bases + Affixes</button>
                <button onclick="choosePattern('latinGreek', this)">Latin &amp; Greek Affixes</button>
            </div>
            <div id="sylSection" style="display:none;">
                <h2 style="margin-top:15px;">Choose Syllable Count</h2>
                <p>How many syllables should each word have?</p>
                <div class="syl-buttons">
                    <button id="syl1Btn" onclick="startWithSettings(1)">1</button>
                    <button onclick="startWithSettings(2)">2</button>
                    <button onclick="startWithSettings(3)">3</button>
                </div>
            </div>
        </div>
    </div>
    <div id="greetPopup">
        <div class="greet-card">
            <div class="greet-text" id="greetText">WHASSUP!</div>
            <button class="greet-btn" onclick="dismissGreet()">LET'S GO!</button>
        </div>
    </div>
    <div id="wordPopup">
        <div class="popup-card">
            <div class="popup-question">Read this word</div>
            <div class="popup-word" id="popupWord"></div>
            <div class="popup-buttons">
                <button class="btn-correct" onclick="answerPopup(true)">Correct</button>
                <button class="btn-incorrect" onclick="answerPopup(false)">Incorrect</button>
            </div>
            <div class="popup-result" id="popupResult"></div>
        </div>
    </div>

    <script>
        let activeGame = 'platformer';

        function switchTab(tab) {
            const gameContainer = document.getElementById('gameContainer');
            const hopFrame = document.getElementById('hopFrame');
            const buttons = document.querySelectorAll('.tab-bar button');
            activeGame = tab;

            if (tab === 'hop') {
                gameContainer.style.display = 'none';
                hopFrame.style.display = 'block';
                document.getElementById('backBtn').style.display = 'block';
                buttons.forEach(b => b.classList.remove('active'));
                buttons[1].classList.add('active');
                // Re-init the hop game now that iframe is visible
                try { hopFrame.contentWindow.postMessage({ type: 'start' }, '*'); } catch(err) {}
            } else {
                hopFrame.style.display = 'none';
                document.getElementById('backBtn').style.display = 'none';
                gameContainer.style.display = 'flex';
                buttons.forEach(b => b.classList.remove('active'));
                buttons[0].classList.add('active');
            }
        }

        // Listen for Platform Hop landing events (both direct call and postMessage)
        window.onHopLanded = function() {
            if (activeGame === 'hop' && typeof selectedWords !== 'undefined' && selectedWords && selectedWords.length > 0) {
                var hopFrame = document.getElementById('hopFrame');
                try { hopFrame.contentWindow.postMessage({ type: 'pause' }, '*'); } catch(err) {}
                try { if (hopFrame.contentWindow.hopPause) hopFrame.contentWindow.hopPause(); } catch(err) {}
                showWordPopup();
            }
        };
        window.addEventListener('message', function(e) {
            if (e.data && e.data.type === 'landed') {
                window.onHopLanded();
            }
        });

        // Forward key events to iframe when hop is active
        document.addEventListener('keydown', function(e) {
            if (activeGame === 'hop') {
                if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
                var hopFrame = document.getElementById('hopFrame');
                hopFrame.contentWindow.postMessage({ type: 'keydown', code: e.code }, '*');
            }
        });
        document.addEventListener('keyup', function(e) {
            if (activeGame === 'hop') {
                var hopFrame = document.getElementById('hopFrame');
                hopFrame.contentWindow.postMessage({ type: 'keyup', code: e.code }, '*');
            }
        });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const livesEl = document.getElementById('lives');
        const messageEl = document.getElementById('message');

        let score = 0, level = 1, lives = 10, gameRunning = true, invincible = 0, levelComplete = false, deathsThisLevel = 0;

        // ---- Tutorial system ----
        let tutorialShown = {}; // tracks which tutorials have been shown
        let activeTutorials = []; // currently displayed tutorial tips
        let tutorialTimer = 0; // countdown timer for auto-dismiss
        let tutorialPaused = false; // whether game is paused for tutorial

        const tutorialDefs = {
            movement: { text: 'Arrow Keys / WASD to move, or click & drag!', target: 'player', offsetY: -70 },
            jump: { text: 'SPACE / UP to jump, or tap / click!', target: 'player', offsetY: -40 },
            coins: { text: 'Collect coins for points!', target: 'coin' },
            spikes: { text: 'Avoid spikes! They hurt!', target: 'spike' },
            lava: { text: 'Stay away from lava!', target: 'lava' },
            flag: { text: 'Reach the flag to finish!', target: 'flag' },
            springs: { text: 'Springs bounce you high!', target: 'spring' },
            water: { text: 'Water heals +1 life!', target: 'water' },
            movingPlatforms: { text: 'Moving platforms! Time your jumps!', target: 'movingPlatform' },
            portals: { text: 'Portals teleport you!', target: 'portal' },
            drones: { text: 'Drones shoot lasers! Dodge them!', target: 'drone' }
        };

        function getTutorialsForLevel(lvl) {
            var tips = [];
            if (lvl === 1) {
                tips.push('movement', 'jump', 'coins', 'spikes', 'lava', 'flag');
            }
            if (lvl === 2) {
                tips.push('springs', 'water');
            }
            if (lvl === 4) {
                tips.push('movingPlatforms');
            }
            if (lvl === 5) {
                tips.push('portals');
            }
            if (lvl === 20) {
                tips.push('drones');
            }
            return tips.filter(function(t) { return !tutorialShown[t]; });
        }

        function getTutorialTargetPos(def) {
            if (def.target === 'player') return { x: player.x + player.width / 2, y: player.y };
            if (def.target === 'coin') {
                var c = coins.find(function(c) { return !c.collected; });
                return c ? { x: c.x + 10, y: c.y } : null;
            }
            if (def.target === 'spike') {
                var s = spikes[0];
                return s ? { x: s.x + s.width / 2, y: s.y } : null;
            }
            if (def.target === 'lava') {
                var l = lava[0];
                return l ? { x: l.x + l.width / 2, y: l.y } : null;
            }
            if (def.target === 'flag') {
                return flag ? { x: flag.x + 10, y: flag.y } : null;
            }
            if (def.target === 'spring') {
                var sp = springs[0];
                return sp ? { x: sp.x + sp.width / 2, y: sp.y } : null;
            }
            if (def.target === 'water') {
                var w = water.find(function(w) { return !w.collected; });
                return w ? { x: w.x + w.width / 2, y: w.y } : null;
            }
            if (def.target === 'movingPlatform') {
                var mp = movingPlatforms[0];
                return mp ? { x: mp.x + mp.width / 2, y: mp.y } : null;
            }
            if (def.target === 'portal') {
                var p = portals[0];
                return p ? { x: p.x + 15, y: p.y } : null;
            }
            if (def.target === 'drone') {
                var d = drones[0];
                return d ? { x: d.x + d.width / 2, y: d.y } : null;
            }
            return null;
        }

        let tutorialIndex = 0; // current tip index within activeTutorials

        function showLevelTutorials() {
            var tips = getTutorialsForLevel(level);
            if (tips.length === 0) return;
            activeTutorials = tips;
            tutorialIndex = 0;
            tutorialPaused = true;
            tips.forEach(function(t) { tutorialShown[t] = true; });
        }

        function nextTutorial() {
            tutorialIndex++;
            if (tutorialIndex >= activeTutorials.length) {
                activeTutorials = [];
                tutorialIndex = 0;
                tutorialPaused = false;
            }
        }

        function dismissTutorials() {
            activeTutorials = [];
            tutorialIndex = 0;
            tutorialPaused = false;
        }

        function drawTutorials() {
            if (activeTutorials.length === 0) return;
            var t = globalTime * 0.016;
            var tipKey = activeTutorials[tutorialIndex];
            var def = tutorialDefs[tipKey];
            if (!def) return;
            var pos = getTutorialTargetPos(def);
            if (!pos) { nextTutorial(); return; }

            // Semi-transparent overlay
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // --- Draw the single current tip ---
            var textY = pos.y - 45 + (def.offsetY || 0);
            if (textY < 30) textY = pos.y + 55;
            if (textY > 460) textY = 430;
            var textX = pos.x;
            if (textX < 100) textX = 100;
            if (textX > 700) textX = 700;

            // Pulsing arrow
            var arrowPulse = Math.sin(t * 4) * 3;
            var arrowY = textY + 18;
            var arrowTargetY = pos.y - 5;
            if (textY > pos.y) {
                arrowY = textY - 8;
                arrowTargetY = pos.y + 25;
            }

            // Dashed arrow line
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2.5;
            ctx.setLineDash([5, 4]);
            ctx.beginPath();
            ctx.moveTo(textX, arrowY + arrowPulse);
            ctx.lineTo(pos.x, arrowTargetY + arrowPulse);
            ctx.stroke();
            ctx.setLineDash([]);

            // Arrowhead
            var angle = Math.atan2(arrowTargetY - arrowY, pos.x - textX);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(pos.x + arrowPulse * 0.3, arrowTargetY + arrowPulse);
            ctx.lineTo(pos.x - Math.cos(angle - 0.4) * 10, arrowTargetY + arrowPulse - Math.sin(angle - 0.4) * 10);
            ctx.lineTo(pos.x - Math.cos(angle + 0.4) * 10, arrowTargetY + arrowPulse - Math.sin(angle + 0.4) * 10);
            ctx.closePath();
            ctx.fill();

            // Label background
            ctx.font = 'bold 16px "Segoe UI", Tahoma, sans-serif';
            var textWidth = ctx.measureText(def.text).width;
            var boxW = textWidth + 28;
            var boxH = 32;
            var boxX = textX - boxW / 2;
            var boxY = textY - boxH / 2;
            if (boxX < 4) boxX = 4;
            if (boxX + boxW > 796) boxX = 796 - boxW;

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.beginPath();
            ctx.roundRect(boxX, boxY, boxW, boxH, 10);
            ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.roundRect(boxX, boxY, boxW, boxH, 10);
            ctx.stroke();

            // Label text
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(def.text, boxX + boxW / 2, boxY + boxH / 2);

            // --- Progress counter & Next button at bottom ---
            var bottomY = canvas.height - 30;
            var isLast = tutorialIndex >= activeTutorials.length - 1;
            var btnLabel = isLast ? 'Got it!' : 'Next  \u25B6';

            // Progress dots
            ctx.textAlign = 'center';
            var dotsStr = '';
            for (var di = 0; di < activeTutorials.length; di++) {
                dotsStr += di === tutorialIndex ? '\u25CF ' : '\u25CB ';
            }
            ctx.font = '14px "Segoe UI", Tahoma, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.fillText(dotsStr.trim(), canvas.width / 2, bottomY + 16);

            // Next/Got it button
            ctx.font = 'bold 18px "Segoe UI", Tahoma, sans-serif';
            var btnTextW = ctx.measureText(btnLabel).width;
            var btnW = btnTextW + 36;
            var btnH = 36;
            var btnX = canvas.width / 2 - btnW / 2;
            var btnY = bottomY - btnH / 2;

            // Store button bounds for click detection
            drawTutorials._btnX = btnX;
            drawTutorials._btnY = btnY;
            drawTutorials._btnW = btnW;
            drawTutorials._btnH = btnH;

            // Button glow
            ctx.fillStyle = 'rgba(255,215,0,0.15)';
            ctx.beginPath();
            ctx.roundRect(btnX - 4, btnY - 4, btnW + 8, btnH + 8, 14);
            ctx.fill();

            // Button background
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.roundRect(btnX, btnY, btnW, btnH, 10);
            ctx.fill();

            // Button text
            ctx.fillStyle = '#1a1a1a';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(btnLabel, canvas.width / 2, bottomY);

            // Reset text alignment
            ctx.textAlign = 'start';
            ctx.textBaseline = 'alphabetic';
        }

        const player = {
            x: 50, y: 400, width: 30, height: 36,
            vx: 0, vy: 0, speed: 5, jumpPower: -13,
            onGround: false, facing: 1, animFrame: 0
        };

        const gravity = 0.6, friction = 0.85;
        const keys = {};

        // Seeded PRNG for consistent word generation
        function mulberry32(a) {
            return function() {
                a |= 0; a = a + 0x6D2B79F5 | 0;
                var t = Math.imul(a ^ a >>> 15, 1 | a);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function buildWordBank() {
            var onsets = ['b','c','d','f','g','h','j','k','l','m','n','p','r','s','t','v','w','y','z'];
            var blends = ['bl','br','cl','cr','dr','fl','fr','gl','gr','pl','pr','sk','sl','sm','sn','sp','st','sw','tr','tw','ch','sh','th'];
            var simpleCodas = ['b','d','f','g','k','l','m','n','p','s','t','x'];
            var endCodas = ['b','d','f','g','k','l','m','n','p','s','t','x','ft','ld','lf','lk','lp','lt','mp','nd','nk','nt','sk','sp','st'];
            var shortV = ['a','e','i','o','u'];
            var vTeams = ['ai','ay','ea','ee','oa','oi','oy','ou','oo','ue','ew','ow','ie','ei','au','aw','ui','ey'];
            var longV = ['a','i','o','u','e'];
            var bank = {};

            function genList(pattern, syls, seed) {
                var rand = mulberry32(seed);
                var pick = function(arr) { return arr[Math.floor(rand() * arr.length)]; };
                var getOnset = function() { return rand() > 0.35 ? pick(onsets) : pick(blends); };
                var words = [];
                var seen = {};
                var att = 0;
                while (words.length < 500 && att < 8000) {
                    att++;
                    var word = '';
                    for (var i = 0; i < syls; i++) {
                        var isFirst = i === 0;
                        var isLast = i === syls - 1;
                        var onset = isFirst ? getOnset() : pick(onsets);
                        var coda = isLast ? pick(endCodas) : pick(simpleCodas);
                        if (pattern === 'shortVowels') {
                            word += onset + pick(shortV) + coda;
                        } else if (pattern === 'vowelTeams') {
                            if (isFirst) {
                                word += onset + pick(vTeams) + pick(simpleCodas);
                            } else {
                                word += onset + pick(shortV) + coda;
                            }
                        } else if (pattern === 'magicE') {
                            if (isLast) {
                                word += onset + pick(longV) + pick(simpleCodas) + 'e';
                            } else {
                                word += onset + pick(shortV) + pick(simpleCodas);
                            }
                        }
                    }
                    if (!seen[word]) { seen[word] = true; words.push(word); }
                }
                return words;
            }

            ['shortVowels','vowelTeams','magicE'].forEach(function(p, pi) {
                bank[p] = {};
                for (var s = 1; s <= 3; s++) {
                    bank[p][s] = genList(p, s, (pi + 1) * 10000 + s * 1000);
                }
            });

            bank.prefixSuffix = {
                2: [
                    'undo','unfair','unlike','unlock','unpack','untie','unseen','unsafe','unfit','unwrap',
                    'unzip','unplug','unwind','undone','unload','uncap','unhook','unpin','unmask','untold',
                    'unbend','unblock','unborn','unchain','unclean','unclear','uncoil','uncork','uncut','undress',
                    'unfed','unfold','unglue','unhurt','unjust','unkind','unlace','unlit','unmark','unmet',
                    'unpaid','unplanned','unrest','unroll','unsaid','unscrew','unseal','unsnap','unstuck','untried',
                    'redo','replay','refill','reheat','rewind','reset','retell','rename','reread','recount',
                    'rethink','rewrite','repaint','restock','rejoin','remix','retie','resend','recheck','retest',
                    'reboot','rebuild','recast','reclaim','reclean','recoat','recode','recook','redial','redraw',
                    'refit','refold','regain','reglue','regrip','regrow','rehang','rehire','reknit','relearn',
                    'reload','relock','remake','rematch','remelt','remold','repack','repay','replant','reprint',
                    'preview','preset','prepaid','precut','prewash','preplan','preheat','presoak','premix','pretest',
                    'preboard','prebook','precook','predate','predawn','prefab','pregame','prelaunch','premade','preschool',
                    'misread','mislead','misstep','misfire','misspell','miscount','misprint','misjudge','misplace','misquote',
                    'mismatch','misname','misrule','mistrust','mistype','misuse','misdeal','misdeed','mishear','mislabel',
                    'dislike','dismiss','distrust','disgust','dismay','disband','disown','disprove','displace','disarm',
                    'disbar','discard','disclaim','disclose','discount','disdain','disfavor','disgrace','disjoined','disklike',
                    'helping','jumping','running','sitting','reading','cooking','fishing','camping','painting','landing',
                    'lifting','asking','packing','mixing','resting','drinking','sleeping','thinking','spelling','counting',
                    'walking','talking','working','playing','growing','flying','crying','dying','lying','trying',
                    'baking','biking','boxing','busing','caring','caving','chasing','clapping','climbing','closing',
                    'dancing','dipping','diving','drawing','driving','dropping','eating','fading','falling','feeding',
                    'hopeful','careful','joyful','thankful','helpful','playful','mindful','harmful','painful','fearful',
                    'cheerful','faithful','graceful','peaceful','powerful','skillful','spiteful','tasteful','wasteful','wrathful',
                    'endless','fearless','harmless','hopeless','useless','careless','restless','homeless','tireless','boneless',
                    'ageless','aimless','baseless','blameless','breathless','cashless','cloudless','cordless','countless','dateless',
                    'doubtless','dustless','faceless','fadeless','flawless','gateless','guileless','gutless','hairless','hatless',
                    'kindness','sadness','illness','fitness','darkness','goodness','weakness','madness','boldness','fondness',
                    'gladness','hardness','likeness','loudness','meekness','nearness','oddness','rawness','richness','sharpness',
                    'slower','faster','taller','smaller','stronger','longer','softer','harder','brighter','darker',
                    'cleaner','deeper','fairer','finer','fresher','greater','keener','leaner','lighter','milder',
                    'biggest','fastest','longest','tallest','smallest','hardest','softest','closest','deepest','widest',
                    'boldest','coldest','coolest','darkest','fairest','finest','fullest','grandest','keenest','kindest'
                ],
                3: [
                    'unhappy','unlucky','unlikely','unable','uncommon','uncover','unfriendly','unwilling','uncertain','unfinished',
                    'untidy','unbroken','unkindly','unlocking','unpacking','unwinding','undoing','unloading','uncovered','unmasking',
                    'unaware','unbeaten','unbuckle','unburden','unbutton','unchanged','uncivil','unclutter','uncoated','underfed',
                    'underline','underscore','underpaid','underwater','unearned','unending','uneven','unfailing','unfasten','unfeeling',
                    'unfiltered','unfounded','ungainly','ungraded','unharmed','unhealthy','unheated','unknowing','unlawful','unlikely',
                    'unmarried','unmindful','unopened','unpleasant','unplugging','unquestioned','unraveled','unrelated','unsaddled','unsettled',
                    'returning','reviewing','replacing','removing','repeating','recording','rewinding','restarting','refreshing','recalling',
                    'replaying','rewriting','rewarding','recounting','rejoining','reminding','reopening','refilling','reheating','resending',
                    'reacting','realigning','rearranging','reassembling','rebalancing','rebounding','rebuilding','recapturing','recasting','rechecking',
                    'reclaiming','recoating','recoding','recoloring','reconnecting','reconsidering','recopying','recovering','redefining','redesigning',
                    'redirecting','redoing','redriving','reenacting','reengaging','reentering','reexamining','refinishing','refocusing','reforming',
                    'discover','disappear','disagree','discolor','disorder','discomfort','disrupting','disproving','displacing','disarming',
                    'disabled','disabling','disallow','disbelief','discarding','disclosing','discomfort','disconnect','discontent','discourage',
                    'discredit','disgusted','dishonest','dishonor','disinfect','disjointed','dislodging','dismantled','dismounted','disobeyed',
                    'wonderful','beautiful','powerful','colorful','delightful','bountiful','plentiful','forgetful','ungrateful','distasteful',
                    'bountiful','disdainful','distrustful','frightful','neglectful','regretful','remorseful','resentful','revengeful','suspenseful',
                    'carefully','hopefully','thankfully','cheerfully','playfully','mindfully','joyfully','fearfully','painfully','helpfully',
                    'bashfully','blissfully','doubtfully','dutifully','fanciful','forcefully','gleefully','gracefully','gratefully','hatefully',
                    'happiness','loneliness','emptiness','eagerness','laziness','awareness','dizziness','fuzziness','craziness','readiness',
                    'bitterness','blindness','calmness','cleverness','closeness','coolness','craftiness','crispness','dampness','deafness',
                    'directness','dirtiness','drowsiness','dullness','dustiness','eeriness','faintness','fieriness','flatness','fondness',
                    'endlessly','carelessly','hopelessly','uselessly','fearlessly','restlessly','tirelessly','aimlessly','helplessly','mindlessly',
                    'breathlessly','ceaselessly','changelessly','clumsily','colorlessly','countlessly','dauntlessly','doubtlessly','effortlessly','faultlessly',
                    'misreading','misleading','misspelling','misfiring','miscounting','misjudging','misplacing','misquoting','misprinting','misguided',
                    'misaligning','misbehaving','miscalling','mischarging','misconnect','misdirecting','misfeeding','mishandling','mishearing','mislabeling',
                    'preparing','predicting','preventing','pretending','presenting','preserving','preceding','premature','precaution','prescribing',
                    'preapproval','prearranging','precleaning','precoloring','precondition','predated','preempting','preexisting','prefacing','preheating',
                    'recycle','recover','reminder','reporter','remember','receiver','remainder','retailer','recorder','reflector',
                    'recliner','redeemer','defender','deliverer','describer','designer','developer','differing','digester','discharger',
                    'dispenser','disposer','distinguisher','distributer','divider','eliciter','employer','enabler','enchanter','endanger'
                ]
            };

            // Fake bases with real prefixes and suffixes
            var prefixes = ['un','re','pre','mis','dis'];
            var suffixes = ['ing','ful','less','ness','er','est','ed','ly','ment'];
            function genFakeBase(seed) {
                var rand = mulberry32(seed);
                var pick = function(arr) { return arr[Math.floor(rand() * arr.length)]; };
                var getOnset = function() { return rand() > 0.35 ? pick(onsets) : pick(blends); };
                var makeSyl = function() { return getOnset() + pick(shortV) + pick(simpleCodas); };
                var words2 = [], words3 = [];
                var seen2 = {}, seen3 = {};
                var att = 0;
                while ((words2.length < 500 || words3.length < 500) && att < 10000) {
                    att++;
                    var base = makeSyl();
                    var usePrefix = rand() > 0.5;
                    var w2, w3;
                    if (usePrefix) {
                        var pre = pick(prefixes);
                        w2 = pre + base;
                        w3 = pre + base + pick(suffixes);
                    } else {
                        var suf = pick(suffixes);
                        w2 = base + suf;
                        var pre2 = pick(prefixes);
                        w3 = pre2 + base + suf;
                    }
                    if (words2.length < 500 && !seen2[w2]) { seen2[w2] = true; words2.push(w2); }
                    if (words3.length < 500 && !seen3[w3]) { seen3[w3] = true; words3.push(w3); }
                }
                return { 2: words2, 3: words3 };
            }
            bank.fakeBase = genFakeBase(99999);

            bank.latinGreek = {
                2: [
                    'action','faction','fiction','function','mention','motion','nation','notion','option','potion',
                    'ration','section','station','version','caution','portion','lotion','auction','traction','suction',
                    'diction','fashion','fusion','lesion','mansion','mission','passion','pension','session','tension',
                    'torsion','traction','union','vision','bastion',
                    'moment','segment','cement','comment','fragment','garment','payment','ailment','judgment','treatment',
                    'ament','ament','cement','figment','filament','lement','ornament','pigment','raiment','shipment',
                    'torment','alment','vestment',
                    'central','dental','final','mental','rental','signal','fatal','legal','metal','moral',
                    'total','social','local','global','plural','formal','normal','vocal','royal','rural',
                    'basal','brutal','causal','choral','coastal','coral','cranial','crystal','equal','feudal',
                    'fiscal','focal','frugal','fungal','herbal','journal','lethal','martial','medal','nasal',
                    'naval','neural','nodal','oral','oval','papal','pedal','penal','postal','primal',
                    'active','massive','passive','motive','native','festive','captive',
                    'cursive','furtive','pensive','plaintive','sportive','votive',
                    'famous','nervous','joyous','porous','anxious','conscious','precious','spacious','gracious','curious',
                    'callous','cautious','copious','devious','envious','ferrous','fibrous','furious','gaseous','heinous',
                    'jealous','lustrous','mucous','obvious','odious','onerous','parlous','raucous','serious','studious',
                    'tedious','timeous','vicious','vigorous','viscous','wondrous','zealous',
                    'subway','subset','transplant','transport','postcard','postmark','transfer','submerge',
                    'subtext','subplot','subsoil','sublime','submit','succeed','suffix','suggest','summit','supper',
                    'posture','postage','postpone','compound','complex','combat','commute','compose','conduct','confirm',
                    'congress','connect','consent','consult','contact','contain','contract','control','convert','convex'
                ],
                3: [
                    'attention','admission','collision','conclusion','confusion','decision','direction','division','election','erosion',
                    'explosion','extension','illusion','inclusion','invasion','location','nutrition','occasion','permission','pollution',
                    'position','precision','protection','provision','reduction','revision','selection','solution','suspension','tradition',
                    'vacation','promotion','devotion','formation','relation','vibration','creation','migration','rotation','equation',
                    'abolition','acquisition','addition','affection','ambition','animation','assumption','attraction','aviation','celebration',
                    'collection','combustion','commission','compassion','completion','complexion','composition','conception','condition','connection',
                    'construction','convention','conviction','correction','corruption','deception','decoration','deduction','deflection','demolition',
                    'depression','description','desertion','detection','detention','digestion','dimension','disruption','distortion','donation',
                    'education','elevation','emotion','eruption','eviction','evolution','exception','excursion','exemption','exhaustion',
                    'agreement','apartment','arrangement','assignment','attachment','commitment','department','employment','enjoyment','equipment',
                    'excitement','improvement','investment','management','punishment','replacement','retirement','settlement','amazement','achievement',
                    'abandonment','abatement','abolishment','accomplishment','acknowledgment','adjustment','advancement','advertisement','advisement','allotment',
                    'amazement','amusement','announcement','appointment','assessment','astonishment','attainment','battlement','bereavement','bewilderment',
                    'bombardment','compartment','concealment','contentment','deferment','detachment','development','displacement','embodiment','empowerment',
                    'abundance','appearance','attendance','audience','confidence','consequence','difference','dominance','elegance','endurance',
                    'evidence','existence','ignorance','importance','influence','innocence','insurance','patience','preference','presence',
                    'reference','resistance','sequence','substance','tolerance','violence','alliance','fragrance','guidance','radiance',
                    'absorbance','abundance','acceptance','accordance','admittance','allegiance','allowance','ambulance','annoyance','appliance',
                    'arrogance','assurance','avoidance','brilliance','clearance','coherence','competence','compliance','concordance','conferance',
                    'conscience','constancy','decadence','defiance','deliverance','dependence','diligence','discordance','dissonance','disturbance',
                    'autograph','paragraph','photograph','microscope','telescope','telephone','microphone','periscope','saxophone','telegraph',
                    'barograph','biography','calligraphy','cartography','choreograph','chronograph','cosmograph','cryptograph','demography','geography',
                    'holograph','homograph','lithograph','monograph','pictograph','polygraph','seismograph','spectrograph','stenograph','typography',
                    'horrible','possible','terrible','flexible','sensible','probable','suitable','adorable','enjoyable','washable',
                    'accessible','adaptable','advisable','agreeable','allowable','amicable','applicable','available','avoidable','breakable',
                    'burnable','capable','changeable','climbable','comfortable','comparable','compatible','countable','credible','curable',
                    'dangerous','fabulous','glamorous','humorous','luminous','murderous','numerous','poisonous','previous','prosperous',
                    'ambitious','anomalous','barbarous','blasphemous','calamitous','cancerous','cavernous','clamorous','covetous','credulous',
                    'deciduous','desirous','disastrous','dubious','erroneous','frivolous','generous','gluttonous','hazardous','idolatrous',
                    'supervise','interview','interact','interval','intercept','multiply','monotone','internet','introduce','intersect',
                    'advocate','alternate','calculate','calibrate','candidate','celebrate','circulate','compensate','complicate','concentrate',
                    'correlate','cultivate','decorate','dedicate','demonstrate','designate','desolate','devastate','dominate','duplicate',
                    'cardinal','carnival','chemical','criminal','critical','cultural','fictional','funeral','general','liberal',
                    'literal','logical','magical','mineral','minimal','musical','mythical','national','nautical','nominal',
                    'optional','personal','physical','practical','principal','radical','regional','seasonal','surgical','tactical',
                    'terminal','tropical','typical','vertical','virtual','visual','whimsical','comical','digital','clinical',
                    'aboriginal','accidental','additional','ancestral','artificial','beneficial','botanical','celestial','centennial','ceremonial',
                    'classical','clerical','colonial','commercial','conditional','continental','corporal','diagonal','disposal','doctoral',
                    'editorial','electrical','emotional','empirical','essential','external','fanatical','geometrical','historical','horizontal'
                ]
            };

            return bank;
        }

        const wordBank = buildWordBank();
        let selectedPatterns = [];
        let selectedWords = [];
        let gamePaused = true;
        let usedWords = [];
        let correctCount = 0, incorrectCount = 0;

        function choosePattern(pattern, btn) {
            var idx = selectedPatterns.indexOf(pattern);
            if (idx === -1) {
                selectedPatterns.push(pattern);
                btn.classList.add('selected');
            } else {
                selectedPatterns.splice(idx, 1);
                btn.classList.remove('selected');
            }
            if (selectedPatterns.length > 0) {
                document.getElementById('sylSection').style.display = 'block';
            } else {
                document.getElementById('sylSection').style.display = 'none';
            }
            var syl1 = document.getElementById('syl1Btn');
            var hasOneSyl = selectedPatterns.some(function(p) {
                return wordBank[p] && wordBank[p][1];
            });
            if (hasOneSyl) {
                syl1.classList.remove('disabled');
                syl1.disabled = false;
            } else {
                syl1.classList.add('disabled');
                syl1.disabled = true;
            }
        }

        function startWithSettings(n) {
            if (selectedPatterns.length === 0) return;
            var combined = [];
            selectedPatterns.forEach(function(p) {
                var list = wordBank[p][n];
                if (list) combined = combined.concat(list);
            });
            if (combined.length === 0) return;
            selectedWords = combined;
            usedWords = [];
            var name = document.getElementById('playerNameInput').value.trim();
            var greetName = name ? name.toUpperCase() : 'BUDDY';
            document.getElementById('greetText').textContent = 'WHASSUP ' + greetName + '!';
            document.getElementById('startPopup').style.display = 'none';
            document.getElementById('greetPopup').style.display = 'flex';

            if (activeGame === 'hop') {
                // Tell iframe to start
                var hopFrame = document.getElementById('hopFrame');
                hopFrame.contentWindow.postMessage({ type: 'start' }, '*');
            }
        }

        function dismissGreet() {
            document.getElementById('greetPopup').style.display = 'none';
            if (activeGame === 'hop') {
                var hopFrame = document.getElementById('hopFrame');
                hopFrame.contentWindow.postMessage({ type: 'start' }, '*');
                hopFrame.focus();
            } else {
                gamePaused = false;
                showLevelTutorials();
            }
        }

        function showWordPopup() {
            gamePaused = true;
            if (usedWords.length >= selectedWords.length) usedWords = [];
            let word;
            do {
                word = selectedWords[Math.floor(Math.random() * selectedWords.length)];
            } while (usedWords.includes(word));
            usedWords.push(word);
            document.getElementById('popupWord').textContent = word;
            document.getElementById('popupResult').textContent = '';
            document.getElementById('wordPopup').style.display = 'flex';
        }

        function answerPopup(saidCorrect) {
            const resultEl = document.getElementById('popupResult');
            if (saidCorrect) {
                resultEl.textContent = 'Great job!';
                resultEl.style.color = '#22C55E';
                score += 5;
                scoreEl.textContent = score;
                correctCount++;
                document.getElementById('correctCount').textContent = correctCount;
            } else {
                resultEl.textContent = 'Try again next time!';
                resultEl.style.color = '#EF4444';
                incorrectCount++;
                document.getElementById('incorrectCount').textContent = incorrectCount;
            }
            setTimeout(() => {
                document.getElementById('wordPopup').style.display = 'none';
                if (activeGame === 'hop') {
                    var hopFrame = document.getElementById('hopFrame');
                    try { hopFrame.contentWindow.postMessage({ type: 'resume' }, '*'); } catch(err) {}
                    try { if (hopFrame.contentWindow.hopResume) hopFrame.contentWindow.hopResume(); } catch(err) {}
                    hopFrame.focus();
                } else {
                    gamePaused = false;
                }
            }, 1000);
        }

        let platforms = [], coins = [], spikes = [], springs = [], lava = [], portals = [], water = [];
        let movingPlatforms = [], flag = null, particles = [], clouds = [];
        let drones = [], lasers = [];
        let waterTimer = 0; // frames spent in water

        // ---- Visual-only state ----
        let screenShake = { x: 0, y: 0, intensity: 0 };
        let ambientParticles = [];
        let playerTrail = [];
        let backgroundTrees = [];
        let bgMountains = [];
        let globalTime = 0;
        let lavaEmbers = [];

        const colors = {
            player: '#E85D04', playerDark: '#BC4B03',
            platform: '#5D9E3C', platformTop: '#7EC850', platformDirt: '#8B5A2B',
            coin: '#FFD700', coinShine: '#FFF8DC',
            spike: '#4B5563', flag: '#22C55E', flagPole: '#92400E',
            sky1: '#87CEEB', sky2: '#E0F6FF', cloud: '#FFFFFF', sun: '#FCD34D',
            spring: '#FFD700', springBase: '#B8860B',
            lava: '#FF4500', lavaGlow: '#FF6347',
            portal: '#9B59B6', portalGlow: '#8E44AD',
            drone: '#374151', droneLight: '#EF4444',
            laser: '#EF4444', laserGlow: '#FCA5A5',
            water: '#2196F3', waterDeep: '#1565C0', waterSurface: '#64B5F6'
        };

        // ---- Visual initialization ----
        function initVisuals() {
            // Ambient floating particles (fireflies/dust)
            ambientParticles = [];
            for (let i = 0; i < 18; i++) {
                ambientParticles.push({
                    x: Math.random() * 800,
                    y: Math.random() * 480,
                    size: 1 + Math.random() * 2,
                    speed: 0.15 + Math.random() * 0.25,
                    angle: Math.random() * Math.PI * 2,
                    angleSpeed: (Math.random() - 0.5) * 0.03,
                    brightness: Math.random(),
                    brightnessDir: Math.random() > 0.5 ? 1 : -1,
                    color: Math.random() > 0.5 ? '#ffe88a' : '#ffffff'
                });
            }

            // Background trees (two layers)
            backgroundTrees = [];
            for (let i = 0; i < 9; i++) {
                backgroundTrees.push({
                    x: 20 + i * 95 + Math.random() * 40,
                    y: 390 + Math.random() * 15,
                    h: 55 + Math.random() * 30,
                    w: 18 + Math.random() * 10,
                    layer: 0
                });
            }
            for (let i = 0; i < 7; i++) {
                backgroundTrees.push({
                    x: 50 + i * 115 + Math.random() * 40,
                    y: 400 + Math.random() * 10,
                    h: 35 + Math.random() * 20,
                    w: 12 + Math.random() * 8,
                    layer: 1
                });
            }

            // Mountains (parallax layers)
            bgMountains = [
                // far layer
                [
                    { x: 0, y: 310 }, { x: 80, y: 240 }, { x: 180, y: 280 }, { x: 260, y: 210 },
                    { x: 360, y: 250 }, { x: 440, y: 200 }, { x: 540, y: 245 }, { x: 640, y: 215 },
                    { x: 720, y: 260 }, { x: 800, y: 290 }
                ],
                // mid layer
                [
                    { x: 0, y: 340 }, { x: 100, y: 290 }, { x: 200, y: 320 }, { x: 300, y: 270 },
                    { x: 400, y: 305 }, { x: 500, y: 265 }, { x: 600, y: 300 }, { x: 700, y: 280 },
                    { x: 800, y: 330 }
                ]
            ];

            // Lava embers
            lavaEmbers = [];
        }

        function initClouds() {
            clouds = [];
            for (let i = 0; i < 6; i++) {
                clouds.push({
                    x: Math.random() * 800,
                    y: 30 + Math.random() * 90,
                    size: 28 + Math.random() * 28,
                    speed: 0.18 + Math.random() * 0.18,
                    puffs: 3 + Math.floor(Math.random() * 3)
                });
            }
        }

        function generateLevel(lvl) {
            platforms = []; coins = []; spikes = []; springs = []; lava = []; portals = []; water = [];
            movingPlatforms = []; particles = []; levelComplete = false;
            drones = []; lasers = []; waterTimer = 0;

            // Ground
            platforms.push({ x: 0, y: 460, width: 800, height: 40, isGround: true });

            const layouts = [
                // Level 1 - intro
                () => {
                    // Split ground for lava pit
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 520, height: 40, isGround: true });
                    platforms.push({ x: 580, y: 460, width: 220, height: 40, isGround: true });
                    platforms.push({ x: 100, y: 380, width: 90, height: 20 });
                    platforms.push({ x: 280, y: 320, width: 85, height: 20 });
                    platforms.push({ x: 450, y: 260, width: 85, height: 20 });
                    platforms.push({ x: 620, y: 200, width: 90, height: 20 });
                    platforms.push({ x: 700, y: 140, width: 70, height: 20 });
                    spikes.push({ x: 380, y: 445, width: 36, height: 15 });
                    lava.push({ x: 520, y: 461, width: 60, height: 39 });
                },
                // Level 2 - springs
                () => {
                    // Split ground for lava pit
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 340, height: 40, isGround: true });
                    platforms.push({ x: 410, y: 460, width: 390, height: 40, isGround: true });
                    platforms.push({ x: 80, y: 390, width: 75, height: 20 });
                    platforms.push({ x: 220, y: 340, width: 70, height: 20 });
                    platforms.push({ x: 380, y: 290, width: 15, height: 20 });
                    platforms.push({ x: 435, y: 290, width: 15, height: 20 });
                    platforms.push({ x: 540, y: 240, width: 70, height: 20 });
                    platforms.push({ x: 680, y: 180, width: 75, height: 20 });
                    platforms.push({ x: 700, y: 120, width: 70, height: 20 });
                    springs.push({ x: 150, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    spikes.push({ x: 500, y: 445, width: 36, height: 15 });
                    lava.push({ x: 340, y: 461, width: 70, height: 39 });
                    water.push({ x: 395, y: 291, width: 40, height: 19, collected: false });
                },
                // Level 3 - jumps
                () => {
                    // Split ground for lava pits
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 200, height: 40, isGround: true });
                    platforms.push({ x: 270, y: 460, width: 360, height: 40, isGround: true });
                    platforms.push({ x: 690, y: 460, width: 110, height: 40, isGround: true });
                    platforms.push({ x: 60, y: 400, width: 65, height: 20 });
                    platforms.push({ x: 170, y: 350, width: 60, height: 20 });
                    platforms.push({ x: 280, y: 300, width: 60, height: 20 });
                    platforms.push({ x: 390, y: 350, width: 60, height: 20 });
                    platforms.push({ x: 500, y: 290, width: 60, height: 20 });
                    platforms.push({ x: 610, y: 240, width: 60, height: 20 });
                    platforms.push({ x: 700, y: 180, width: 65, height: 20 });
                    platforms.push({ x: 720, y: 120, width: 55, height: 20 });
                    springs.push({ x: 130, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    spikes.push({ x: 300, y: 445, width: 36, height: 15 });
                    lava.push({ x: 200, y: 461, width: 70, height: 39 });
                    lava.push({ x: 630, y: 461, width: 60, height: 39 });
                },
                // Level 4 - moving platforms
                () => {
                    // Split ground for lava pits
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 180, height: 40, isGround: true });
                    platforms.push({ x: 250, y: 460, width: 410, height: 40, isGround: true });
                    platforms.push({ x: 720, y: 460, width: 80, height: 40, isGround: true });
                    platforms.push({ x: 40, y: 410, width: 55, height: 20 });
                    platforms.push({ x: 150, y: 360, width: 50, height: 20 });
                    platforms.push({ x: 290, y: 310, width: 50, height: 20 });
                    platforms.push({ x: 430, y: 360, width: 50, height: 20 });
                    platforms.push({ x: 570, y: 300, width: 10, height: 20 });
                    platforms.push({ x: 620, y: 300, width: 10, height: 20 });
                    platforms.push({ x: 430, y: 220, width: 55, height: 20 });
                    platforms.push({ x: 590, y: 160, width: 55, height: 20 });
                    platforms.push({ x: 700, y: 110, width: 65, height: 20 });
                    movingPlatforms.push({ x: 200, y: 280, width: 55, height: 15, minX: 160, maxX: 270, vx: 2 });
                    movingPlatforms.push({ x: 360, y: 250, width: 55, height: 15, minY: 200, maxY: 300, vy: 2 });
                    movingPlatforms.push({ x: 500, y: 220, width: 55, height: 15, minX: 460, maxX: 570, vx: 2.5 });
                    springs.push({ x: 100, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 500, y: 440, width: 30, height: 20, compressed: false });
                    spikes.push({ x: 400, y: 445, width: 36, height: 15 });
                    lava.push({ x: 180, y: 461, width: 70, height: 39 });
                    lava.push({ x: 660, y: 461, width: 60, height: 39 });
                    water.push({ x: 580, y: 301, width: 40, height: 19, collected: false });
                },
                // Level 5 - portals
                () => {
                    platforms.push({ x: 30, y: 420, width: 50, height: 20 });
                    platforms.push({ x: 120, y: 370, width: 50, height: 20 });
                    platforms.push({ x: 30, y: 310, width: 50, height: 20 });
                    platforms.push({ x: 120, y: 250, width: 50, height: 20 });
                    platforms.push({ x: 230, y: 310, width: 50, height: 20 });
                    platforms.push({ x: 340, y: 260, width: 50, height: 20 });
                    platforms.push({ x: 460, y: 320, width: 50, height: 20 });
                    platforms.push({ x: 570, y: 260, width: 50, height: 20 });
                    platforms.push({ x: 460, y: 180, width: 55, height: 20 });
                    platforms.push({ x: 610, y: 140, width: 55, height: 20 });
                    platforms.push({ x: 720, y: 100, width: 55, height: 20 });
                    movingPlatforms.push({ x: 170, y: 200, width: 50, height: 15, minX: 130, maxX: 230, vx: 2.5 });
                    movingPlatforms.push({ x: 390, y: 200, width: 50, height: 15, minY: 160, maxY: 260, vy: 2.5 });
                    movingPlatforms.push({ x: 540, y: 180, width: 50, height: 15, minX: 500, maxX: 600, vx: 3 });
                    movingPlatforms.push({ x: 680, y: 120, width: 45, height: 15, minY: 80, maxY: 160, vy: 2 });
                    movingPlatforms.push({ x: 300, y: 280, width: 45, height: 15, minX: 260, maxX: 360, vx: 3 });
                    springs.push({ x: 85, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 200, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 300, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 530, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 680, y: 440, width: 30, height: 20, compressed: false });
                    portals.push({ x: 50, y: 270, width: 30, height: 40, targetX: 250, targetY: 270, color: '#9B59B6' });
                    portals.push({ x: 360, y: 220, width: 30, height: 40, targetX: 480, targetY: 280, color: '#E74C3C' });
                    portals.push({ x: 590, y: 220, width: 30, height: 40, targetX: 630, targetY: 100, color: '#3498DB' });
                    portals.push({ x: 480, y: 140, width: 30, height: 40, targetX: 140, targetY: 210, color: '#1ABC9C' });
                    portals.push({ x: 250, y: 270, width: 30, height: 40, targetX: 590, targetY: 220, color: '#F39C12' });
                    spikes.push({ x: 100, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 160, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 250, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 340, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 400, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 500, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 600, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 720, y: 445, width: 36, height: 15 });
                    lava.push({ x: 120, y: 475, width: 45, height: 25 });
                    lava.push({ x: 180, y: 475, width: 50, height: 25 });
                    lava.push({ x: 280, y: 475, width: 50, height: 25 });
                    lava.push({ x: 430, y: 475, width: 50, height: 25 });
                    lava.push({ x: 560, y: 475, width: 50, height: 25 });
                    lava.push({ x: 650, y: 475, width: 50, height: 25 });
                },
                // Level 6 - lava
                () => {
                    platforms.push({ x: 25, y: 420, width: 48, height: 20 });
                    platforms.push({ x: 110, y: 370, width: 45, height: 20 });
                    platforms.push({ x: 195, y: 320, width: 45, height: 20 });
                    platforms.push({ x: 110, y: 260, width: 45, height: 20 });
                    platforms.push({ x: 280, y: 280, width: 45, height: 20 });
                    platforms.push({ x: 370, y: 330, width: 45, height: 20 });
                    platforms.push({ x: 460, y: 270, width: 45, height: 20 });
                    platforms.push({ x: 540, y: 220, width: 10, height: 20 });
                    platforms.push({ x: 590, y: 220, width: 10, height: 20 });
                    platforms.push({ x: 370, y: 180, width: 50, height: 20 });
                    platforms.push({ x: 480, y: 140, width: 50, height: 20 });
                    platforms.push({ x: 600, y: 180, width: 50, height: 20 });
                    platforms.push({ x: 700, y: 130, width: 55, height: 20 });
                    water.push({ x: 550, y: 221, width: 40, height: 19, collected: false });
                    movingPlatforms.push({ x: 210, y: 200, width: 48, height: 15, minX: 160, maxX: 270, vx: 3 });
                    movingPlatforms.push({ x: 420, y: 220, width: 48, height: 15, minY: 180, maxY: 280, vy: 2.5 });
                    movingPlatforms.push({ x: 620, y: 140, width: 48, height: 15, minX: 570, maxX: 680, vx: 3.5 });
                    movingPlatforms.push({ x: 150, y: 180, width: 45, height: 15, minY: 140, maxY: 220, vy: 3 });
                    movingPlatforms.push({ x: 330, y: 240, width: 45, height: 15, minX: 280, maxX: 380, vx: 3 });
                    movingPlatforms.push({ x: 560, y: 100, width: 45, height: 15, minX: 510, maxX: 610, vx: 3.5 });
                    springs.push({ x: 70, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 180, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 320, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 600, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 720, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 570, y: 205, width: 25, height: 15, compressed: false });
                    springs.push({ x: 390, y: 165, width: 25, height: 15, compressed: false });
                    portals.push({ x: 130, y: 220, width: 30, height: 40, targetX: 300, targetY: 240, color: '#9B59B6' });
                    portals.push({ x: 480, y: 230, width: 30, height: 40, targetX: 390, targetY: 140, color: '#E74C3C' });
                    portals.push({ x: 390, y: 140, width: 30, height: 40, targetX: 570, targetY: 180, color: '#3498DB' });
                    portals.push({ x: 620, y: 140, width: 30, height: 40, targetX: 720, targetY: 90, color: '#1ABC9C' });
                    portals.push({ x: 215, y: 280, width: 30, height: 40, targetX: 480, targetY: 230, color: '#F39C12' });
                    spikes.push({ x: 100, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 140, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 200, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 240, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 300, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 360, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 400, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 500, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 560, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 640, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 700, y: 445, width: 36, height: 15 });
                    lava.push({ x: 60, y: 475, width: 40, height: 25 });
                    lava.push({ x: 100, y: 475, width: 40, height: 25 });
                    lava.push({ x: 160, y: 475, width: 40, height: 25 });
                    lava.push({ x: 220, y: 475, width: 50, height: 25 });
                    lava.push({ x: 280, y: 475, width: 40, height: 25 });
                    lava.push({ x: 350, y: 475, width: 50, height: 25 });
                    lava.push({ x: 430, y: 475, width: 50, height: 25 });
                    lava.push({ x: 530, y: 475, width: 50, height: 25 });
                    lava.push({ x: 620, y: 475, width: 40, height: 25 });
                    lava.push({ x: 680, y: 475, width: 40, height: 25 });
                },
                // Level 7 - maze
                () => {
                    platforms.push({ x: 20, y: 420, width: 45, height: 20 });
                    platforms.push({ x: 100, y: 370, width: 42, height: 20 });
                    platforms.push({ x: 180, y: 420, width: 42, height: 20 });
                    platforms.push({ x: 260, y: 360, width: 42, height: 20 });
                    platforms.push({ x: 100, y: 300, width: 42, height: 20 });
                    platforms.push({ x: 190, y: 250, width: 42, height: 20 });
                    platforms.push({ x: 320, y: 300, width: 42, height: 20 });
                    platforms.push({ x: 410, y: 250, width: 42, height: 20 });
                    platforms.push({ x: 500, y: 310, width: 42, height: 20 });
                    platforms.push({ x: 590, y: 260, width: 42, height: 20 });
                    platforms.push({ x: 410, y: 180, width: 45, height: 20 });
                    platforms.push({ x: 510, y: 140, width: 45, height: 20 });
                    platforms.push({ x: 620, y: 180, width: 45, height: 20 });
                    platforms.push({ x: 710, y: 120, width: 55, height: 20 });
                    movingPlatforms.push({ x: 140, y: 200, width: 45, height: 15, minY: 160, maxY: 260, vy: 3 });
                    movingPlatforms.push({ x: 280, y: 200, width: 45, height: 15, minX: 240, maxX: 340, vx: 3.5 });
                    movingPlatforms.push({ x: 460, y: 200, width: 45, height: 15, minY: 160, maxY: 250, vy: 3.5 });
                    movingPlatforms.push({ x: 580, y: 150, width: 45, height: 15, minX: 530, maxX: 630, vx: 3.5 });
                    movingPlatforms.push({ x: 670, y: 160, width: 45, height: 15, minY: 120, maxY: 200, vy: 3 });
                    movingPlatforms.push({ x: 50, y: 350, width: 42, height: 15, minX: 20, maxX: 100, vx: 2.5 });
                    movingPlatforms.push({ x: 350, y: 220, width: 42, height: 15, minY: 180, maxY: 270, vy: 3.5 });
                    movingPlatforms.push({ x: 720, y: 80, width: 45, height: 15, minX: 680, maxX: 760, vx: 4 });
                    springs.push({ x: 65, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 140, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 230, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 340, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 440, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 540, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 640, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 730, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 610, y: 165, width: 22, height: 15, compressed: false });
                    springs.push({ x: 210, y: 235, width: 22, height: 15, compressed: false });
                    springs.push({ x: 430, y: 165, width: 22, height: 15, compressed: false });
                    portals.push({ x: 120, y: 260, width: 30, height: 40, targetX: 340, targetY: 260, color: '#9B59B6' });
                    portals.push({ x: 430, y: 210, width: 30, height: 40, targetX: 530, targetY: 270, color: '#E74C3C' });
                    portals.push({ x: 610, y: 220, width: 30, height: 40, targetX: 530, targetY: 100, color: '#3498DB' });
                    portals.push({ x: 640, y: 140, width: 30, height: 40, targetX: 430, targetY: 140, color: '#1ABC9C' });
                    portals.push({ x: 210, y: 210, width: 30, height: 40, targetX: 520, targetY: 270, color: '#F39C12' });
                    portals.push({ x: 340, y: 260, width: 30, height: 40, targetX: 610, targetY: 140, color: '#E91E63' });
                    portals.push({ x: 520, y: 100, width: 30, height: 40, targetX: 730, targetY: 80, color: '#00BCD4' });
                    spikes.push({ x: 80, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 120, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 180, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 240, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 300, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 360, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 420, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 480, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 540, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 600, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 660, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 720, y: 445, width: 36, height: 15 });
                    lava.push({ x: 50, y: 475, width: 35, height: 25 });
                    lava.push({ x: 90, y: 475, width: 35, height: 25 });
                    lava.push({ x: 150, y: 475, width: 40, height: 25 });
                    lava.push({ x: 210, y: 475, width: 40, height: 25 });
                    lava.push({ x: 260, y: 475, width: 40, height: 25 });
                    lava.push({ x: 320, y: 475, width: 40, height: 25 });
                    lava.push({ x: 380, y: 475, width: 40, height: 25 });
                    lava.push({ x: 450, y: 475, width: 40, height: 25 });
                    lava.push({ x: 510, y: 475, width: 40, height: 25 });
                    lava.push({ x: 570, y: 475, width: 40, height: 25 });
                    lava.push({ x: 630, y: 475, width: 40, height: 25 });
                    lava.push({ x: 700, y: 475, width: 40, height: 25 });
                },
                // Level 8 - precision
                () => {
                    platforms.push({ x: 15, y: 420, width: 40, height: 20 });
                    platforms.push({ x: 90, y: 380, width: 38, height: 20 });
                    platforms.push({ x: 165, y: 340, width: 38, height: 20 });
                    platforms.push({ x: 90, y: 290, width: 38, height: 20 });
                    platforms.push({ x: 165, y: 240, width: 38, height: 20 });
                    platforms.push({ x: 250, y: 290, width: 38, height: 20 });
                    platforms.push({ x: 335, y: 340, width: 38, height: 20 });
                    platforms.push({ x: 420, y: 290, width: 38, height: 20 });
                    platforms.push({ x: 500, y: 240, width: 10, height: 20 });
                    platforms.push({ x: 550, y: 240, width: 10, height: 20 });
                    water.push({ x: 510, y: 241, width: 40, height: 19, collected: false });
                    platforms.push({ x: 420, y: 180, width: 38, height: 20 });
                    platforms.push({ x: 335, y: 130, width: 38, height: 20 });
                    platforms.push({ x: 505, y: 130, width: 38, height: 20 });
                    platforms.push({ x: 590, y: 180, width: 38, height: 20 });
                    platforms.push({ x: 670, y: 130, width: 42, height: 20 });
                    platforms.push({ x: 730, y: 90, width: 50, height: 20 });
                    movingPlatforms.push({ x: 220, y: 180, width: 42, height: 15, minX: 180, maxX: 280, vx: 4 });
                    movingPlatforms.push({ x: 360, y: 200, width: 42, height: 15, minY: 160, maxY: 260, vy: 3.5 });
                    movingPlatforms.push({ x: 570, y: 120, width: 42, height: 15, minX: 520, maxX: 620, vx: 4 });
                    movingPlatforms.push({ x: 640, y: 160, width: 42, height: 15, minY: 120, maxY: 200, vy: 4 });
                    movingPlatforms.push({ x: 700, y: 120, width: 42, height: 15, minX: 650, maxX: 740, vx: 4.5 });
                    movingPlatforms.push({ x: 50, y: 350, width: 40, height: 15, minX: 20, maxX: 100, vx: 3 });
                    movingPlatforms.push({ x: 280, y: 220, width: 40, height: 15, minY: 180, maxY: 270, vy: 4 });
                    movingPlatforms.push({ x: 460, y: 100, width: 40, height: 15, minX: 420, maxX: 520, vx: 4.5 });
                    movingPlatforms.push({ x: 750, y: 50, width: 40, height: 15, minY: 40, maxY: 90, vy: 3 });
                    springs.push({ x: 55, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 130, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 200, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 280, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 380, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 470, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 550, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 630, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 700, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 610, y: 165, width: 20, height: 15, compressed: false });
                    springs.push({ x: 440, y: 165, width: 20, height: 15, compressed: false });
                    springs.push({ x: 185, y: 225, width: 20, height: 15, compressed: false });
                    portals.push({ x: 110, y: 250, width: 30, height: 40, targetX: 270, targetY: 250, color: '#9B59B6' });
                    portals.push({ x: 355, y: 90, width: 30, height: 40, targetX: 525, targetY: 200, color: '#E74C3C' });
                    portals.push({ x: 440, y: 140, width: 30, height: 40, targetX: 610, targetY: 140, color: '#3498DB' });
                    portals.push({ x: 690, y: 90, width: 30, height: 40, targetX: 525, targetY: 90, color: '#1ABC9C' });
                    portals.push({ x: 185, y: 200, width: 30, height: 40, targetX: 440, targetY: 250, color: '#F39C12' });
                    portals.push({ x: 270, y: 250, width: 30, height: 40, targetX: 355, targetY: 300, color: '#E91E63' });
                    portals.push({ x: 525, y: 90, width: 30, height: 40, targetX: 690, targetY: 90, color: '#00BCD4' });
                    portals.push({ x: 610, y: 140, width: 30, height: 40, targetX: 750, targetY: 50, color: '#9C27B0' });
                    spikes.push({ x: 70, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 110, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 160, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 220, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 260, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 320, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 360, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 420, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 480, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 540, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 600, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 660, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 720, y: 445, width: 36, height: 15 });
                    lava.push({ x: 40, y: 475, width: 35, height: 25 });
                    lava.push({ x: 80, y: 475, width: 35, height: 25 });
                    lava.push({ x: 140, y: 475, width: 35, height: 25 });
                    lava.push({ x: 190, y: 475, width: 35, height: 25 });
                    lava.push({ x: 240, y: 475, width: 35, height: 25 });
                    lava.push({ x: 290, y: 475, width: 35, height: 25 });
                    lava.push({ x: 350, y: 475, width: 35, height: 25 });
                    lava.push({ x: 400, y: 475, width: 35, height: 25 });
                    lava.push({ x: 450, y: 475, width: 35, height: 25 });
                    lava.push({ x: 510, y: 475, width: 35, height: 25 });
                    lava.push({ x: 560, y: 475, width: 35, height: 25 });
                    lava.push({ x: 620, y: 475, width: 35, height: 25 });
                    lava.push({ x: 680, y: 475, width: 35, height: 25 });
                },
                // Level 9 - hard mode
                () => {
                    platforms.push({ x: 10, y: 430, width: 38, height: 20 });
                    platforms.push({ x: 85, y: 390, width: 35, height: 20 });
                    platforms.push({ x: 160, y: 350, width: 35, height: 20 });
                    platforms.push({ x: 85, y: 300, width: 35, height: 20 });
                    platforms.push({ x: 160, y: 250, width: 35, height: 20 });
                    platforms.push({ x: 240, y: 300, width: 35, height: 20 });
                    platforms.push({ x: 320, y: 250, width: 35, height: 20 });
                    platforms.push({ x: 400, y: 300, width: 35, height: 20 });
                    platforms.push({ x: 480, y: 250, width: 35, height: 20 });
                    platforms.push({ x: 560, y: 200, width: 35, height: 20 });
                    platforms.push({ x: 400, y: 170, width: 35, height: 20 });
                    platforms.push({ x: 320, y: 120, width: 35, height: 20 });
                    platforms.push({ x: 480, y: 120, width: 35, height: 20 });
                    platforms.push({ x: 640, y: 150, width: 35, height: 20 });
                    platforms.push({ x: 720, y: 200, width: 35, height: 20 });
                    platforms.push({ x: 640, y: 100, width: 38, height: 20 });
                    platforms.push({ x: 750, y: 70, width: 45, height: 20 });
                    movingPlatforms.push({ x: 200, y: 190, width: 38, height: 15, minX: 150, maxX: 260, vx: 4.5 });
                    movingPlatforms.push({ x: 280, y: 180, width: 38, height: 15, minY: 140, maxY: 220, vy: 4.5 });
                    movingPlatforms.push({ x: 420, y: 80, width: 38, height: 15, minX: 360, maxX: 500, vx: 5 });
                    movingPlatforms.push({ x: 560, y: 130, width: 38, height: 15, minY: 90, maxY: 170, vy: 4.5 });
                    movingPlatforms.push({ x: 700, y: 100, width: 38, height: 15, minX: 650, maxX: 760, vx: 5 });
                    movingPlatforms.push({ x: 50, y: 340, width: 35, height: 15, minX: 20, maxX: 100, vx: 4 });
                    movingPlatforms.push({ x: 350, y: 200, width: 35, height: 15, minY: 150, maxY: 250, vy: 5 });
                    movingPlatforms.push({ x: 600, y: 50, width: 35, height: 15, minX: 550, maxX: 660, vx: 5.5 });
                    springs.push({ x: 50, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 120, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 200, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 280, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 360, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 440, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 520, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 600, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 660, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 740, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 580, y: 185, width: 18, height: 15, compressed: false });
                    springs.push({ x: 740, y: 185, width: 18, height: 15, compressed: false });
                    springs.push({ x: 420, y: 155, width: 18, height: 15, compressed: false });
                    springs.push({ x: 180, y: 235, width: 18, height: 15, compressed: false });
                    portals.push({ x: 105, y: 260, width: 30, height: 40, targetX: 260, targetY: 260, color: '#9B59B6' });
                    portals.push({ x: 180, y: 210, width: 30, height: 40, targetX: 420, targetY: 260, color: '#E74C3C' });
                    portals.push({ x: 340, y: 80, width: 30, height: 40, targetX: 580, targetY: 160, color: '#3498DB' });
                    portals.push({ x: 500, y: 80, width: 30, height: 40, targetX: 660, targetY: 160, color: '#1ABC9C' });
                    portals.push({ x: 660, y: 60, width: 30, height: 40, targetX: 770, targetY: 30, color: '#F39C12' });
                    portals.push({ x: 260, y: 260, width: 30, height: 40, targetX: 340, targetY: 210, color: '#E91E63' });
                    portals.push({ x: 420, y: 260, width: 30, height: 40, targetX: 500, targetY: 210, color: '#00BCD4' });
                    portals.push({ x: 660, y: 110, width: 30, height: 40, targetX: 770, targetY: 30, color: '#9C27B0' });
                    spikes.push({ x: 60, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 100, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 160, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 220, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 260, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 320, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 380, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 420, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 480, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 540, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 580, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 640, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 700, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 760, y: 445, width: 36, height: 15 });
                    lava.push({ x: 40, y: 475, width: 35, height: 25 });
                    lava.push({ x: 80, y: 475, width: 35, height: 25 });
                    lava.push({ x: 130, y: 475, width: 35, height: 25 });
                    lava.push({ x: 180, y: 475, width: 35, height: 25 });
                    lava.push({ x: 240, y: 475, width: 35, height: 25 });
                    lava.push({ x: 290, y: 475, width: 35, height: 25 });
                    lava.push({ x: 350, y: 475, width: 35, height: 25 });
                    lava.push({ x: 410, y: 475, width: 35, height: 25 });
                    lava.push({ x: 460, y: 475, width: 35, height: 25 });
                    lava.push({ x: 510, y: 475, width: 35, height: 25 });
                    lava.push({ x: 570, y: 475, width: 35, height: 25 });
                    lava.push({ x: 620, y: 475, width: 35, height: 25 });
                    lava.push({ x: 680, y: 475, width: 35, height: 25 });
                    lava.push({ x: 730, y: 475, width: 35, height: 25 });
                }
            ];

            // Use preset layouts for levels 1-9, procedural for 10+
            if (lvl <= layouts.length) {
                layouts[lvl - 1]();
            } else {
                // Procedural generation for levels 10-50
                generateProceduralLevel(lvl);
            }

            // Add drones for levels 20+
            if (lvl >= 20) {
                const droneCount = Math.min(Math.floor((lvl - 19) / 3) + 1, 5);
                for (let i = 0; i < droneCount; i++) {
                    const dx = 150 + Math.random() * 500;
                    const dy = 80 + Math.random() * 200;
                    drones.push({
                        x: dx, y: dy, width: 40, height: 25,
                        startX: dx, patrolRange: 100 + Math.random() * 100,
                        direction: 1, speed: 1.5 + lvl * 0.05,
                        fireTimer: 60 + Math.floor(Math.random() * 60),
                        fireRate: Math.max(90 - lvl, 40)
                    });
                }
            }

            // Add coins
            platforms.forEach((p, i) => {
                if (!p.isGround && Math.random() > 0.4) {
                    coins.push({ x: p.x + p.width / 2 - 10, y: p.y - 30, width: 20, height: 20, collected: false, bobOffset: Math.random() * Math.PI * 2 });
                }
            });

            // Flag position - on the highest/hardest platform
            const flagPositions = [
                { x: 720, y: 80 },   // L1
                { x: 720, y: 60 },   // L2
                { x: 740, y: 60 },   // L3
                { x: 720, y: 50 },   // L4
                { x: 740, y: 40 },   // L5
                { x: 700, y: 70 },   // L6
                { x: 710, y: 60 },   // L7
                { x: 730, y: 30 },   // L8
                { x: 755, y: 10 }    // L9
            ];
            let flagPos;
            if (lvl <= 9) {
                flagPos = flagPositions[lvl - 1];
            } else if (lvl >= 20) {
                // Drone levels - flag on the simple final platform
                flagPos = { x: 735, y: 60 };
            } else {
                // Levels 10-19
                flagPos = { x: 735, y: 40 };
            }
            flag = { x: flagPos.x, y: flagPos.y, width: 20, height: 60 };

            // Reset player
            player.x = 50; player.y = 410; player.vx = 0; player.vy = 0;
            player.onGround = false; invincible = 0;
        }

        function generateProceduralLevel(lvl) {
            const seed = lvl * 12345;
            let randCounter = 0;
            const seededRandom = () => {
                randCounter++;
                const x = Math.sin(seed + randCounter) * 10000;
                return x - Math.floor(x);
            };

            // For drone levels (20+), make terrain very simple
            if (lvl >= 20) {
                // Simple terrain - just 3 platforms to reach the flag
                platforms.push({ x: 50, y: 350, width: 150, height: 20 });
                platforms.push({ x: 400, y: 250, width: 150, height: 20 });
                platforms.push({ x: 700, y: 150, width: 90, height: 20 });

                // One portal to help navigate while dodging drones
                portals.push({ x: 100, y: 310, width: 30, height: 40, targetX: 420, targetY: 210, color: '#9B59B6' });

                // One spring to help
                springs.push({ x: 300, y: 440, width: 30, height: 20, compressed: false });

                return;
            }

            // Levels 10-19: moderate complexity
            const difficulty = Math.min((lvl - 9) / 10, 1);
            const platformSize = 60 - difficulty * 8;
            const numPlatforms = 8 + Math.floor(difficulty * 4);

            // Generate platforms as a reachable staircase path
            // Scale steps to fit within the canvas (target x: 50 -> 660, y: 400 -> 120)
            const totalXRange = 610;
            const totalYRange = 280;
            const baseStepX = totalXRange / numPlatforms;
            const baseStepY = totalYRange / numPlatforms;

            let prevX = 50, prevY = 400;
            for (let i = 0; i < numPlatforms; i++) {
                const variation = (seededRandom() - 0.5) * 0.4;
                const newX = prevX + baseStepX * (1 + variation);
                const newY = prevY - baseStepY * (0.8 + seededRandom() * 0.4);
                const clampedX = Math.max(10, Math.min(660, newX));
                const clampedY = Math.max(100, Math.min(420, newY));
                const width = platformSize + seededRandom() * 15;

                if (seededRandom() > 0.3) {
                    platforms.push({ x: clampedX, y: clampedY, width: width, height: 20 });
                } else {
                    const isHorizontal = seededRandom() > 0.5;
                    if (isHorizontal) {
                        movingPlatforms.push({
                            x: clampedX, y: clampedY, width: width - 5, height: 15,
                            minX: Math.max(10, clampedX - 30), maxX: Math.min(750, clampedX + 30),
                            vx: 1.5 + difficulty * (seededRandom() > 0.5 ? 1 : -1)
                        });
                    } else {
                        movingPlatforms.push({
                            x: clampedX, y: clampedY, width: width - 5, height: 15,
                            minY: Math.max(60, clampedY - 25), maxY: Math.min(400, clampedY + 25),
                            vy: 1.5 + difficulty * (seededRandom() > 0.5 ? 1 : -1)
                        });
                    }
                }
                prevX = clampedX;
                prevY = clampedY;
            }

            // Add final platform for flag
            platforms.push({ x: 720, y: 100, width: 60, height: 20 });
            // Bridge platform if path ends far from flag
            if (prevX < 620 || prevY > 200) {
                platforms.push({ x: 620, y: 160, width: 55, height: 20 });
            }

            // Spikes
            const numSpikes = 4 + Math.floor(difficulty * 4);
            for (let i = 0; i < numSpikes; i++) {
                const sx = 100 + (i * (600 / numSpikes)) + seededRandom() * 40;
                spikes.push({ x: sx, y: 445, width: 36, height: 15 });
            }

            // Lava
            const numLava = 3 + Math.floor(difficulty * 4);
            for (let i = 0; i < numLava; i++) {
                const lx = 80 + (i * (620 / numLava)) + seededRandom() * 30;
                lava.push({ x: lx, y: 475, width: 40, height: 25 });
            }

            // Rare water pool in a platform
            if (seededRandom() > 0.6) {
                const staticPlats = platforms.filter(p => !p.isGround && p.width >= 50);
                if (staticPlats.length > 0) {
                    const wp = staticPlats[Math.floor(seededRandom() * staticPlats.length)];
                    const origX = wp.x, origW = wp.width, origY = wp.y, origH = wp.height;
                    wp.width = 10;
                    platforms.push({ x: origX + origW - 10, y: origY, width: 10, height: origH });
                    water.push({ x: origX + 10, y: origY + 1, width: origW - 20, height: origH - 1, collected: false });
                }
            }

            // Springs
            const numSprings = 3 + Math.floor(difficulty * 3);
            for (let i = 0; i < numSprings; i++) {
                const springX = 80 + seededRandom() * 640;
                springs.push({ x: springX, y: 440, width: 28, height: 20, compressed: false });
            }

            // Portals
            const numPortals = 2 + Math.floor(difficulty * 2);
            const portalColors = ['#9B59B6', '#E74C3C', '#3498DB', '#1ABC9C'];
            for (let i = 0; i < numPortals; i++) {
                const px = 100 + seededRandom() * 550;
                const py = 120 + seededRandom() * 220;
                const tx = 100 + seededRandom() * 550;
                const ty = 100 + seededRandom() * 240;
                portals.push({
                    x: px, y: py, width: 30, height: 40,
                    targetX: tx, targetY: ty,
                    color: portalColors[i % portalColors.length]
                });
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({ x, y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 1, color, size: 2 + Math.random() * 3 });
            }
        }

        function rectCollision(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }

        function update(dt) {
            if (!gameRunning || gamePaused || tutorialPaused) return;
            if (invincible > 0) invincible -= dt;

            // Input
            if (keys['ArrowLeft'] || keys['KeyA']) { player.vx = -player.speed; player.facing = -1; }
            else if (keys['ArrowRight'] || keys['KeyD']) { player.vx = player.speed; player.facing = 1; }
            else { player.vx *= Math.pow(friction, dt); }

            if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.onGround) {
                player.vy = player.jumpPower;
                player.onGround = false;
            }

            player.vy += gravity * dt;
            if (player.vy > 15) player.vy = 15;

            // Horizontal movement & collision
            player.x += player.vx * dt;
            const allPlatforms = [...platforms, ...movingPlatforms];
            for (const p of allPlatforms) {
                if (rectCollision(player, p)) {
                    if (player.vx > 0) player.x = p.x - player.width;
                    else if (player.vx < 0) player.x = p.x + p.width;
                    player.vx = 0;
                }
            }

            // Vertical movement & collision
            const prevOnGround = player.onGround;
            player.y += player.vy * dt;
            player.onGround = false;
            let landedPlatform = null;
            for (const p of allPlatforms) {
                if (rectCollision(player, p)) {
                    if (player.vy > 0) {
                        player.y = p.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                        landedPlatform = p;
                        if (p.vx) player.x += p.vx * dt;
                    } else if (player.vy < 0) {
                        player.y = p.y + p.height;
                        player.vy = 0;
                    }
                }
            }

            // Show word popup when landing on a platform (not ground)
            if (!prevOnGround && player.onGround && landedPlatform && !landedPlatform.isGround) {
                showWordPopup();
                return;
            }

            // Update moving platforms
            movingPlatforms.forEach(mp => {
                if (mp.vx !== undefined) { mp.x += mp.vx * dt; if (mp.x <= mp.minX || mp.x >= mp.maxX) mp.vx *= -1; }
                if (mp.vy !== undefined) { mp.y += mp.vy * dt; if (mp.y <= mp.minY || mp.y >= mp.maxY) mp.vy *= -1; }
            });

            // Screen bounds
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;

            // Fall death
            if (player.y > canvas.height && invincible <= 0) { loseLife(); return; }

            // Spike collision
            if (invincible <= 0) {
                for (const spike of spikes) {
                    if (rectCollision(player, spike)) { loseLife(); return; }
                }
            }

            // Lava collision
            if (invincible <= 0) {
                for (const l of lava) {
                    if (rectCollision(player, l)) { loseLife(); return; }
                }
            }

            // Water - heals 1 life (one-time use)
            water.forEach(w => {
                if (!w.collected && rectCollision(player, w)) {
                    w.collected = true;
                    lives++; livesEl.textContent = lives;
                    createParticles(w.x + w.width / 2, w.y, '#64B5F6', 12);
                    createParticles(w.x + w.width / 2, w.y, '#BBDEFB', 8);
                }
            });

            // Spring collision
            springs.forEach(spring => {
                if (rectCollision(player, spring) && player.vy > 0) {
                    player.vy = -18; // Super jump!
                    spring.compressed = true;
                    setTimeout(() => spring.compressed = false, 200);
                    createParticles(spring.x + 15, spring.y, colors.spring, 5);
                }
            });

            // Portal collision
            portals.forEach(portal => {
                if (rectCollision(player, portal)) {
                    if (!player.portalCooldown) {
                        player.x = portal.targetX;
                        player.y = portal.targetY;
                        player.portalCooldown = true;
                        createParticles(portal.x + 15, portal.y + 20, portal.color, 10);
                        createParticles(portal.targetX + 15, portal.targetY + 20, portal.color, 10);
                    }
                }
            });
            // Clear portal cooldown once the player isn't touching any portal
            if (!portals.some(p => rectCollision(player, p))) {
                player.portalCooldown = false;
            }

            // Coin collection
            coins.forEach(coin => {
                if (!coin.collected && rectCollision(player, coin)) {
                    coin.collected = true;
                    score += 10;
                    scoreEl.textContent = score;
                    createParticles(coin.x + 10, coin.y + 10, colors.coin, 8);
                }
            });

            // Flag collision - instant next level
            if (!levelComplete && rectCollision(player, flag)) {
                levelComplete = true;
                if (level >= 50) {
                    // Victory!
                    score += 500;
                    scoreEl.textContent = score;
                    gameRunning = false;
                    showMessage('YOU WIN! Final Score: ' + score + ' - Press R', '#FFD700');
                } else {
                    // Lives bonus after level 8
                    let bonusLives = 0;
                    if (level >= 8) {
                        bonusLives = Math.max(0, 4 - deathsThisLevel);
                        lives += bonusLives;
                        livesEl.textContent = lives;
                    }
                    level++;
                    levelEl.textContent = level;
                    score += 50;
                    scoreEl.textContent = score;
                    deathsThisLevel = 0;
                    generateLevel(level);
                    let msg = 'Level ' + level;
                    if (level >= 20) msg += ' - DRONES!';
                    if (bonusLives > 0) msg += ' (+' + bonusLives + ' lives)';
                    showMessage(msg, '#22C55E');
                    setTimeout(() => {
                        hideMessage();
                        showLevelTutorials();
                    }, 1500);
                }
            }

            // Update drones
            drones.forEach(drone => {
                // Patrol movement
                drone.x += drone.speed * drone.direction * dt;
                if (drone.x <= drone.startX - drone.patrolRange || drone.x >= drone.startX + drone.patrolRange) {
                    drone.direction *= -1;
                }

                // Fire lasers
                drone.fireTimer -= dt;
                if (drone.fireTimer <= 0) {
                    drone.fireTimer = drone.fireRate;
                    // Shoot laser downward toward player
                    const angle = Math.atan2(player.y - drone.y, player.x - drone.x);
                    lasers.push({
                        x: drone.x + drone.width / 2,
                        y: drone.y + drone.height,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        life: 120
                    });
                    createParticles(drone.x + drone.width / 2, drone.y + drone.height, colors.laser, 3);
                }
            });

            // Update lasers
            lasers = lasers.filter(laser => {
                laser.x += laser.vx * dt;
                laser.y += laser.vy * dt;
                laser.life -= dt;

                // Laser collision with player
                if (invincible <= 0) {
                    const laserRect = { x: laser.x - 5, y: laser.y - 5, width: 10, height: 10 };
                    if (rectCollision(player, laserRect)) {
                        loseLife();
                        return false;
                    }
                }

                return laser.life > 0 && laser.x > 0 && laser.x < 800 && laser.y > 0 && laser.y < 500;
            });

            // Animation
            if (Math.abs(player.vx) > 0.5) player.animFrame += 0.15 * dt;

            // Clouds
            clouds.forEach(c => { c.x += c.speed * dt; if (c.x > 850) c.x = -80; });

            // Particles
            particles = particles.filter(p => {
                p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 0.15 * dt; p.life -= 0.025 * dt;
                return p.life > 0;
            });

            globalTime++;

            // Update screen shake
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= Math.pow(0.85, dt);
                if (screenShake.intensity < 0.3) { screenShake.intensity = 0; screenShake.x = 0; screenShake.y = 0; }
            }

            // Player trail
            if (Math.abs(player.vx) > 2.5 || Math.abs(player.vy) > 3) {
                playerTrail.push({ x: player.x + player.width / 2, y: player.y + player.height / 2, life: 1, size: player.width * 0.4 });
                if (playerTrail.length > 8) playerTrail.shift();
            }
            playerTrail.forEach(tr => { tr.life -= 0.12 * dt; });
            playerTrail = playerTrail.filter(tr => tr.life > 0);

            // Update ambient particles
            ambientParticles.forEach(ap => {
                ap.angle += ap.angleSpeed * dt;
                ap.x += Math.cos(ap.angle) * ap.speed * dt;
                ap.y += (Math.sin(ap.angle) * ap.speed * 0.5 - 0.05) * dt;
                ap.brightness += ap.brightnessDir * 0.02 * dt;
                if (ap.brightness > 1) { ap.brightness = 1; ap.brightnessDir = -1; }
                if (ap.brightness < 0) { ap.brightness = 0; ap.brightnessDir = 1; }
                if (ap.x > 810) ap.x = -10;
                if (ap.x < -10) ap.x = 810;
                if (ap.y < 0) ap.y = 490;
                if (ap.y > 490) ap.y = 0;
            });

            // Emit lava embers
            if (lava.length > 0 && globalTime % 4 === 0) {
                const src = lava[Math.floor(Math.random() * lava.length)];
                lavaEmbers.push({ x: src.x + Math.random() * src.width, y: src.y, vx: (Math.random() - 0.5) * 1.5, vy: -1.5 - Math.random() * 2, life: 1, size: 1.5 + Math.random() * 2 });
            }
            lavaEmbers = lavaEmbers.filter(e => { e.x += e.vx * dt; e.y += e.vy * dt; e.vy += 0.08 * dt; e.life -= 0.025 * dt; return e.life > 0; });
            if (lavaEmbers.length > 40) lavaEmbers.splice(0, lavaEmbers.length - 40);
        }

        function loseLife() {
            if (invincible > 0) return;
            lives--;
            deathsThisLevel++;
            livesEl.textContent = lives;
            createParticles(player.x + 15, player.y + 18, colors.player, 15);
            screenShake.intensity = 10;
            if (lives <= 0) {
                gameRunning = false;
                showMessage('Game Over! Press R to restart', '#DC2626');
            } else {
                player.x = 50; player.y = 410; player.vx = 0; player.vy = 0;
                invincible = 90;
            }
        }

        function showMessage(text, color) { messageEl.textContent = text; messageEl.style.color = color; messageEl.style.display = 'block'; }
        function hideMessage() { messageEl.style.display = 'none'; }

        function getSaves() {
            var data = localStorage.getItem('platformerSaves');
            return data ? JSON.parse(data) : {};
        }

        function setSaves(saves) {
            localStorage.setItem('platformerSaves', JSON.stringify(saves));
        }

        // Migrate old single save to new format
        (function migrateSave() {
            var old = localStorage.getItem('platformerSave');
            if (old) {
                var saves = getSaves();
                if (!saves['Auto Save']) {
                    saves['Auto Save'] = JSON.parse(old);
                    saves['Auto Save'].savedAt = Date.now();
                    setSaves(saves);
                }
                localStorage.removeItem('platformerSave');
            }
        })();

        let savePopupMode = 'load'; // 'load' or 'save'

        function renderSaveList() {
            var saves = getSaves();
            var list = document.getElementById('saveList');
            var keys = Object.keys(saves);
            if (keys.length === 0) {
                list.innerHTML = '<div class="save-empty">No saves yet</div>';
                return;
            }
            keys.sort(function(a, b) { return (saves[b].savedAt || 0) - (saves[a].savedAt || 0); });
            list.innerHTML = '';
            keys.forEach(function(name) {
                var s = saves[name];
                var item = document.createElement('div');
                item.className = 'save-item';
                var date = s.savedAt ? new Date(s.savedAt).toLocaleString() : 'Unknown date';
                var patterns = (s.selectedPatterns || []).join(', ') || 'N/A';
                item.innerHTML =
                    '<div class="save-info">' +
                        '<div class="save-name">' + name.replace(/</g, '&lt;') + '</div>' +
                        '<div class="save-details">Level ' + s.level + ' | Score ' + s.score + ' | ' + date + '</div>' +
                        '<div class="save-details">' + patterns + '</div>' +
                    '</div>' +
                    '<button class="save-delete" data-name="' + name.replace(/"/g, '&quot;') + '">Delete</button>';
                item.querySelector('.save-info').addEventListener('click', function() {
                    if (savePopupMode === 'load') {
                        loadSaveByName(name);
                    } else {
                        overwriteSave(name);
                    }
                });
                item.querySelector('.save-delete').addEventListener('click', function(e) {
                    e.stopPropagation();
                    deleteSave(name);
                });
                list.appendChild(item);
            });
        }

        function saveGame() {
            savePopupMode = 'save';
            document.getElementById('savePopupTitle').textContent = 'Save Game';
            document.getElementById('savePopupSubtitle').textContent = 'Create a new save or overwrite an existing one';
            document.getElementById('savePopupNewBtn').style.display = '';
            renderSaveList();
            document.getElementById('savePopup').style.display = 'flex';
            gamePaused = true;
        }

        function loadGame() {
            savePopupMode = 'load';
            document.getElementById('savePopupTitle').textContent = 'Load Game';
            document.getElementById('savePopupSubtitle').textContent = 'Choose a save to load';
            document.getElementById('savePopupNewBtn').style.display = 'none';
            renderSaveList();
            document.getElementById('savePopup').style.display = 'flex';
            gamePaused = true;
        }

        function closeSavePopup() {
            document.getElementById('savePopup').style.display = 'none';
            if (selectedWords.length > 0) gamePaused = false;
        }

        function showSaveNamePopup() {
            var nameInput = document.getElementById('saveNameInput');
            var playerName = document.getElementById('playerNameInput').value.trim();
            nameInput.value = playerName ? playerName + ' - Level ' + level : 'Level ' + level;
            document.getElementById('saveNamePopup').style.display = 'flex';
            nameInput.focus();
            nameInput.select();
        }

        function closeSaveNamePopup() {
            document.getElementById('saveNamePopup').style.display = 'none';
        }

        function makeSaveData() {
            return {
                score: score, level: level, lives: lives,
                correctCount: correctCount, incorrectCount: incorrectCount,
                selectedPatterns: selectedPatterns, selectedWords: selectedWords,
                deathsThisLevel: deathsThisLevel, tutorialShown: tutorialShown, savedAt: Date.now()
            };
        }

        function confirmSave() {
            var name = document.getElementById('saveNameInput').value.trim();
            if (!name) { alert('Please enter a name.'); return; }
            var saves = getSaves();
            saves[name] = makeSaveData();
            setSaves(saves);
            closeSaveNamePopup();
            closeSavePopup();
            showMessage('Game Saved!', '#5D9E3C');
            setTimeout(hideMessage, 1000);
        }

        function overwriteSave(name) {
            if (!confirm('Overwrite "' + name + '"?')) return;
            var saves = getSaves();
            saves[name] = makeSaveData();
            setSaves(saves);
            closeSavePopup();
            showMessage('Save overwritten!', '#5D9E3C');
            setTimeout(hideMessage, 1000);
        }

        function deleteSave(name) {
            if (!confirm('Delete "' + name + '"?')) return;
            var saves = getSaves();
            delete saves[name];
            setSaves(saves);
            renderSaveList();
        }

        function loadSaveByName(name) {
            var saves = getSaves();
            var save = saves[name];
            if (!save) return;
            score = save.score; level = save.level; lives = save.lives;
            correctCount = save.correctCount; incorrectCount = save.incorrectCount;
            selectedPatterns = save.selectedPatterns; selectedWords = save.selectedWords;
            deathsThisLevel = save.deathsThisLevel || 0;
            tutorialShown = save.tutorialShown || {};
            activeTutorials = []; tutorialPaused = false;
            usedWords = [];
            scoreEl.textContent = score; levelEl.textContent = level; livesEl.textContent = lives;
            document.getElementById('correctCount').textContent = correctCount;
            document.getElementById('incorrectCount').textContent = incorrectCount;
            gameRunning = true; gamePaused = false; invincible = 0;
            document.getElementById('startPopup').style.display = 'none';
            document.getElementById('greetPopup').style.display = 'none';
            document.getElementById('wordPopup').style.display = 'none';
            document.getElementById('savePopup').style.display = 'none';
            hideMessage();
            generateLevel(level);
            showMessage('Loaded: ' + name, '#5D9E3C');
            setTimeout(hideMessage, 1500);
        }

        // Enter key in save name input
        document.getElementById('saveNameInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') confirmSave();
        });

        function restart() {
            score = 0; level = 1; lives = 10; deathsThisLevel = 0;
            correctCount = 0; incorrectCount = 0; usedWords = [];
            tutorialShown = {}; activeTutorials = []; tutorialPaused = false;
            scoreEl.textContent = score; levelEl.textContent = level; livesEl.textContent = lives;
            document.getElementById('correctCount').textContent = 0;
            document.getElementById('incorrectCount').textContent = 0;
            gameRunning = true; invincible = 0; gamePaused = true; hideMessage(); generateLevel(1);
            selectedPatterns = [];
            document.getElementById('startPopup').style.display = 'flex';
            document.getElementById('sylSection').style.display = 'none';
            document.querySelectorAll('.pattern-buttons button').forEach(function(b) { b.classList.remove('selected'); });
        }

        // ===================== DRAW =====================
        function draw() {
            const t = globalTime * 0.016; // smooth time in seconds-ish

            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            // --- 1. REALISTIC SKY ---
            const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGrad.addColorStop(0, '#6DD0F5');
            skyGrad.addColorStop(0.2, '#8EDEF5');
            skyGrad.addColorStop(0.45, '#B0E8F8');
            skyGrad.addColorStop(0.65, '#D0F0FA');
            skyGrad.addColorStop(0.8, '#E8F6FC');
            skyGrad.addColorStop(1, '#F5FBF0');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Atmospheric haze near horizon
            const hazeGrad = ctx.createLinearGradient(0, 280, 0, 460);
            hazeGrad.addColorStop(0, 'rgba(210,230,245,0)');
            hazeGrad.addColorStop(0.5, 'rgba(210,230,245,0.08)');
            hazeGrad.addColorStop(1, 'rgba(220,238,220,0.15)');
            ctx.fillStyle = hazeGrad;
            ctx.fillRect(0, 280, 800, 180);

            // Warm sun-side glow on right side of sky
            const warmGlow = ctx.createRadialGradient(750, 100, 30, 700, 150, 350);
            warmGlow.addColorStop(0, 'rgba(255,245,210,0.08)');
            warmGlow.addColorStop(1, 'rgba(255,240,200,0)');
            ctx.fillStyle = warmGlow;
            ctx.fillRect(400, 0, 400, 350);

            // --- 2. SUN WITH RAYS ---
            const sunX = 700, sunY = 65;
            // Outer atmospheric glow
            const flareGrad2 = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 160);
            flareGrad2.addColorStop(0, 'rgba(255,250,210,0.3)');
            flareGrad2.addColorStop(0.4, 'rgba(255,240,180,0.1)');
            flareGrad2.addColorStop(1, 'rgba(255,240,180,0)');
            ctx.fillStyle = flareGrad2;
            ctx.beginPath(); ctx.arc(sunX, sunY, 160, 0, Math.PI * 2); ctx.fill();

            // Inner flare
            const flareGrad = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, 80);
            flareGrad.addColorStop(0, 'rgba(255,255,240,0.6)');
            flareGrad.addColorStop(0.5, 'rgba(255,245,150,0.2)');
            flareGrad.addColorStop(1, 'rgba(255,240,120,0)');
            ctx.fillStyle = flareGrad;
            ctx.beginPath(); ctx.arc(sunX, sunY, 80, 0, Math.PI * 2); ctx.fill();

            // Soft rotating rays
            ctx.save();
            ctx.translate(sunX, sunY);
            ctx.rotate(t * 0.08);
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const len = 55 + (i % 2) * 25 + (i % 3) * 10;
                ctx.strokeStyle = i % 2 === 0 ? '#ffe87a' : '#fff4b0';
                ctx.lineWidth = 2.5 - (i % 2) * 0.8;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();

            // Sun body with realistic glow
            const sunBodyGrad = ctx.createRadialGradient(sunX - 4, sunY - 4, 2, sunX, sunY, 36);
            sunBodyGrad.addColorStop(0, '#FFFFF0');
            sunBodyGrad.addColorStop(0.3, '#FFF8D0');
            sunBodyGrad.addColorStop(0.7, '#FFE44D');
            sunBodyGrad.addColorStop(1, '#F0A030');
            ctx.fillStyle = sunBodyGrad;
            ctx.beginPath(); ctx.arc(sunX, sunY, 36, 0, Math.PI * 2); ctx.fill();

            // --- 3. FAR MOUNTAIN RANGE (atmospheric perspective - faded, blue-tinted) ---
            const mParallax0 = (t * 4) % 800;
            for (let offset = -800; offset <= 800; offset += 800) {
                const mPts = bgMountains[0];
                // Mountain body with gradient
                const farMtnGrad = ctx.createLinearGradient(0, 200, 0, 460);
                farMtnGrad.addColorStop(0, 'rgba(185,210,225,0.22)');
                farMtnGrad.addColorStop(0.3, 'rgba(195,218,205,0.18)');
                farMtnGrad.addColorStop(1, 'rgba(205,228,210,0.12)');
                ctx.fillStyle = farMtnGrad;
                ctx.beginPath();
                mPts.forEach((pt, i) => {
                    const px = pt.x + offset - mParallax0 * 0.15;
                    if (i === 0) ctx.moveTo(px, pt.y);
                    else ctx.lineTo(px, pt.y);
                });
                ctx.lineTo(800 + offset - mParallax0 * 0.15, 460);
                ctx.lineTo(0 + offset - mParallax0 * 0.15, 460);
                ctx.fill();
                // Snow caps on peaks
                ctx.fillStyle = 'rgba(245,252,255,0.25)';
                mPts.forEach((pt, i) => {
                    if (i > 0 && i < mPts.length - 1 && pt.y < mPts[i-1].y && pt.y < mPts[i+1].y) {
                        const px = pt.x + offset - mParallax0 * 0.15;
                        ctx.beginPath();
                        ctx.moveTo(px - 20, pt.y + 18);
                        ctx.lineTo(px, pt.y);
                        ctx.lineTo(px + 20, pt.y + 18);
                        ctx.closePath();
                        ctx.fill();
                    }
                });
            }

            // MID MOUNTAIN RANGE (slightly more saturated, less haze)
            for (let offset = -800; offset <= 800; offset += 800) {
                const mPts2 = bgMountains[1];
                const midMtnGrad = ctx.createLinearGradient(0, 260, 0, 460);
                midMtnGrad.addColorStop(0, 'rgba(145,195,150,0.25)');
                midMtnGrad.addColorStop(0.5, 'rgba(160,205,160,0.2)');
                midMtnGrad.addColorStop(1, 'rgba(175,215,170,0.15)');
                ctx.fillStyle = midMtnGrad;
                ctx.beginPath();
                mPts2.forEach((pt, i) => {
                    const px = pt.x + offset - mParallax0 * 0.3;
                    if (i === 0) ctx.moveTo(px, pt.y);
                    else ctx.lineTo(px, pt.y);
                });
                ctx.lineTo(800 + offset - mParallax0 * 0.3, 460);
                ctx.lineTo(0 + offset - mParallax0 * 0.3, 460);
                ctx.fill();
                // Sunlit right slope highlights
                ctx.fillStyle = 'rgba(200,235,160,0.2)';
                mPts2.forEach((pt, i) => {
                    if (i > 0 && i < mPts2.length - 1 && pt.y < mPts2[i-1].y) {
                        const px = pt.x + offset - mParallax0 * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(px, pt.y);
                        ctx.lineTo(px + 30, pt.y + 30);
                        ctx.lineTo(px, pt.y + 30);
                        ctx.closePath();
                        ctx.fill();
                    }
                });
            }

            // Foreground rolling hills
            ctx.fillStyle = '#A8D880';
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            ctx.moveTo(0, 430);
            ctx.bezierCurveTo(100, 400, 200, 420, 320, 405);
            ctx.bezierCurveTo(420, 390, 520, 415, 620, 400);
            ctx.bezierCurveTo(700, 390, 750, 410, 800, 395);
            ctx.lineTo(800, 460); ctx.lineTo(0, 460);
            ctx.fill();
            // Sunlit tops of hills
            ctx.fillStyle = 'rgba(200,245,140,0.15)';
            ctx.beginPath();
            ctx.moveTo(0, 430);
            ctx.bezierCurveTo(100, 400, 200, 420, 320, 405);
            ctx.bezierCurveTo(420, 390, 520, 415, 620, 400);
            ctx.bezierCurveTo(700, 390, 750, 410, 800, 395);
            ctx.lineTo(800, 410); ctx.lineTo(0, 440);
            ctx.fill();
            ctx.globalAlpha = 1;

            // --- 4. BACKGROUND TREES (with shading and depth) ---
            backgroundTrees.forEach(tree => {
                const isFar = tree.layer === 0;
                const alpha = isFar ? 0.2 : 0.3;
                ctx.globalAlpha = alpha;
                const trunkW = tree.w * 0.18;
                const trunkH = tree.h * 0.4;

                // Trunk with gradient
                const trunkGrad = ctx.createLinearGradient(tree.x + tree.w * 0.4, 0, tree.x + tree.w * 0.6, 0);
                trunkGrad.addColorStop(0, isFar ? '#7A5D40' : '#8B6C50');
                trunkGrad.addColorStop(0.5, isFar ? '#9A7A58' : '#A08860');
                trunkGrad.addColorStop(1, isFar ? '#6A5038' : '#7A5840');
                ctx.fillStyle = trunkGrad;
                ctx.fillRect(tree.x + tree.w * 0.41, tree.y - trunkH, trunkW, trunkH + 5);

                // Canopy with lit top and shaded bottom
                const canopyY = tree.y - tree.h * 0.65;
                const canopyR = tree.w * 0.6;
                const canopyGrad = ctx.createRadialGradient(
                    tree.x + tree.w * 0.4, canopyY - canopyR * 0.3, canopyR * 0.15,
                    tree.x + tree.w * 0.5, canopyY, canopyR
                );
                canopyGrad.addColorStop(0, isFar ? '#8AD87A' : '#78CC68');
                canopyGrad.addColorStop(0.5, isFar ? '#6ABF5E' : '#58B04A');
                canopyGrad.addColorStop(1, isFar ? '#4A9F40' : '#3D8E35');
                ctx.fillStyle = canopyGrad;
                // Multiple overlapping canopy blobs for natural look
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.5, canopyY, canopyR, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.2, canopyY + canopyR * 0.25, canopyR * 0.7, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.8, canopyY + canopyR * 0.25, canopyR * 0.7, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.35, canopyY - canopyR * 0.3, canopyR * 0.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.65, canopyY - canopyR * 0.2, canopyR * 0.55, 0, Math.PI * 2); ctx.fill();

                // Sunlight highlight on top-right
                ctx.fillStyle = 'rgba(180,245,120,0.25)';
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.65, canopyY - canopyR * 0.2, canopyR * 0.4, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- 5. REALISTIC CLOUDS (volumetric with light/shadow) ---
            clouds.forEach(c => {
                const totalW = c.puffs * c.size * 0.55;
                // Ground shadow
                ctx.globalAlpha = 0.06;
                ctx.fillStyle = '#556';
                ctx.beginPath();
                ctx.ellipse(c.x + totalW * 0.4, 440, totalW * 0.5, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Cloud bottom shadow layer
                ctx.globalAlpha = 0.12;
                ctx.fillStyle = '#8CA0B8';
                for (let pi = 0; pi < c.puffs; pi++) {
                    const puffR = c.size * (0.42 + (pi === Math.floor(c.puffs / 2) ? 0.1 : 0));
                    ctx.beginPath();
                    ctx.arc(c.x + pi * c.size * 0.55, c.y + puffR * 0.25, puffR * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Main cloud body - each puff has lit top, shaded bottom
                for (let pi = 0; pi < c.puffs; pi++) {
                    const puffR = c.size * (0.45 + (pi === Math.floor(c.puffs / 2) ? 0.12 : 0));
                    const px = c.x + pi * c.size * 0.55;
                    // Main puff with realistic lighting
                    const cloudGrad = ctx.createRadialGradient(px + puffR * 0.15, c.y - puffR * 0.3, puffR * 0.1, px, c.y + puffR * 0.1, puffR);
                    cloudGrad.addColorStop(0, 'rgba(255,255,255,0.7)');
                    cloudGrad.addColorStop(0.4, 'rgba(250,252,255,0.6)');
                    cloudGrad.addColorStop(0.75, 'rgba(230,240,250,0.45)');
                    cloudGrad.addColorStop(1, 'rgba(210,225,240,0.2)');
                    ctx.fillStyle = cloudGrad;
                    ctx.beginPath();
                    ctx.arc(px, c.y, puffR, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Bright sun-kissed highlight on top
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                const midPuff = Math.floor(c.puffs / 2);
                const hlX = c.x + midPuff * c.size * 0.55;
                const hlR = c.size * 0.3;
                ctx.beginPath(); ctx.arc(hlX + hlR * 0.3, c.y - c.size * 0.3, hlR, 0, Math.PI * 2); ctx.fill();
            });

            // --- 6. AMBIENT PARTICLES (fireflies/dust) ---
            ambientParticles.forEach(ap => {
                ctx.globalAlpha = ap.brightness * 0.3;
                const apGrad = ctx.createRadialGradient(ap.x, ap.y, 0, ap.x, ap.y, ap.size * 2.5);
                apGrad.addColorStop(0, ap.color);
                apGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = apGrad;
                ctx.beginPath(); ctx.arc(ap.x, ap.y, ap.size * 2.5, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- 7. LAVA ---
            lava.forEach(l => {
                // Outer glow
                const lGlow = ctx.createRadialGradient(l.x + l.width / 2, l.y, 0, l.x + l.width / 2, l.y + l.height / 2, l.width * 0.8);
                lGlow.addColorStop(0, 'rgba(255,100,0,0.5)');
                lGlow.addColorStop(1, 'rgba(255,40,0,0)');
                ctx.fillStyle = lGlow;
                ctx.fillRect(l.x - 8, l.y - 10, l.width + 16, l.height + 18);

                // Base lava gradient
                const lavaGrad = ctx.createLinearGradient(l.x, l.y, l.x, l.y + l.height);
                lavaGrad.addColorStop(0, '#ff7700');
                lavaGrad.addColorStop(0.4, '#ff4500');
                lavaGrad.addColorStop(1, '#cc2200');
                ctx.fillStyle = lavaGrad;
                ctx.fillRect(l.x, l.y, l.width, l.height);

                // Animated wave surface
                ctx.fillStyle = '#ff9933';
                ctx.beginPath();
                ctx.moveTo(l.x, l.y);
                const waveSegs = Math.max(4, Math.floor(l.width / 8));
                for (let i = 0; i <= waveSegs; i++) {
                    const wx = l.x + (i / waveSegs) * l.width;
                    const wy = l.y + Math.sin(t * 3 + i * 1.2 + l.x * 0.05) * 3;
                    ctx.lineTo(wx, wy);
                }
                ctx.lineTo(l.x + l.width, l.y + 5);
                ctx.lineTo(l.x, l.y + 5);
                ctx.fill();

                // Bright hotspots
                for (let i = 0; i < 2; i++) {
                    const hx = l.x + 8 + i * (l.width * 0.5);
                    const hy = l.y + 6 + Math.sin(t * 2.5 + i * 2.1) * 3;
                    const hGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, 7);
                    hGrad.addColorStop(0, 'rgba(255,230,100,0.9)');
                    hGrad.addColorStop(1, 'rgba(255,120,0,0)');
                    ctx.fillStyle = hGrad;
                    ctx.beginPath(); ctx.arc(hx, hy, 7, 0, Math.PI * 2); ctx.fill();
                }
            });

            // Lava embers
            lavaEmbers.forEach(e => {
                ctx.globalAlpha = e.life;
                const ec = `hsl(${20 + e.life * 30},100%,${50 + e.life * 30}%)`;
                ctx.fillStyle = ec;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.size * e.life, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- WATER POOLS (healing) ---
            water.forEach(w => {
                const wcx = w.x + w.width / 2, wcy = w.y + w.height / 2;

                // Outer healing glow
                const wGlow = ctx.createRadialGradient(wcx, w.y, 0, wcx, wcy, w.width * 0.9);
                wGlow.addColorStop(0, 'rgba(33,150,243,0.35)');
                wGlow.addColorStop(1, 'rgba(33,150,243,0)');
                ctx.fillStyle = wGlow;
                ctx.fillRect(w.x - 8, w.y - 8, w.width + 16, w.height + 16);

                // Base water gradient
                const wGrad = ctx.createLinearGradient(w.x, w.y, w.x, w.y + w.height);
                wGrad.addColorStop(0, colors.waterSurface);
                wGrad.addColorStop(0.4, colors.water);
                wGrad.addColorStop(1, colors.waterDeep);
                ctx.fillStyle = wGrad;
                ctx.globalAlpha = 0.8;
                ctx.fillRect(w.x, w.y, w.width, w.height);
                ctx.globalAlpha = 1;

                // Animated wave surface
                ctx.fillStyle = '#90CAF9';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(w.x, w.y);
                const wSegs = Math.max(3, Math.floor(w.width / 8));
                for (let i = 0; i <= wSegs; i++) {
                    const wx = w.x + (i / wSegs) * w.width;
                    const wy = w.y + Math.sin(t * 2.5 + i * 0.9 + w.x * 0.04) * 2;
                    ctx.lineTo(wx, wy);
                }
                ctx.lineTo(w.x + w.width, w.y + 4);
                ctx.lineTo(w.x, w.y + 4);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Healing sparkle
                if (Math.sin(t * 4 + w.x) > 0.5) {
                    ctx.fillStyle = 'white';
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath(); ctx.arc(wcx + Math.sin(t * 3) * 5, w.y + 3, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });

            // --- 8. PLATFORMS ---
            [...platforms, ...movingPlatforms].forEach(p => {
                const isMoving = movingPlatforms.includes(p);

                // Drop shadow beneath platform
                ctx.fillStyle = 'rgba(0,0,0,0.12)';
                ctx.fillRect(p.x + 2, p.y + p.height, p.width - 2, 4);

                // Dirt/stone body with realistic gradient
                const dirtGrad = ctx.createLinearGradient(p.x, p.y + 4, p.x, p.y + p.height);
                dirtGrad.addColorStop(0, isMoving ? '#8060C0' : '#8B6832');
                dirtGrad.addColorStop(0.5, isMoving ? '#6b4fa0' : '#7A5428');
                dirtGrad.addColorStop(1, isMoving ? '#4a3070' : '#5C3D18');
                ctx.fillStyle = dirtGrad;
                ctx.fillRect(p.x, p.y + 4, p.width, p.height - 4);

                // Left edge highlight (light from sun on right)
                ctx.fillStyle = isMoving ? 'rgba(180,140,255,0.15)' : 'rgba(200,170,120,0.2)';
                ctx.fillRect(p.x, p.y + 4, 2, p.height - 4);
                // Right edge shadow
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                ctx.fillRect(p.x + p.width - 2, p.y + 4, 2, p.height - 4);

                // Stone texture cracks
                ctx.strokeStyle = isMoving ? 'rgba(100,60,160,0.3)' : 'rgba(60,30,10,0.25)';
                ctx.lineWidth = 1;
                for (let sx = p.x + 8; sx < p.x + p.width - 4; sx += 14) {
                    ctx.beginPath(); ctx.moveTo(sx, p.y + 5); ctx.lineTo(sx + 3, p.y + p.height - 2); ctx.stroke();
                }
                // Horizontal crack
                if (p.width > 40) {
                    ctx.beginPath(); ctx.moveTo(p.x + 4, p.y + p.height * 0.6); ctx.lineTo(p.x + p.width - 4, p.y + p.height * 0.65); ctx.stroke();
                }

                // Grass top band
                const grassGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + 7);
                grassGrad.addColorStop(0, isMoving ? '#b06aff' : '#8AD450');
                grassGrad.addColorStop(1, isMoving ? '#7040c0' : '#5aaa30');
                ctx.fillStyle = grassGrad;
                ctx.fillRect(p.x, p.y, p.width, 7);

                // Top sunlit highlight
                ctx.fillStyle = isMoving ? 'rgba(200,150,255,0.5)' : 'rgba(200,255,120,0.5)';
                ctx.fillRect(p.x + 2, p.y, p.width - 4, 2);

                // Grass blades (more realistic)
                if (!isMoving) {
                    const bladeCount = Math.max(3, Math.floor(p.width / 10));
                    for (let ti = 0; ti < bladeCount; ti++) {
                        const tx = p.x + 3 + ti * (p.width / bladeCount) + Math.sin(ti * 7) * 2;
                        const bladeH = 3 + Math.abs(Math.sin(ti * 3.7)) * 4;
                        const lean = Math.sin(t * 1.5 + ti * 0.8) * 1.5;
                        ctx.strokeStyle = ti % 3 === 0 ? '#4CAF50' : '#5DC93A';
                        ctx.lineWidth = 1.2;
                        ctx.beginPath();
                        ctx.moveTo(tx, p.y);
                        ctx.quadraticCurveTo(tx + lean, p.y - bladeH * 0.6, tx + lean * 1.5, p.y - bladeH);
                        ctx.stroke();
                    }
                }

                // Small pebbles/texture on dirt face
                if (!isMoving && p.height > 12) {
                    ctx.globalAlpha = 0.18;
                    ctx.fillStyle = '#9A7B4A';
                    for (let mi = 0; mi < 3; mi++) {
                        const mxPos = p.x + 6 + mi * (p.width / 3.5);
                        ctx.beginPath(); ctx.ellipse(mxPos, p.y + 11, 3, 2, 0.3, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
            });

            // --- 9. METALLIC SPIKES ---
            spikes.forEach(spike => {
                const count = Math.floor(spike.width / 12);
                for (let i = 0; i < count; i++) {
                    const sx = spike.x + i * 12;
                    const sGrad = ctx.createLinearGradient(sx, spike.y + spike.height, sx + 6, spike.y);
                    sGrad.addColorStop(0, '#2a2f38');
                    sGrad.addColorStop(0.4, '#6a7585');
                    sGrad.addColorStop(0.7, '#c8cfd8');
                    sGrad.addColorStop(1, '#8090a0');
                    ctx.fillStyle = sGrad;
                    ctx.beginPath();
                    ctx.moveTo(sx, spike.y + spike.height);
                    ctx.lineTo(sx + 6, spike.y);
                    ctx.lineTo(sx + 12, spike.y + spike.height);
                    ctx.closePath();
                    ctx.fill();
                    // Gleam
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#e8eef5';
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(sx + 4, spike.y + spike.height - 2);
                    ctx.lineTo(sx + 6, spike.y + 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            });

            // --- 10. SPRINGS ---
            springs.forEach(spring => {
                const h = spring.compressed ? 8 : spring.height;
                const sw = spring.width;

                // Base plate
                const baseGrad = ctx.createLinearGradient(spring.x, spring.y + h - 5, spring.x + sw, spring.y + h);
                baseGrad.addColorStop(0, '#8a6010');
                baseGrad.addColorStop(0.5, '#c8980a');
                baseGrad.addColorStop(1, '#8a6010');
                ctx.fillStyle = baseGrad;
                ctx.fillRect(spring.x, spring.y + h - 5, sw, 5);

                // Coil segments
                const coilH = h - 5;
                const coilSegs = 4;
                const segH = coilH / coilSegs;
                for (let ci = 0; ci < coilSegs; ci++) {
                    const cy = spring.y + ci * segH;
                    const bright = ci % 2 === 0 ? 1 : 0.7;
                    ctx.fillStyle = `rgba(255,${Math.floor(200 * bright)},0,1)`;
                    ctx.fillRect(spring.x + 3, cy, sw - 6, segH - 1);
                    // Coil highlight
                    ctx.fillStyle = 'rgba(255,255,200,0.4)';
                    ctx.fillRect(spring.x + 4, cy, (sw - 8) * 0.4, 2);
                }

                // Top cap
                const topGrad = ctx.createLinearGradient(spring.x, spring.y, spring.x + sw, spring.y + 4);
                topGrad.addColorStop(0, '#ffe870');
                topGrad.addColorStop(0.5, '#ffffff');
                topGrad.addColorStop(1, '#ffe870');
                ctx.fillStyle = topGrad;
                ctx.fillRect(spring.x, spring.y, sw, 4);
            });

            // --- 11. PORTALS ---
            portals.forEach(portal => {
                const px = portal.x + 15, py = portal.y + 20;
                const spin = t * 2.5;

                // Outer glow
                const pGlow = ctx.createRadialGradient(px, py, 5, px, py, 32);
                pGlow.addColorStop(0, portal.color + 'aa');
                pGlow.addColorStop(1, portal.color + '00');
                ctx.fillStyle = pGlow;
                ctx.beginPath(); ctx.ellipse(px, py, 32, 34, 0, 0, Math.PI * 2); ctx.fill();

                // Rotating outer ring
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(spin);
                ctx.strokeStyle = portal.color;
                ctx.lineWidth = 2.5;
                ctx.globalAlpha = 0.85;
                ctx.beginPath();
                for (let ri = 0; ri < 8; ri++) {
                    const ra = (ri / 8) * Math.PI * 2;
                    const rr = 18 + Math.sin(spin * 2 + ri) * 2;
                    ctx.moveTo(Math.cos(ra) * (rr - 5), Math.sin(ra) * (rr - 5) * 1.2);
                    ctx.lineTo(Math.cos(ra) * rr, Math.sin(ra) * rr * 1.2);
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
                // Orbiting particles
                for (let oi = 0; oi < 4; oi++) {
                    const oa = spin + (oi / 4) * Math.PI * 2;
                    const ox = Math.cos(oa) * 18, oy = Math.sin(oa) * 20;
                    ctx.fillStyle = portal.color;
                    ctx.beginPath(); ctx.arc(ox, oy, 2.5, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();

                // Inner portal body
                const portalBody = ctx.createRadialGradient(px, py, 1, px, py, 14);
                portalBody.addColorStop(0, 'rgba(255,255,255,0.95)');
                portalBody.addColorStop(0.4, portal.color + 'dd');
                portalBody.addColorStop(1, portal.color + '44');
                ctx.fillStyle = portalBody;
                ctx.beginPath(); ctx.ellipse(px, py, 14, 18, 0, 0, Math.PI * 2); ctx.fill();

                // Warp shimmer
                ctx.globalAlpha = 0.3 + Math.sin(t * 4 + portal.x) * 0.2;
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.ellipse(px - 3, py - 4, 5, 8, -0.4, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            });

            // --- 12. FLAG ---
            if (flag) {
                // Pole shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(flag.x + 10, flag.y, 3, flag.height);

                // Pole gradient
                const poleGrad = ctx.createLinearGradient(flag.x + 8, 0, flag.x + 12, 0);
                poleGrad.addColorStop(0, '#5a2a04');
                poleGrad.addColorStop(0.4, '#c07030');
                poleGrad.addColorStop(1, '#5a2a04');
                ctx.fillStyle = poleGrad;
                ctx.fillRect(flag.x + 8, flag.y, 4, flag.height);

                // Waving flag cloth
                const waveAmp = 4;
                const waveFreq = t * 4;
                ctx.fillStyle = '#22C55E';
                ctx.beginPath();
                ctx.moveTo(flag.x + 12, flag.y);
                // Top edge wave
                for (let fi = 0; fi <= 26; fi++) {
                    const fx = flag.x + 12 + fi;
                    const fy = flag.y + Math.sin(waveFreq + fi * 0.3) * waveAmp * (fi / 26);
                    if (fi === 0) ctx.lineTo(fx, fy); else ctx.lineTo(fx, fy);
                }
                // Bottom edge wave
                for (let fi = 26; fi >= 0; fi--) {
                    const fx = flag.x + 12 + fi;
                    const fy = flag.y + 26 + Math.sin(waveFreq + fi * 0.3 + 1) * waveAmp * (fi / 26);
                    ctx.lineTo(fx, fy);
                }
                ctx.closePath();
                ctx.fill();

                // Flag highlight
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#aaffc0';
                ctx.beginPath();
                ctx.moveTo(flag.x + 12, flag.y + 2);
                for (let fi = 0; fi <= 26; fi++) {
                    const fx = flag.x + 12 + fi;
                    const fy = flag.y + 2 + Math.sin(waveFreq + fi * 0.3) * waveAmp * (fi / 26);
                    ctx.lineTo(fx, fy);
                }
                ctx.lineTo(flag.x + 12, flag.y + 8);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // --- 13. 3D SPINNING COINS ---
            coins.forEach(coin => {
                if (!coin.collected) {
                    const bob = Math.sin(t * 2 + coin.bobOffset) * 2.5;
                    const cx = coin.x + 10, cy = coin.y + 10 + bob;
                    const spinAngle = t * 3 + coin.bobOffset;
                    const scaleX = Math.abs(Math.cos(spinAngle));

                    // Outer glow
                    const coinGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 16);
                    coinGlow.addColorStop(0, 'rgba(255,215,0,0.4)');
                    coinGlow.addColorStop(1, 'rgba(255,215,0,0)');
                    ctx.fillStyle = coinGlow;
                    ctx.beginPath(); ctx.arc(cx, cy, 16, 0, Math.PI * 2); ctx.fill();

                    // Coin body (squished for 3D effect)
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.scale(Math.max(0.1, scaleX), 1);
                    const cGrad = ctx.createRadialGradient(-3, -3, 1, 0, 0, 9);
                    cGrad.addColorStop(0, '#fffacc');
                    cGrad.addColorStop(0.4, '#ffd700');
                    cGrad.addColorStop(1, '#b8860b');
                    ctx.fillStyle = cGrad;
                    ctx.beginPath(); ctx.arc(0, 0, 9, 0, Math.PI * 2); ctx.fill();
                    // Edge highlight
                    ctx.strokeStyle = '#ffe87a';
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath(); ctx.arc(0, 0, 7, -Math.PI * 0.7, Math.PI * 0.1); ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.restore();

                    // Sparkle
                    if (Math.sin(t * 5 + coin.bobOffset * 2) > 0.7) {
                        ctx.fillStyle = 'white';
                        ctx.globalAlpha = 0.9;
                        for (let si = 0; si < 4; si++) {
                            const sa = (si / 4) * Math.PI * 2 + t * 4;
                            const sd = 11;
                            ctx.beginPath(); ctx.arc(cx + Math.cos(sa) * sd, cy + Math.sin(sa) * sd, 1.5, 0, Math.PI * 2); ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                }
            });

            // --- 14. BETTER DRONES ---
            drones.forEach(drone => {
                const dc = drone.x + drone.width / 2, dy = drone.y + drone.height / 2;

                // Searchlight cone
                ctx.globalAlpha = 0.12;
                const lightGrad = ctx.createLinearGradient(dc, drone.y + drone.height, dc, drone.y + drone.height + 120);
                lightGrad.addColorStop(0, '#ffffaa');
                lightGrad.addColorStop(1, 'rgba(255,255,100,0)');
                ctx.fillStyle = lightGrad;
                ctx.beginPath();
                ctx.moveTo(dc - 8, drone.y + drone.height);
                ctx.lineTo(dc - 55, drone.y + drone.height + 120);
                ctx.lineTo(dc + 55, drone.y + drone.height + 120);
                ctx.lineTo(dc + 8, drone.y + drone.height);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;

                // Engine glow
                ctx.globalAlpha = 0.35;
                const engGlow = ctx.createRadialGradient(dc, drone.y, 0, dc, drone.y, 30);
                engGlow.addColorStop(0, '#66aaff');
                engGlow.addColorStop(1, 'rgba(100,150,255,0)');
                ctx.fillStyle = engGlow;
                ctx.beginPath(); ctx.arc(dc, drone.y, 30, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;

                // Body
                const bodyGrad = ctx.createLinearGradient(drone.x, drone.y, drone.x, drone.y + drone.height);
                bodyGrad.addColorStop(0, '#5a6575');
                bodyGrad.addColorStop(1, '#2a3040');
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.roundRect(drone.x, drone.y, drone.width, drone.height, 4);
                ctx.fill();

                // Body highlight
                ctx.fillStyle = 'rgba(150,180,220,0.25)';
                ctx.fillRect(drone.x + 2, drone.y + 2, drone.width - 4, 4);

                // Cockpit
                ctx.fillStyle = '#0a1520';
                ctx.beginPath();
                ctx.ellipse(drone.x + drone.width / 2, drone.y + drone.height / 2, 10, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(100,200,255,0.5)';
                ctx.beginPath();
                ctx.ellipse(drone.x + drone.width / 2 - 2, drone.y + drone.height / 2 - 1, 5, 3, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // Propellers
                const propAngle = t * 18;
                [drone.x + 6, drone.x + drone.width - 6].forEach((px, idx) => {
                    ctx.save();
                    ctx.translate(px, drone.y - 2);
                    ctx.rotate(idx === 0 ? propAngle : -propAngle);
                    ctx.globalAlpha = 0.75;
                    ctx.fillStyle = '#8090a8';
                    ctx.fillRect(-9, -1.5, 18, 3);
                    ctx.restore();
                });

                // Exhaust particles
                if (globalTime % 3 === 0) {
                    particles.push({ x: dc + (Math.random() - 0.5) * 10, y: drone.y - 3, vx: (Math.random() - 0.5) * 1.5, vy: -0.8 - Math.random(), life: 0.6, color: '#88aaff', size: 2 });
                }

                // Warning light
                const warn = drone.fireTimer < 20;
                const blink = Math.sin(t * (warn ? 15 : 4)) > 0;
                ctx.fillStyle = warn ? '#ff3030' : (blink ? '#ef4444' : '#991b1b');
                ctx.globalAlpha = warn ? (0.7 + Math.sin(t * 20) * 0.3) : 1;
                ctx.beginPath();
                ctx.arc(dc, drone.y + drone.height - 3, warn ? 5 : 3.5, 0, Math.PI * 2);
                ctx.fill();
                if (warn) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#ff8888';
                    ctx.beginPath(); ctx.arc(dc, drone.y + drone.height - 3, 9, 0, Math.PI * 2); ctx.fill();
                }
                ctx.globalAlpha = 1;
            });

            // --- 15. LASERS WITH BLOOM ---
            lasers.forEach(laser => {
                const lx = laser.x, ly = laser.y;
                const lx2 = laser.x - laser.vx * 3, ly2 = laser.y - laser.vy * 3;

                // Wide bloom
                ctx.globalAlpha = 0.15;
                ctx.strokeStyle = '#ffaaaa';
                ctx.lineWidth = 14;
                ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx2, ly2); ctx.stroke();

                // Mid glow
                ctx.globalAlpha = 0.35;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 6;
                ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx2, ly2); ctx.stroke();

                // Core
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx2, ly2); ctx.stroke();

                // Head dot
                ctx.fillStyle = '#ffeeee';
                ctx.beginPath(); ctx.arc(lx, ly, 3, 0, Math.PI * 2); ctx.fill();
            });
            ctx.lineWidth = 1; ctx.globalAlpha = 1; ctx.lineCap = 'butt';

            // --- 16. PLAYER TRAIL ---
            playerTrail.forEach((tr, i) => {
                ctx.globalAlpha = tr.life * 0.35;
                ctx.fillStyle = invincible > 0 ? '#aaddff' : '#ff8833';
                ctx.beginPath();
                ctx.arc(tr.x, tr.y, tr.size * tr.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- 17. PLAYER ---
            if (invincible <= 0 || Math.floor(invincible / 5) % 2 === 0) {
                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y);
                ctx.scale(player.facing, 1);
                ctx.translate(-player.width / 2, 0);

                // Subtle glow
                ctx.globalAlpha = 0.2;
                const plGlow = ctx.createRadialGradient(15, 18, 2, 15, 18, 20);
                plGlow.addColorStop(0, invincible > 0 ? '#88ccff' : '#ff8833');
                plGlow.addColorStop(1, 'rgba(255,120,0,0)');
                ctx.fillStyle = plGlow;
                ctx.beginPath(); ctx.arc(15, 18, 20, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;

                // Body
                ctx.fillStyle = colors.player;
                ctx.fillRect(5, 10, 20, 22);
                // Body gradient highlight
                ctx.fillStyle = 'rgba(255,180,100,0.3)';
                ctx.fillRect(6, 11, 8, 10);

                // Head
                ctx.fillStyle = colors.player;
                ctx.beginPath();
                ctx.arc(15, 10, 9, 0, Math.PI * 2);
                ctx.fill();

                // Eye white
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(18, 8, 3.5, 0, Math.PI * 2);
                ctx.fill();
                // Pupil
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(19, 8, 1.8, 0, Math.PI * 2);
                ctx.fill();
                // Eye shine
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(20, 7, 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.fillStyle = colors.playerDark;
                const leg = Math.sin(player.animFrame) * 3;
                ctx.fillRect(7, 30, 5, 6 + (player.onGround ? leg : 0));
                ctx.fillRect(18, 30, 5, 6 + (player.onGround ? -leg : 0));

                ctx.restore();
            }

            // --- 18. GAME PARTICLES ---
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.max(0.1, p.size * p.life), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // (vignette removed for clarity)

            ctx.restore(); // end screen shake

            // --- TUTORIAL OVERLAYS ---
            drawTutorials();
        }

        let lastFrameTime = 0;
        let accumulator = 0;
        const FIXED_STEP = 16.667;

        function gameLoop(timestamp) {
            if (!timestamp) { draw(); requestAnimationFrame(gameLoop); return; }
            if (!lastFrameTime) lastFrameTime = timestamp;
            let elapsed = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            if (elapsed > 100) elapsed = 100;
            accumulator += elapsed;
            while (accumulator >= FIXED_STEP) {
                update(1);
                accumulator -= FIXED_STEP;
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', e => {
            if (activeGame === 'hop') return;
            if (tutorialPaused) {
                if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight') {
                    nextTutorial();
                }
                e.preventDefault();
                return;
            }
            keys[e.code] = true;
            if (e.code === 'KeyR') restart();
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });
        document.addEventListener('keyup', e => { if (activeGame === 'hop') return; keys[e.code] = false; });

        // Touch controls for mobile
        let touchStartX = null, touchStartY = null, touchActive = false;
        const DRAG_THRESHOLD = 15;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (tutorialPaused) { nextTutorial(); return; }
            const t = e.touches[0];
            touchStartX = t.clientX;
            touchStartY = t.clientY;
            touchActive = true;
            // Tap jumps immediately
            keys['Space'] = true;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touchActive || touchStartX === null) return;
            const t = e.touches[0];
            const dx = t.clientX - touchStartX;
            const dy = t.clientY - touchStartY;

            // Horizontal movement
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            if (dx < -DRAG_THRESHOLD) keys['ArrowLeft'] = true;
            else if (dx > DRAG_THRESHOLD) keys['ArrowRight'] = true;

            // Swipe up to jump
            if (dy < -DRAG_THRESHOLD) keys['Space'] = true;
            else keys['Space'] = false;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchActive = false;
            touchStartX = null;
            touchStartY = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            keys['Space'] = false;
        }, { passive: false });

        // Mouse drag controls (desktop)
        canvas.addEventListener('mousedown', (e) => {
            if (tutorialPaused) { nextTutorial(); return; }
            touchStartX = e.clientX;
            touchStartY = e.clientY;
            touchActive = true;
            keys['Space'] = true;
        });

        document.addEventListener('mousemove', (e) => {
            if (!touchActive || touchStartX === null) return;
            const dx = e.clientX - touchStartX;
            const dy = e.clientY - touchStartY;

            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            if (dx < -DRAG_THRESHOLD) keys['ArrowLeft'] = true;
            else if (dx > DRAG_THRESHOLD) keys['ArrowRight'] = true;

            if (dy < -DRAG_THRESHOLD) keys['Space'] = true;
            else keys['Space'] = false;
        });

        document.addEventListener('mouseup', () => {
            if (!touchActive) return;
            touchActive = false;
            touchStartX = null;
            touchStartY = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            keys['Space'] = false;
        });

        canvas.addEventListener('click', (e) => {
            if (tutorialPaused) {
                // Check if click is on the Next button, or anywhere on canvas
                nextTutorial();
            }
        });

        initVisuals();
        initClouds();
        generateLevel(level);
        gameLoop();
    </script>
</body>
</html>

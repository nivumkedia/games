<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fruit Ninja</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #3a2a18; touch-action: none; }
        canvas { display: block; width: 100%; height: 100%; cursor: none; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// --- Constants ---
const FIXED_DT = 1 / 60;
const GRAVITY = 1200;
const MAX_LIVES = 3;
const STORAGE_KEY = 'fruitNinjaBest';
const UNLOCK_STORAGE_KEY = 'fruitNinjaUnlocks';
const ARCHERY_THRESHOLD = 20;
const SWORD_THRESHOLD = 55;
const ARROW_SPEED = 1800;
const MAX_SPLATTERS = 50;

const FRUIT_TYPES = [
    { name: 'watermelon', radius: 45, points: 3, outer: '#2d7a2d', inner: '#ff3b3b', juice: '#ff5555' },
    { name: 'orange',     radius: 32, points: 2, outer: '#e87800', inner: '#ffb347', juice: '#ffc966' },
    { name: 'apple',      radius: 30, points: 2, outer: '#cc1111', inner: '#ffffcc', juice: '#ff6666' },
    { name: 'banana',     radius: 26, points: 3, outer: '#e6cc00', inner: '#fff9c4', juice: '#ffe066' },
    { name: 'strawberry', radius: 24, points: 1, outer: '#cc2244', inner: '#ff8899', juice: '#ff4466' },
    { name: 'kiwi',       radius: 24, points: 1, outer: '#6b4226', inner: '#a8e06c', juice: '#88cc44' },
];

const SPECIAL_TYPES = [
    // Good items
    { name: 'star',      radius: 28, points: 5,  color: '#ffd700', glow: '#ffee88', particles: '#ffe066', rarity: 1 },
    { name: 'diamond',   radius: 30, points: 10, color: '#88ddff', glow: '#ffffff', particles: '#aaeeff', rarity: 0.15 },
    { name: 'heart',     radius: 26, points: 0,  color: '#ff4466', glow: '#ff8899', particles: '#ff6688', rarity: 1, effect: 'heal' },
    { name: 'coin',      radius: 22, points: 3,  color: '#ffd700', glow: '#ffcc00', particles: '#ffe066', rarity: 1 },
    { name: 'hourglass', radius: 26, points: 0,  color: '#4488ff', glow: '#88bbff', particles: '#66aaff', rarity: 1, effect: 'slow' },
    { name: 'shield',    radius: 28, points: 0,  color: '#4488ff', glow: '#88ccff', particles: '#66aaff', rarity: 1, effect: 'shield' },
    // Bad items
    { name: 'skull',     radius: 28, points: 0,  color: '#888888', glow: '#44ff44', particles: '#66ff66', rarity: 1, effect: 'loseLife' },
    { name: 'rock',      radius: 30, points: 0,  color: '#777777', glow: '#999999', particles: '#aaaaaa', rarity: 1, effect: 'rock', unsliceable: true },
    { name: 'poison',    radius: 24, points: -5, color: '#44bb44', glow: '#66ff66', particles: '#55cc55', rarity: 1, effect: 'poison' },
];

// --- State ---
let W, H;
let state = 'start';
let score = 0;
let bestScore = parseInt(localStorage.getItem(STORAGE_KEY)) || 0;
let lives = MAX_LIVES;
let gameTime = 0;
let spawnTimer = 0;
let spawnInterval = 1.8;
let comboCount = 0;
let comboTimer = 0;

let fruits = [];
let halves = [];
let particles = [];
let popups = [];
let bladeTrail = [];
let bombs = [];

let isPointerDown = false;
let pointerPos = { x: -100, y: -100 };
let lastPointerPos = null;
let bladePoints = [];

// Visual state
let woodKnots = [];
let splatters = [];
let dustMotes = [];
let screenShake = { x: 0, y: 0, timer: 0 };
let screenFlash = 0;
let bladeSparkles = [];
let startScreenFruits = [];
let shockwaves = [];
let sliceLines = [];
let timeScale = 1;
let slowMoTimer = 0;
let hourglassTimer = 0;
let hourglassActive = false;
let shieldActive = false;

// --- Blade/BG Ability State ---
let chainSlicing = false;  // Guard flag to prevent infinite recursion in explode/chain
let lightningBolts = [];   // Visual lightning bolt effects for chain blade
let bgPlatforms = [];      // Platforms for forest/neon/frozen backgrounds
let lavaBubbles = [];       // Lava bubbles for volcano background
let lavaBubbleTimer = 0;   // Timer for spawning lava bubbles
let wavePhase = 0;         // Phase for ocean wave animation
let bladeSliceCount = 0;   // For blood blade lifesteal counter
let stormTimer = 0;        // Storm blade: slice-all timer
let meteorTimer = 0;       // Meteor blade: bonus score timer

// --- Unlock / Mode State ---
let savedUnlocks = JSON.parse(localStorage.getItem(UNLOCK_STORAGE_KEY) || '{}');
let unlockedSword = !!savedUnlocks.sword;
let unlockedArchery = !!savedUnlocks.archery;
let currentMode = 'blade'; // 'blade' | 'sword' | 'archery'
let arrows = [];
let selectedModeIndex = 0;
let unlockMessage = '';

// --- Shop / Coin System ---
const SHOP_STORAGE_KEY = 'fruitNinjaShop';

const BLADE_ITEMS = [
    { id: 'blade_classic', name: 'Classic', price: 0, glow: 'rgba(150,200,255,0.7)', fill: 'rgba(180,220,255,0.3)', mid: 'rgba(210,235,255,0.55)', core: 'rgba(255,255,255,0.9)', sparkle: 'rgba(180,220,255,', special: null, bonus: 'none', bonusDesc: 'No bonus' },
    { id: 'blade_fire', name: 'Fire Blade', price: 50, glow: 'rgba(255,80,0,0.7)', fill: 'rgba(255,120,40,0.3)', mid: 'rgba(255,160,60,0.55)', core: 'rgba(255,220,100,0.9)', sparkle: 'rgba(255,120,40,', special: null, bonus: 'explode', bonusDesc: 'Sliced fruits explode nearby' },
    { id: 'blade_ice', name: 'Ice Blade', price: 50, glow: 'rgba(100,220,255,0.7)', fill: 'rgba(150,240,255,0.3)', mid: 'rgba(200,250,255,0.55)', core: 'rgba(255,255,255,0.9)', sparkle: 'rgba(150,240,255,', special: null, bonus: 'freeze', bonusDesc: 'Fruits freeze mid-air' },
    { id: 'blade_toxic', name: 'Toxic Blade', price: 75, glow: 'rgba(0,255,80,0.7)', fill: 'rgba(40,255,100,0.3)', mid: 'rgba(80,255,130,0.55)', core: 'rgba(200,255,200,0.9)', sparkle: 'rgba(40,255,100,', special: null, bonus: 'poison_immune', bonusDesc: 'Immune to poison' },
    { id: 'blade_shadow', name: 'Shadow Blade', price: 100, glow: 'rgba(140,60,220,0.7)', fill: 'rgba(100,30,180,0.3)', mid: 'rgba(160,80,240,0.55)', core: 'rgba(220,180,255,0.9)', sparkle: 'rgba(140,60,220,', special: null, bonus: 'wider', bonusDesc: '+50% blade width' },
    { id: 'blade_golden', name: 'Golden Blade', price: 150, glow: 'rgba(255,200,0,0.7)', fill: 'rgba(255,220,60,0.3)', mid: 'rgba(255,230,100,0.55)', core: 'rgba(255,255,200,0.9)', sparkle: 'rgba(255,220,60,', special: null, bonus: 'bonus_coins', bonusDesc: '+2 coins per slice' },
    { id: 'blade_rainbow', name: 'Rainbow Blade', price: 200, glow: 'rgba(255,100,100,0.7)', fill: 'rgba(255,200,100,0.3)', mid: 'rgba(100,255,100,0.55)', core: 'rgba(255,255,255,0.9)', sparkle: 'rgba(255,200,100,', special: 'rainbow', bonus: 'random_bonus', bonusDesc: 'Random bonus each slice' },
    { id: 'blade_lightning', name: 'Lightning Blade', price: 250, glow: 'rgba(255,255,100,0.7)', fill: 'rgba(255,255,150,0.3)', mid: 'rgba(255,255,200,0.55)', core: 'rgba(255,255,255,0.9)', sparkle: 'rgba(255,255,100,', special: null, bonus: 'chain', bonusDesc: 'Chain lightning hits +2' },
    { id: 'blade_sakura', name: 'Sakura Blade', price: 300, glow: 'rgba(255,150,180,0.7)', fill: 'rgba(255,180,200,0.3)', mid: 'rgba(255,200,220,0.55)', core: 'rgba(255,240,245,0.9)', sparkle: 'rgba(255,150,180,', special: 'sakura', bonus: 'second_life', bonusDesc: 'Missed fruits may return' },
    { id: 'blade_galaxy', name: 'Galaxy Blade', price: 500, glow: 'rgba(80,0,180,0.7)', fill: 'rgba(60,0,140,0.3)', mid: 'rgba(120,40,220,0.55)', core: 'rgba(200,150,255,0.9)', sparkle: 'rgba(120,40,220,', special: 'galaxy', bonus: 'gravity', bonusDesc: 'Fruits orbit blade' },
    { id: 'blade_dragon', name: 'Dragon Blade', price: 750, glow: 'rgba(255,40,0,0.7)', fill: 'rgba(255,60,20,0.3)', mid: 'rgba(255,100,40,0.55)', core: 'rgba(255,200,100,0.9)', sparkle: 'rgba(255,60,20,', special: 'dragon', bonus: 'fire_breath', bonusDesc: 'Burn trail slices' },
    { id: 'blade_crystal', name: 'Crystal Blade', price: 1000, glow: 'rgba(220,240,255,0.7)', fill: 'rgba(240,250,255,0.3)', mid: 'rgba(250,255,255,0.55)', core: 'rgba(255,255,255,0.95)', sparkle: 'rgba(220,240,255,', special: 'crystal', bonus: 'double_chance', bonusDesc: '30% chance 2x points' },
    // --- More weapons ---
    { id: 'blade_plasma', name: 'Plasma Blade', price: 80, glow: 'rgba(0,200,255,0.7)', fill: 'rgba(0,180,255,0.3)', mid: 'rgba(80,220,255,0.55)', core: 'rgba(200,240,255,0.9)', sparkle: 'rgba(0,200,255,', special: null, bonus: 'magnet', bonusDesc: 'Coins fly to you (+1 bonus)' },
    { id: 'blade_blood', name: 'Blood Blade', price: 120, glow: 'rgba(180,0,0,0.7)', fill: 'rgba(200,20,20,0.3)', mid: 'rgba(220,40,40,0.55)', core: 'rgba(255,100,100,0.9)', sparkle: 'rgba(200,20,20,', special: null, bonus: 'lifesteal', bonusDesc: 'Every 5 slices heals 1 life' },
    { id: 'blade_wind', name: 'Wind Blade', price: 90, glow: 'rgba(180,255,200,0.7)', fill: 'rgba(200,255,220,0.3)', mid: 'rgba(220,255,230,0.55)', core: 'rgba(240,255,245,0.9)', sparkle: 'rgba(200,255,220,', special: null, bonus: 'push', bonusDesc: 'Push fruits upward on near miss' },
    { id: 'blade_lava', name: 'Lava Blade', price: 175, glow: 'rgba(255,100,0,0.7)', fill: 'rgba(255,60,0,0.3)', mid: 'rgba(255,140,20,0.55)', core: 'rgba(255,200,50,0.9)', sparkle: 'rgba(255,100,0,', special: null, bonus: 'melt_bombs', bonusDesc: 'Bombs give +5 pts instead of death' },
    { id: 'blade_void', name: 'Void Blade', price: 400, glow: 'rgba(40,0,60,0.7)', fill: 'rgba(60,0,100,0.3)', mid: 'rgba(100,20,160,0.55)', core: 'rgba(180,100,255,0.9)', sparkle: 'rgba(60,0,100,', special: null, bonus: 'void_pull', bonusDesc: 'Missed fruits get sucked back' },
    { id: 'blade_solar', name: 'Solar Blade', price: 350, glow: 'rgba(255,220,50,0.7)', fill: 'rgba(255,240,100,0.3)', mid: 'rgba(255,245,150,0.55)', core: 'rgba(255,255,220,0.95)', sparkle: 'rgba(255,220,50,', special: null, bonus: 'sunburn', bonusDesc: '+1 point to all fruits' },
    { id: 'blade_storm', name: 'Storm Blade', price: 280, glow: 'rgba(80,80,120,0.7)', fill: 'rgba(100,100,150,0.3)', mid: 'rgba(140,140,200,0.55)', core: 'rgba(200,200,255,0.9)', sparkle: 'rgba(100,100,180,', special: null, bonus: 'storm', bonusDesc: 'Every 10s a storm slices all fruit' },
    { id: 'blade_candy', name: 'Candy Blade', price: 130, glow: 'rgba(255,150,200,0.7)', fill: 'rgba(255,180,220,0.3)', mid: 'rgba(255,200,230,0.55)', core: 'rgba(255,230,240,0.9)', sparkle: 'rgba(255,150,200,', special: null, bonus: 'sweet', bonusDesc: 'Combos start at 2 instead of 3' },
    { id: 'blade_ghost', name: 'Ghost Blade', price: 220, glow: 'rgba(200,200,200,0.5)', fill: 'rgba(220,220,220,0.2)', mid: 'rgba(240,240,240,0.4)', core: 'rgba(255,255,255,0.7)', sparkle: 'rgba(200,200,200,', special: null, bonus: 'phase', bonusDesc: 'Blade passes through rocks safely' },
    { id: 'blade_nature', name: 'Nature Blade', price: 160, glow: 'rgba(50,180,50,0.7)', fill: 'rgba(70,200,70,0.3)', mid: 'rgba(100,220,100,0.55)', core: 'rgba(180,255,180,0.9)', sparkle: 'rgba(70,200,70,', special: null, bonus: 'regrow', bonusDesc: 'Sliced fruits may regrow (+1 pt)' },
    { id: 'blade_meteor', name: 'Meteor Blade', price: 600, glow: 'rgba(255,120,40,0.7)', fill: 'rgba(255,80,0,0.3)', mid: 'rgba(255,160,60,0.55)', core: 'rgba(255,230,150,0.95)', sparkle: 'rgba(255,120,40,', special: null, bonus: 'meteor', bonusDesc: 'Every 15s a meteor scores +10' },
    { id: 'blade_time', name: 'Time Blade', price: 450, glow: 'rgba(100,200,255,0.7)', fill: 'rgba(120,210,255,0.3)', mid: 'rgba(160,230,255,0.55)', core: 'rgba(220,245,255,0.9)', sparkle: 'rgba(100,200,255,', special: null, bonus: 'rewind', bonusDesc: 'Every miss has 50% undo chance' },
];

const BG_ITEMS = [
    { id: 'bg_classic', name: 'Classic Dojo', price: 0, tint: null, alpha: 0, mechanic: 'none', mechanicDesc: 'No bonus' },
    { id: 'bg_night', name: 'Night Dojo', price: 100, tint: '#0a1030', alpha: 0.35, mechanic: 'glow_fruits', mechanicDesc: 'Fruits glow brighter' },
    { id: 'bg_sunset', name: 'Sunset Dojo', price: 100, tint: '#ff6020', alpha: 0.18, mechanic: 'updraft', mechanicDesc: 'Warm updrafts slow falls' },
    { id: 'bg_forest', name: 'Forest', price: 150, tint: '#104010', alpha: 0.25, mechanic: 'branches', mechanicDesc: 'Branches bounce fruit up' },
    { id: 'bg_ocean', name: 'Ocean', price: 150, tint: '#001848', alpha: 0.3, mechanic: 'waves', mechanicDesc: 'Waves save falling fruit' },
    { id: 'bg_volcano', name: 'Volcano', price: 200, tint: '#400000', alpha: 0.3, mechanic: 'lava_pop', mechanicDesc: 'Lava bubbles pop fruit' },
    { id: 'bg_space', name: 'Space', price: 300, tint: '#000020', alpha: 0.55, mechanic: 'low_gravity', mechanicDesc: 'Low gravity, fruits float' },
    { id: 'bg_neon', name: 'Neon City', price: 400, tint: '#300040', alpha: 0.35, mechanic: 'platforms', mechanicDesc: 'Neon platforms bounce fruit' },
    { id: 'bg_frozen', name: 'Frozen Temple', price: 500, tint: '#c0e8ff', alpha: 0.2, mechanic: 'ice_shelf', mechanicDesc: 'Ice shelves catch fruit' },
];

const POWER_ITEMS = [
    { id: 'pow_extralife', name: 'Extra Life', price: 30, desc: 'Start with 4 lives' },
    { id: 'pow_headstart', name: 'Head Start', price: 40, desc: 'Start with 10 pts' },
    { id: 'pow_magnet', name: 'Coin Magnet', price: 60, desc: '2x coin earnings' },
    { id: 'pow_lucky', name: 'Lucky Star', price: 80, desc: 'More specials' },
    { id: 'pow_slow', name: 'Slow Start', price: 50, desc: 'Slower spawn 10s' },
    { id: 'pow_thick', name: 'Thick Blade', price: 100, desc: 'Wider hitbox' },
    { id: 'pow_combo', name: 'Combo Master', price: 120, desc: 'Longer combos' },
    { id: 'pow_shield', name: 'Shield Start', price: 150, desc: 'Start shielded' },
];

const EXTRA_ITEMS = [
    { id: 'ext_double', name: 'Double Points', price: 500, desc: '2x score' },
    { id: 'ext_defuser', name: 'Bomb Defuser', price: 400, desc: '50% less bombs' },
    { id: 'ext_frenzy', name: 'Fruit Frenzy', price: 350, desc: 'More fruits' },
    { id: 'ext_diamond', name: 'Diamond Finder', price: 300, desc: 'More diamonds' },
    { id: 'ext_revive', name: 'Second Chance', price: 600, desc: 'Free revive' },
    { id: 'ext_streak', name: 'Score Streak', price: 450, desc: 'Streak bonus' },
];

const SHOP_CATEGORIES = [
    { key: 'blades', label: 'Blades', items: BLADE_ITEMS },
    { key: 'backgrounds', label: 'BG', items: BG_ITEMS },
    { key: 'powers', label: 'Powers', items: POWER_ITEMS },
    { key: 'extras', label: 'Extras', items: EXTRA_ITEMS },
];

function loadShopData() {
    const raw = localStorage.getItem(SHOP_STORAGE_KEY);
    if (raw) {
        try {
            const data = JSON.parse(raw);
            // Ensure all fields exist
            if (!data.owned) data.owned = ['blade_classic', 'bg_classic'];
            if (!data.equipped) data.equipped = { blade: 'blade_classic', background: 'bg_classic', powers: [] };
            if (!data.equipped.powers) data.equipped.powers = [];
            if (!data.equipped.blade) data.equipped.blade = 'blade_classic';
            if (!data.equipped.background) data.equipped.background = 'bg_classic';
            if (typeof data.coins !== 'number') data.coins = 0;
            return data;
        } catch(e) {}
    }
    return {
        coins: 0,
        owned: ['blade_classic', 'bg_classic'],
        equipped: { blade: 'blade_classic', background: 'bg_classic', powers: [] }
    };
}

function saveShopData() {
    localStorage.setItem(SHOP_STORAGE_KEY, JSON.stringify(shopData));
}

let shopData = loadShopData();
shopData.coins = 99999; saveShopData(); // DEBUG: free coins for testing
let shopCategory = 0;
let shopScrollY = 0;
let shopScrollTarget = 0;
let shopDragging = false;
let shopDragStartY = 0;
let shopDragScrollStart = 0;
let shopLastDragY = 0;
let shopScrollVelocity = 0;
let coinsEarnedThisGame = 0;
let coinPopups = [];
let usedReviveThisGame = false;
let scoreStreak = 0;
let lastSliceWasMiss = false;

function getEquippedBlade() {
    const id = shopData.equipped.blade || 'blade_classic';
    return BLADE_ITEMS.find(b => b.id === id) || BLADE_ITEMS[0];
}

function getEquippedBg() {
    const id = shopData.equipped.background || 'bg_classic';
    return BG_ITEMS.find(b => b.id === id) || BG_ITEMS[0];
}

function hasPower(id) {
    return shopData.equipped.powers && shopData.equipped.powers.includes(id);
}

function hasExtra(id) {
    return shopData.owned && shopData.owned.includes(id);
}

function earnCoins(amount) {
    if (hasPower('pow_magnet')) amount *= 2;
    shopData.coins += amount;
    coinsEarnedThisGame += amount;
    saveShopData();
    return amount;
}

// Space background stars (generated once)
let spaceStars = [];
function initSpaceStars() {
    spaceStars = [];
    for (let i = 0; i < 120; i++) {
        spaceStars.push({
            x: Math.random() * W,
            y: Math.random() * H,
            size: 0.5 + Math.random() * 2,
            twinkleSpeed: 1 + Math.random() * 3,
            twinklePhase: Math.random() * Math.PI * 2,
        });
    }
}

function getAvailableModes() {
    const modes = ['blade'];
    if (unlockedArchery) modes.push('archery');
    if (unlockedSword) modes.push('sword');
    return modes;
}

function saveUnlocks() {
    localStorage.setItem(UNLOCK_STORAGE_KEY, JSON.stringify({ sword: unlockedSword, archery: unlockedArchery }));
}

// --- Visual Init ---
function initWoodKnots() {
    woodKnots = [];
    for (let i = 0; i < 6; i++) {
        const s1 = Math.sin(42 + i * 127.1) * 43758.5453;
        const s2 = Math.sin(42 + i * 269.5) * 43758.5453;
        woodKnots.push({
            x: (s1 - Math.floor(s1)) * W,
            y: (s2 - Math.floor(s2)) * H,
            size: 12 + (Math.sin(42 + i * 311.7) * 0.5 + 0.5) * 25
        });
    }
}

function initDustMotes() {
    dustMotes = [];
    for (let i = 0; i < 40; i++) {
        dustMotes.push({
            x: Math.random() * W,
            y: Math.random() * H,
            vy: -8 - Math.random() * 15,
            vx: (Math.random() - 0.5) * 8,
            size: 0.5 + Math.random() * 2,
            alpha: 0.05 + Math.random() * 0.15,
            phase: Math.random() * Math.PI * 2
        });
    }
}

function initStartScreenFruits() {
    startScreenFruits = [];
    for (let i = 0; i < 8; i++) {
        const type = FRUIT_TYPES[i % FRUIT_TYPES.length];
        startScreenFruits.push({
            x: W * 0.1 + Math.random() * W * 0.8,
            y: H * 0.1 + Math.random() * H * 0.8,
            vx: (Math.random() - 0.5) * 40,
            vy: (Math.random() - 0.5) * 40,
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 1.5,
            radius: type.radius * 0.55,
            name: type.name,
            outer: type.outer,
            inner: type.inner,
        });
    }
}

// --- Resize ---
function resize() {
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    initWoodKnots();
    initDustMotes();
    initStartScreenFruits();
    initSpaceStars();
}
window.addEventListener('resize', resize);
resize();

// --- Input ---
function getPos(e) {
    const t = e.touches ? e.touches[0] : e;
    return { x: t.clientX, y: t.clientY };
}

let shopTapStartPos = null;

canvas.addEventListener('mousedown', e => {
    isPointerDown = true; pointerPos = getPos(e); lastPointerPos = { ...pointerPos }; bladePoints = [{ ...pointerPos, t: performance.now() }];
    if (state === 'shop') {
        shopDragging = true; shopDragStartY = pointerPos.y; shopDragScrollStart = shopScrollY; shopLastDragY = pointerPos.y; shopScrollVelocity = 0;
        shopTapStartPos = { x: pointerPos.x, y: pointerPos.y };
    } else {
        handleStartInput();
    }
});
canvas.addEventListener('mousemove', e => {
    pointerPos = getPos(e);
    if (isPointerDown) bladePoints.push({ ...pointerPos, t: performance.now() });
    if (state === 'shop' && shopDragging && pointerPos.y > 110) {
        shopScrollVelocity = shopLastDragY - pointerPos.y;
        shopScrollY = shopDragScrollStart + (shopDragStartY - pointerPos.y);
        shopLastDragY = pointerPos.y;
        if (shopScrollY < 0) shopScrollY = 0;
    }
});
canvas.addEventListener('mouseup', () => {
    if (state === 'shop' && shopDragging) {
        const dragDist = shopTapStartPos ? Math.abs(pointerPos.y - shopTapStartPos.y) : 999;
        shopDragging = false; shopScrollTarget = shopScrollY;
        if (dragDist < 15) { handleShopInput(); }
        shopTapStartPos = null;
    }
    isPointerDown = false; bladePoints = []; lastPointerPos = null;
});
canvas.addEventListener('mouseleave', () => { isPointerDown = false; bladePoints = []; lastPointerPos = null; shopDragging = false; shopTapStartPos = null; });

// Mouse wheel scrolling for shop
canvas.addEventListener('wheel', e => {
    if (state === 'shop') {
        e.preventDefault();
        shopScrollY += e.deltaY;
        shopScrollTarget = shopScrollY;
        if (shopScrollY < 0) { shopScrollY = 0; shopScrollTarget = 0; }
    }
}, { passive: false });

canvas.addEventListener('touchstart', e => {
    e.preventDefault(); isPointerDown = true; pointerPos = getPos(e); lastPointerPos = { ...pointerPos }; bladePoints = [{ ...pointerPos, t: performance.now() }];
    if (state === 'shop') {
        shopDragging = true; shopDragStartY = pointerPos.y; shopDragScrollStart = shopScrollY; shopLastDragY = pointerPos.y; shopScrollVelocity = 0;
        shopTapStartPos = { x: pointerPos.x, y: pointerPos.y };
    } else {
        handleStartInput();
    }
}, { passive: false });
canvas.addEventListener('touchmove', e => {
    e.preventDefault(); pointerPos = getPos(e);
    if (isPointerDown) bladePoints.push({ ...pointerPos, t: performance.now() });
    if (state === 'shop' && shopDragging && pointerPos.y > 110) {
        shopScrollVelocity = shopLastDragY - pointerPos.y;
        shopScrollY = shopDragScrollStart + (shopDragStartY - pointerPos.y);
        shopLastDragY = pointerPos.y;
        if (shopScrollY < 0) shopScrollY = 0;
    }
}, { passive: false });
canvas.addEventListener('touchend', e => {
    e.preventDefault();
    if (state === 'shop' && shopDragging) {
        const dragDist = shopTapStartPos ? Math.abs(pointerPos.y - shopTapStartPos.y) : 999;
        shopDragging = false; shopScrollTarget = shopScrollY;
        if (dragDist < 15) { handleShopInput(); }
        shopTapStartPos = null;
    }
    isPointerDown = false; bladePoints = []; lastPointerPos = null;
}, { passive: false });
canvas.addEventListener('touchcancel', () => { isPointerDown = false; bladePoints = []; lastPointerPos = null; shopDragging = false; shopTapStartPos = null; });

function fireArrow(targetX, targetY) {
    // If click is on a fruit, lock on to that fruit
    let targetFruit = null;
    for (const fruit of fruits) {
        if (fruit.sliced) continue;
        const dx = targetX - fruit.x;
        const dy = targetY - fruit.y;
        if (dx * dx + dy * dy <= fruit.radius * fruit.radius) {
            targetFruit = fruit;
            break;
        }
    }
    const startX = W / 2;
    const startY = H + 20;
    const aimX = targetFruit ? targetFruit.x : targetX;
    const aimY = targetFruit ? targetFruit.y : targetY;
    const dx = aimX - startX;
    const dy = aimY - startY;
    const dist = Math.hypot(dx, dy) || 1;
    arrows.push({
        x: startX, y: startY,
        vx: (dx / dist) * ARROW_SPEED,
        vy: (dy / dist) * ARROW_SPEED,
        angle: Math.atan2(dy, dx),
        life: 1.5,
        target: targetFruit,
    });
}

function handleStartInput() {
    if (state === 'playing') {
        // Check restart button (bottom-center)
        const rbtnX = W / 2, rbtnY = H - 30, rbtnW = 100, rbtnH = 32;
        if (pointerPos.x > rbtnX - rbtnW/2 && pointerPos.x < rbtnX + rbtnW/2 &&
            pointerPos.y > rbtnY - rbtnH/2 && pointerPos.y < rbtnY + rbtnH/2) {
            startGame();
            return;
        }
        if (currentMode === 'archery') {
            fireArrow(pointerPos.x, pointerPos.y);
            return;
        }
        return;
    }
    if (state === 'gameover') {
        state = 'start';
        return;
    }
    if (state === 'start') {
        // Check if tap is on the SHOP button (bottom center area)
        const shopBtnY = H * 0.82;
        const shopBtnW = 160;
        const shopBtnH = 48;
        if (pointerPos.x > W / 2 - shopBtnW / 2 && pointerPos.x < W / 2 + shopBtnW / 2 &&
            pointerPos.y > shopBtnY - shopBtnH / 2 && pointerPos.y < shopBtnY + shopBtnH / 2) {
            state = 'shop';
            shopCategory = 0;
            shopScrollY = 0;
            shopScrollTarget = 0;
            shopScrollVelocity = 0;
            return;
        }

        const modes = getAvailableModes();
        if (modes.length > 1) {
            // Check if tap is in the mode selector area
            if (pointerPos.y > H * 0.42 && pointerPos.y < H * 0.56) {
                selectedModeIndex = (selectedModeIndex + 1) % modes.length;
                currentMode = modes[selectedModeIndex];
                return;
            }
        }
        currentMode = modes[selectedModeIndex] || 'blade';
        startGame();
    }
}

// --- Shop Input Handling ---
function handleShopInput() {
    const px = pointerPos.x;
    const py = pointerPos.y;

    // Back button (top-left)
    if (px < 100 && py < 60) {
        state = 'start';
        return;
    }

    // Category tabs (top bar)
    const tabY = 55;
    const tabH = 40;
    if (py >= tabY && py <= tabY + tabH) {
        const tabW = W / SHOP_CATEGORIES.length;
        const tabIdx = Math.floor(px / tabW);
        if (tabIdx >= 0 && tabIdx < SHOP_CATEGORIES.length) {
            shopCategory = tabIdx;
            shopScrollY = 0;
            shopScrollTarget = 0;
        }
        return;
    }

    // Item grid tap
    const gridTop = 110;
    if (py > gridTop) {
        const cat = SHOP_CATEGORIES[shopCategory];
        const items = cat.items;
        const cols = Math.max(2, Math.min(4, Math.floor(W / 140)));
        const cardW = (W - 20) / cols - 10;
        const hasGameplayDescInput = (cat.key === 'blades' || cat.key === 'backgrounds');
        const cardH = hasGameplayDescInput ? 150 : 130;
        const adjustedY = py + shopScrollY - gridTop;
        const row = Math.floor(adjustedY / (cardH + 10));
        const col = Math.floor((px - 15) / (cardW + 10));
        const idx = row * cols + col;

        if (idx >= 0 && idx < items.length) {
            const item = items[idx];
            const isOwned = shopData.owned.includes(item.id);

            if (!isOwned) {
                // Buy
                if (shopData.coins >= item.price) {
                    shopData.coins -= item.price;
                    shopData.owned.push(item.id);
                    // Auto-equip if it's the first of its type
                    if (cat.key === 'blades') shopData.equipped.blade = item.id;
                    else if (cat.key === 'backgrounds') shopData.equipped.background = item.id;
                    else if (cat.key === 'powers') {
                        if (!shopData.equipped.powers) shopData.equipped.powers = [];
                        shopData.equipped.powers.push(item.id);
                    }
                    saveShopData();
                }
            } else {
                // Equip / toggle
                if (cat.key === 'blades') {
                    shopData.equipped.blade = item.id;
                    saveShopData();
                } else if (cat.key === 'backgrounds') {
                    shopData.equipped.background = item.id;
                    saveShopData();
                } else if (cat.key === 'powers') {
                    if (!shopData.equipped.powers) shopData.equipped.powers = [];
                    const idx2 = shopData.equipped.powers.indexOf(item.id);
                    if (idx2 >= 0) {
                        shopData.equipped.powers.splice(idx2, 1);
                    } else {
                        shopData.equipped.powers.push(item.id);
                    }
                    saveShopData();
                }
                // Extras: no toggle, just owned
            }
        }
    }
}

// --- Game Logic ---
function triggerGameOver() {
    // Second Chance revive
    if (hasExtra('ext_revive') && !usedReviveThisGame) {
        usedReviveThisGame = true;
        lives = 1;
        popups.push({
            x: W / 2, y: H * 0.4,
            text: 'SECOND CHANCE!',
            life: 1.5, vy: -80, size: 36,
            color: '#ffdd44', scale: 1.8,
        });
        screenFlash = 0.3;
        return; // Don't go to gameover
    }
    state = 'gameover';
    if (score > bestScore) {
        bestScore = score;
        localStorage.setItem(STORAGE_KEY, bestScore);
    }
    checkAndApplyUnlocks();
}

function startGame() {
    state = 'playing';
    score = 0;
    unlockMessage = '';
    lives = MAX_LIVES;
    gameTime = 0;
    spawnTimer = 0;
    spawnInterval = 1.8;
    comboCount = 0;
    comboTimer = 0;
    fruits = [];
    halves = [];
    particles = [];
    popups = [];
    bombs = [];
    splatters = [];
    screenShake = { x: 0, y: 0, timer: 0 };
    screenFlash = 0;
    bladeSparkles = [];
    shockwaves = [];
    sliceLines = [];
    arrows = [];
    timeScale = 1;
    slowMoTimer = 0;
    hourglassTimer = 0;
    hourglassActive = false;
    shieldActive = false;
    coinsEarnedThisGame = 0;
    coinPopups = [];
    usedReviveThisGame = false;
    scoreStreak = 0;
    lastSliceWasMiss = false;
    bladeSliceCount = 0;
    stormTimer = 0;
    meteorTimer = 0;

    // Reset blade/bg ability state
    chainSlicing = false;
    lightningBolts = [];
    lavaBubbles = [];
    lavaBubbleTimer = 3 + Math.random() * 2;
    wavePhase = 0;

    // Initialize bg platforms based on equipped background
    bgPlatforms = [];
    const startBg = getEquippedBg();
    if (startBg.mechanic === 'branches') {
        // 2-3 wooden branch platforms
        const numBranches = 2 + Math.floor(Math.random() * 2);
        for (let i = 0; i < numBranches; i++) {
            bgPlatforms.push({
                x: W * 0.1 + Math.random() * W * 0.6,
                y: H * 0.4 + Math.random() * H * 0.35,
                width: 80 + Math.random() * 60,
                type: 'branch',
            });
        }
    } else if (startBg.mechanic === 'platforms') {
        // 3 neon platforms
        const colors = ['#ff44aa', '#44ffff', '#ffff44'];
        for (let i = 0; i < 3; i++) {
            bgPlatforms.push({
                x: W * 0.1 + Math.random() * W * 0.6,
                y: H * 0.35 + Math.random() * H * 0.35,
                width: 80 + Math.random() * 50,
                type: 'neon',
                color: colors[i],
            });
        }
    } else if (startBg.mechanic === 'ice_shelf') {
        // 2 ice platforms
        for (let i = 0; i < 2; i++) {
            bgPlatforms.push({
                x: W * 0.15 + Math.random() * W * 0.5,
                y: H * 0.45 + Math.random() * H * 0.3,
                width: 100 + Math.random() * 60,
                type: 'ice',
            });
        }
    }

    // Apply powerups
    if (hasPower('pow_extralife')) lives = MAX_LIVES + 1;
    if (hasPower('pow_headstart')) score = 10;
    if (hasPower('pow_shield')) shieldActive = true;
    if (hasPower('pow_slow')) spawnInterval = 3.5; // slower initial spawning
}

function spawnFruit() {
    const type = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
    const xMin = W * 0.15;
    const xMax = W * 0.85;
    const x = xMin + Math.random() * (xMax - xMin);
    const targetY = H * (0.15 + Math.random() * 0.3);
    const vy = -Math.sqrt(2 * GRAVITY * (H - targetY + 50));
    const vx = (Math.random() - 0.5) * 300;

    fruits.push({
        x, y: H + type.radius + 10,
        vx, vy,
        radius: type.radius,
        points: type.points,
        name: type.name,
        outer: type.outer,
        inner: type.inner,
        juice: type.juice,
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 6,
        sliced: false,
        missed: false,
        isBomb: false,
    });
}

function spawnBomb() {
    const x = W * 0.2 + Math.random() * W * 0.6;
    const targetY = H * (0.2 + Math.random() * 0.25);
    const vy = -Math.sqrt(2 * GRAVITY * (H - targetY + 50));
    const vx = (Math.random() - 0.5) * 250;

    fruits.push({
        x, y: H + 40,
        vx, vy,
        radius: 30,
        points: 0,
        name: 'bomb',
        outer: '#222',
        inner: '#444',
        juice: '#ff4400',
        rotation: 0,
        rotSpeed: (Math.random() - 0.5) * 4,
        sliced: false,
        missed: false,
        isBomb: true,
        fuseAngle: 0,
    });
}

function spawnSpecial() {
    // Weighted random selection (diamond is rare)
    // Diamond Finder extra boosts diamond rarity
    const modifiedTypes = SPECIAL_TYPES.map(t => {
        if (t.name === 'diamond' && hasExtra('ext_diamond')) {
            return { ...t, rarity: t.rarity * 3 };
        }
        return t;
    });
    const totalWeight = modifiedTypes.reduce((sum, t) => sum + t.rarity, 0);
    let roll = Math.random() * totalWeight;
    let type = modifiedTypes[0];
    for (const t of modifiedTypes) {
        roll -= t.rarity;
        if (roll <= 0) { type = t; break; }
    }

    const x = W * 0.15 + Math.random() * W * 0.7;
    const targetY = H * (0.15 + Math.random() * 0.3);
    const vy = -Math.sqrt(2 * GRAVITY * (H - targetY + 50));
    const vx = (Math.random() - 0.5) * 280;

    fruits.push({
        x, y: H + type.radius + 10,
        vx, vy,
        radius: type.radius,
        points: type.points,
        name: type.name,
        outer: type.color,
        inner: type.glow,
        juice: type.particles,
        rotation: Math.random() * Math.PI * 2,
        rotSpeed: (Math.random() - 0.5) * 5,
        sliced: false,
        missed: false,
        isBomb: false,
        isSpecial: true,
        specialType: type,
    });
}

function sliceSpecial(fruit) {
    const type = fruit.specialType;

    // Rock: can't be sliced (Ghost Blade phases through safely)
    if (type.unsliceable) {
        if (getEquippedBlade().bonus === 'phase') {
            // Ghost Blade: pass through rocks harmlessly, get +3
            fruit.sliced = true;
            score += 3;
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 60 + Math.random() * 200;
                particles.push({ x: fruit.x, y: fruit.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0.4 + Math.random() * 0.4, maxLife: 0.8, radius: 2 + Math.random() * 3, color: 'rgba(200,200,200,0.6)' });
            }
            popups.push({ x: fruit.x, y: fruit.y - 30, text: 'PHASED! +3', life: 1, vy: -80, size: 28, color: '#ccccff', scale: 1.3 });
            return;
        }
        fruit.sliced = false; // stays on screen
        // Spark particles
        for (let i = 0; i < 15; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 80 + Math.random() * 300;
            particles.push({
                x: fruit.x, y: fruit.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 0.3 + Math.random() * 0.4,
                maxLife: 0.7,
                radius: 1 + Math.random() * 3,
                color: Math.random() > 0.5 ? '#ffdd88' : '#ffffff',
            });
        }
        screenShake = { x: 0, y: 0, timer: 0.25 };
        lives--;
        popups.push({
            x: fruit.x, y: fruit.y - 30,
            text: 'CLANG!',
            life: 1.2,
            vy: -90,
            size: 36,
            color: '#cccccc',
            scale: 1.5,
        });
        if (lives <= 0) {
            triggerGameOver();
        }
        return;
    }

    fruit.sliced = true;

    // Burst particles (no halves for specials)
    for (let i = 0; i < 25; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 60 + Math.random() * 350;
        particles.push({
            x: fruit.x + (Math.random() - 0.5) * fruit.radius * 0.5,
            y: fruit.y + (Math.random() - 0.5) * fruit.radius * 0.5,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.4 + Math.random() * 0.7,
            maxLife: 1.1,
            radius: 2 + Math.random() * 5,
            color: type.particles,
        });
    }

    screenFlash = 0.15;
    screenShake = { x: 0, y: 0, timer: Math.max(screenShake.timer, 0.08) };
    timeScale = 0.25;
    slowMoTimer = 0.08;

    // Earn coins for slicing specials
    let specialCoins = 1;
    if (type.name === 'star') specialCoins = 3;
    else if (type.name === 'diamond') specialCoins = 5;
    else if (type.name === 'coin') specialCoins = 2;
    if (type.name !== 'skull' && type.name !== 'poison') {
        const earned = earnCoins(specialCoins);
        coinPopups.push({ x: fruit.x + 30, y: fruit.y - 20, text: '+' + earned + ' coin' + (earned > 1 ? 's' : ''), life: 1.0, vy: -60 });
    }

    // Apply effect
    switch (type.name) {
        case 'star':
        case 'diamond':
        case 'coin': {
            const specialPts = hasExtra('ext_double') ? type.points * 2 : type.points;
            score += specialPts;
            popups.push({
                x: fruit.x, y: fruit.y,
                text: '+' + specialPts,
                life: 1.2,
                vy: -80,
                size: type.name === 'diamond' ? 42 : 34,
                color: type.glow,
                scale: type.name === 'diamond' ? 1.6 : 1.3,
            });
            break;
        }
        case 'heart':
            lives = MAX_LIVES;
            popups.push({
                x: fruit.x, y: fruit.y,
                text: 'FULL LIVES!',
                life: 1.2,
                vy: -80,
                size: 32,
                color: '#ff6688',
                scale: 1.4,
            });
            break;
        case 'hourglass':
            hourglassActive = true;
            hourglassTimer = 4;
            popups.push({
                x: fruit.x, y: fruit.y,
                text: 'SLOW TIME!',
                life: 1.2,
                vy: -80,
                size: 32,
                color: '#88bbff',
                scale: 1.4,
            });
            break;
        case 'shield':
            shieldActive = true;
            popups.push({
                x: fruit.x, y: fruit.y,
                text: 'SHIELD ON!',
                life: 1.2,
                vy: -80,
                size: 32,
                color: '#88ccff',
                scale: 1.4,
            });
            break;
        case 'skull':
            lives--;
            popups.push({
                x: fruit.x, y: fruit.y,
                text: 'CURSED!',
                life: 1.2,
                vy: -80,
                size: 34,
                color: '#44ff44',
                scale: 1.4,
            });
            if (lives <= 0) {
                triggerGameOver();
            }
            break;
        case 'poison':
            if (getEquippedBlade().bonus === 'poison_immune') {
                score += 5;
                popups.push({
                    x: fruit.x, y: fruit.y,
                    text: '+5 IMMUNE!',
                    life: 1.2,
                    vy: -80,
                    size: 34,
                    color: '#88ff88',
                    scale: 1.3,
                });
            } else {
                score = Math.max(0, score - 5);
                popups.push({
                    x: fruit.x, y: fruit.y,
                    text: '-5',
                    life: 1.2,
                    vy: -80,
                    size: 34,
                    color: '#44ff44',
                    scale: 1.3,
                });
            }
            break;
    }
}

function sliceFruit(fruit) {
    // Route specials to their own handler
    if (fruit.isSpecial) {
        sliceSpecial(fruit);
        return;
    }

    fruit.sliced = true;

    if (fruit.isBomb) {
        // Shield absorption
        if (shieldActive) {
            shieldActive = false;
            // Shield absorb particles
            for (let i = 0; i < 25; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 80 + Math.random() * 300;
                particles.push({
                    x: fruit.x, y: fruit.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 0.4 + Math.random() * 0.6,
                    maxLife: 1.0,
                    radius: 2 + Math.random() * 5,
                    color: Math.random() > 0.5 ? '#88ccff' : '#ffffff',
                });
            }
            screenShake = { x: 0, y: 0, timer: 0.2 };
            screenFlash = 0.2;
            popups.push({
                x: fruit.x, y: fruit.y,
                text: 'SHIELD BLOCKED!',
                life: 1.4,
                vy: -90,
                size: 34,
                color: '#88ccff',
                scale: 1.5,
            });
            return;
        }
        // Lava Blade: bombs give +5 points instead of death
        if (getEquippedBlade().bonus === 'melt_bombs') {
            score += 5;
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 60 + Math.random() * 200;
                particles.push({ x: fruit.x, y: fruit.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0.4 + Math.random() * 0.5, maxLife: 0.9, radius: 2 + Math.random() * 4, color: Math.random() > 0.5 ? '#ff8800' : '#ffcc00' });
            }
            screenShake = { x: 0, y: 0, timer: 0.15 };
            screenFlash = 0.15;
            popups.push({ x: fruit.x, y: fruit.y, text: 'MELTED! +5', life: 1.2, vy: -90, size: 32, color: '#ffaa00', scale: 1.4 });
            return;
        }
        // Bomb explosion particles
        for (let i = 0; i < 40; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 100 + Math.random() * 500;
            particles.push({
                x: fruit.x, y: fruit.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 0.5 + Math.random() * 0.7,
                maxLife: 1.2,
                radius: 3 + Math.random() * 6,
                color: Math.random() > 0.5 ? '#ff4400' : '#ffaa00',
                isBombParticle: true,
            });
        }
        // Add shockwave
        shockwaves.push({
            x: fruit.x, y: fruit.y,
            radius: 10, maxRadius: 200,
            life: 0.6, maxLife: 0.6
        });
        // Screen shake
        screenShake = { x: 0, y: 0, timer: 0.4 };
        // Screen flash (red tint for bomb)
        screenFlash = 0.3;

        triggerGameOver();
        return;
    }

    // Successful slice resets consecutive miss counter
    lives = MAX_LIVES;

    // Score
    comboCount++;
    const comboTime = hasPower('pow_combo') ? 0.8 : 0.5;
    comboTimer = comboTime;
    let pts = fruit.points;
    if (hasExtra('ext_double')) pts *= 2;
    // Crystal Blade: 30% chance double points
    const blade = getEquippedBlade();
    if (blade.bonus === 'double_chance' && Math.random() < 0.3) {
        pts *= 2;
        popups.push({ x: fruit.x + 20, y: fruit.y - 50, text: '2X!', life: 0.8, vy: -100, size: 28, color: '#aaddff', scale: 1.6 });
    }
    score += pts;

    // Score streak bonus
    if (hasExtra('ext_streak')) {
        scoreStreak++;
        if (scoreStreak >= 5) {
            const bonus = Math.floor(scoreStreak / 5);
            score += bonus;
        }
    }

    // Earn coin
    const earned = earnCoins(1);
    coinPopups.push({ x: fruit.x + 25, y: fruit.y - 15, text: '+' + earned, life: 0.8, vy: -50 });

    // Golden Blade: +2 extra coins per slice
    if (blade.bonus === 'bonus_coins') {
        const extraCoins = earnCoins(2);
        coinPopups.push({ x: fruit.x - 20, y: fruit.y - 25, text: '+' + extraCoins + ' gold', life: 0.8, vy: -60 });
    }

    // Rainbow Blade: random bonus each slice
    if (blade.bonus === 'random_bonus') {
        const roll = Math.random();
        if (roll < 0.25) {
            score += 3;
            popups.push({ x: fruit.x - 30, y: fruit.y - 40, text: '+3 BONUS', life: 0.8, vy: -90, size: 22, color: '#ff88ff', scale: 1.2 });
        } else if (roll < 0.5) {
            lives = Math.min(lives + 1, MAX_LIVES);
            popups.push({ x: fruit.x - 30, y: fruit.y - 40, text: '+1 LIFE', life: 0.8, vy: -90, size: 22, color: '#ff6688', scale: 1.2 });
        } else if (roll < 0.75) {
            const bonusCoins = earnCoins(5);
            coinPopups.push({ x: fruit.x - 30, y: fruit.y - 35, text: '+' + bonusCoins + ' coins!', life: 0.8, vy: -60 });
        } else {
            shieldActive = true;
            popups.push({ x: fruit.x - 30, y: fruit.y - 40, text: 'SHIELD!', life: 0.8, vy: -90, size: 22, color: '#88ccff', scale: 1.2 });
            // Shield will last 2 seconds (set a timer in update)
            setTimeout(() => { shieldActive = false; }, 2000);
        }
    }

    // Screen flash (white for slice)
    screenFlash = 0.12;

    // Mini screen shake on slice
    screenShake = { x: 0, y: 0, timer: Math.max(screenShake.timer, 0.08) };

    // Brief slow-motion for impact feel
    timeScale = 0.25;
    slowMoTimer = 0.08;

    // Compute blade direction for slice line visual
    const now = performance.now();
    const recentBlade = bladePoints.filter(p => now - p.t < 120);
    let totalBladeDist = 0;
    for (let i = 1; i < recentBlade.length; i++) {
        totalBladeDist += Math.hypot(recentBlade[i].x - recentBlade[i-1].x, recentBlade[i].y - recentBlade[i-1].y);
    }
    if (recentBlade.length >= 2 && totalBladeDist >= MIN_SLICE_SPEED) {
        const bp0 = recentBlade[0];
        const bp1 = recentBlade[recentBlade.length - 1];
        const dx = bp1.x - bp0.x;
        const dy = bp1.y - bp0.y;
        const len = Math.hypot(dx, dy) || 1;
        const nx = dx / len;
        const ny = dy / len;
        const sliceLen = fruit.radius * 2.5;
        sliceLines.push({
            x1: fruit.x - nx * sliceLen, y1: fruit.y - ny * sliceLen,
            x2: fruit.x + nx * sliceLen, y2: fruit.y + ny * sliceLen,
            life: 0.25, maxLife: 0.25,
            color: fruit.juice,
        });
    } else {
        // Tap slice — random angle slash
        const angle = Math.random() * Math.PI;
        const nx = Math.cos(angle);
        const ny = Math.sin(angle);
        const sliceLen = fruit.radius * 2.5;
        sliceLines.push({
            x1: fruit.x - nx * sliceLen, y1: fruit.y - ny * sliceLen,
            x2: fruit.x + nx * sliceLen, y2: fruit.y + ny * sliceLen,
            life: 0.25, maxLife: 0.25,
            color: fruit.juice,
        });
    }

    // Score popup
    popups.push({
        x: fruit.x, y: fruit.y,
        text: '+' + pts,
        life: 1,
        vy: -80,
        size: 34,
        color: '#fff',
        scale: 1.3,
    });

    // Combo popup with scale bounce (Candy Blade: starts at 2)
    const comboThreshold = getEquippedBlade().bonus === 'sweet' ? 2 : 3;
    if (comboCount >= comboThreshold) {
        let bonus = comboCount;
        if (hasExtra('ext_double')) bonus *= 2;
        score += bonus;
        popups.push({
            x: fruit.x, y: fruit.y - 40,
            text: comboCount + 'x COMBO +' + bonus,
            life: 1.4,
            vy: -110,
            size: 28,
            color: '#ffdd44',
            scale: 2.2,
            isCombo: true,
        });
    }

    // Create two halves — fly apart faster for dramatic split
    for (let side = -1; side <= 1; side += 2) {
        halves.push({
            x: fruit.x, y: fruit.y,
            vx: side * (140 + Math.random() * 160),
            vy: -150 - Math.random() * 120,
            radius: fruit.radius,
            name: fruit.name,
            outer: fruit.outer,
            inner: fruit.inner,
            juice: fruit.juice,
            rotation: fruit.rotation,
            rotSpeed: side * (6 + Math.random() * 8),
            side: side,
            life: 2.5,
        });
    }

    // Juice particles — more, bigger, varied speeds
    for (let i = 0; i < 38; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 40 + Math.random() * 450;
        particles.push({
            x: fruit.x + (Math.random() - 0.5) * fruit.radius * 0.5,
            y: fruit.y + (Math.random() - 0.5) * fruit.radius * 0.5,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.5 + Math.random() * 0.9,
            maxLife: 1.4,
            radius: 1.5 + Math.random() * 6.5,
            color: fruit.juice,
        });
    }

    // Big juice drops (fewer, heavier, more visible)
    for (let i = 0; i < 6; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 80 + Math.random() * 200;
        particles.push({
            x: fruit.x, y: fruit.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 60,
            life: 0.8 + Math.random() * 0.8,
            maxLife: 1.6,
            radius: 5 + Math.random() * 5,
            color: fruit.outer,
        });
    }

    // Juice splatters (persistent marks on background)
    for (let i = 0; i < 5; i++) {
        splatters.push({
            x: fruit.x + (Math.random() - 0.5) * fruit.radius * 3,
            y: fruit.y + (Math.random() - 0.5) * fruit.radius * 3,
            radius: 10 + Math.random() * 25,
            color: fruit.juice,
            life: 4.0,
            maxLife: 4.0,
        });
        if (splatters.length > MAX_SPLATTERS) splatters.shift();
    }

    // Fire Blade: explode nearby fruits (120px radius)
    if (blade.bonus === 'explode' && !chainSlicing) {
        chainSlicing = true;
        for (const other of fruits) {
            if (other.sliced || other === fruit || other.isBomb) continue;
            const dx = other.x - fruit.x;
            const dy = other.y - fruit.y;
            if (Math.hypot(dx, dy) <= 120) {
                sliceFruit(other);
            }
        }
        chainSlicing = false;
        // Explosion visual
        shockwaves.push({ x: fruit.x, y: fruit.y, radius: 10, maxRadius: 120, life: 0.4, maxLife: 0.4 });
    }

    // Lightning Blade: chain to up to 2 nearby unsliced fruits (200px)
    if (blade.bonus === 'chain' && !chainSlicing) {
        chainSlicing = true;
        // Find nearest unsliced non-bomb fruits within 200px
        const candidates = [];
        for (const other of fruits) {
            if (other.sliced || other === fruit || other.isBomb) continue;
            const dist = Math.hypot(other.x - fruit.x, other.y - fruit.y);
            if (dist <= 200) {
                candidates.push({ fruit: other, dist });
            }
        }
        candidates.sort((a, b) => a.dist - b.dist);
        const chainTargets = candidates.slice(0, 2);
        for (const target of chainTargets) {
            // Visual lightning bolt
            lightningBolts.push({
                x1: fruit.x, y1: fruit.y,
                x2: target.fruit.x, y2: target.fruit.y,
                life: 0.3, maxLife: 0.3,
            });
            sliceFruit(target.fruit);
        }
        chainSlicing = false;
    }

    // Plasma Blade: bonus coin per slice
    if (blade.bonus === 'magnet') {
        const extraC = earnCoins(1);
        coinPopups.push({ x: fruit.x - 15, y: fruit.y - 35, text: '+' + extraC + ' magnet', life: 0.7, vy: -55 });
    }

    // Blood Blade: every 5 slices heals 1 life
    if (blade.bonus === 'lifesteal') {
        bladeSliceCount++;
        if (bladeSliceCount % 5 === 0) {
            lives = Math.min(lives + 1, MAX_LIVES + 1);
            popups.push({ x: fruit.x, y: fruit.y - 50, text: 'LIFESTEAL!', life: 1, vy: -90, size: 24, color: '#ff4444', scale: 1.3 });
        }
    }

    // Solar Blade: +1 point to all fruits
    if (blade.bonus === 'sunburn') {
        score += 1;
    }

    // Candy Blade: combos start at 2 instead of 3 (handled via comboCount check later)
    // Nature Blade: 25% chance sliced fruit regrows as a new fruit worth +1
    if (blade.bonus === 'regrow' && Math.random() < 0.25 && !chainSlicing) {
        const type = FRUIT_TYPES[Math.floor(Math.random() * FRUIT_TYPES.length)];
        const targetY = H * (0.2 + Math.random() * 0.3);
        fruits.push({
            x: fruit.x + (Math.random() - 0.5) * 60, y: fruit.y,
            vx: (Math.random() - 0.5) * 200,
            vy: -Math.sqrt(2 * GRAVITY * (H - targetY + 30)),
            radius: type.radius, points: type.points + 1,
            name: type.name, outer: type.outer, inner: type.inner, juice: type.juice,
            rotation: Math.random() * Math.PI * 2, rotSpeed: (Math.random() - 0.5) * 6,
            sliced: false, missed: false, isBomb: false,
        });
        popups.push({ x: fruit.x, y: fruit.y - 45, text: 'REGROW!', life: 0.8, vy: -80, size: 22, color: '#88ff88', scale: 1.2 });
    }
}

function segmentCircleIntersect(ax, ay, bx, by, cx, cy, r) {
    const dx = bx - ax, dy = by - ay;
    const fx = ax - cx, fy = ay - cy;
    const a = dx * dx + dy * dy;
    const b = 2 * (fx * dx + fy * dy);
    const c = fx * fx + fy * fy - r * r;
    let discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return false;
    discriminant = Math.sqrt(discriminant);
    const t1 = (-b - discriminant) / (2 * a);
    const t2 = (-b + discriminant) / (2 * a);
    return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1);
}

const MIN_SLICE_SPEED = 8; // minimum pixel distance per blade segment to count as a swipe

function checkSlicing() {
    if (!isPointerDown) return;

    const bladeBonus = getEquippedBlade().bonus;

    // --- Swipe check (Blade mode) ---
    if (currentMode === 'blade') {
        if (bladePoints.length >= 2) {
            const now = performance.now();
            const recent = bladePoints.filter(p => now - p.t < 100);
            if (recent.length >= 2) {
                let totalDist = 0;
                for (let i = 1; i < recent.length; i++) {
                    totalDist += Math.hypot(recent[i].x - recent[i-1].x, recent[i].y - recent[i-1].y);
                }
                if (totalDist >= MIN_SLICE_SPEED) {
                    for (let i = 1; i < recent.length; i++) {
                        const a = recent[i - 1];
                        const b = recent[i];
                        const segLen = Math.hypot(b.x - a.x, b.y - a.y);
                        if (segLen < 2) continue;
                        for (const fruit of fruits) {
                            if (fruit.sliced) continue;
                            let sliceRadius = hasPower('pow_thick') ? fruit.radius * 1.4 : fruit.radius;
                            // Shadow Blade: +50% blade width (stacks with thick blade)
                            if (bladeBonus === 'wider') sliceRadius *= 1.5;
                            if (segmentCircleIntersect(a.x, a.y, b.x, b.y, fruit.x, fruit.y, sliceRadius)) {
                                sliceFruit(fruit);
                            }
                        }
                    }
                }
            }
        }

        // Dragon Blade: lingering trail hitbox (check trail from last 500ms)
        if (bladeBonus === 'fire_breath' && bladePoints.length >= 2) {
            const now = performance.now();
            const trailPoints = bladePoints.filter(p => now - p.t < 500 && now - p.t >= 100);
            for (let i = 1; i < trailPoints.length; i++) {
                const a = trailPoints[i - 1];
                const b = trailPoints[i];
                for (const fruit of fruits) {
                    if (fruit.sliced) continue;
                    let sliceRadius = hasPower('pow_thick') ? fruit.radius * 1.4 : fruit.radius;
                    if (segmentCircleIntersect(a.x, a.y, b.x, b.y, fruit.x, fruit.y, sliceRadius)) {
                        sliceFruit(fruit);
                    }
                }
            }
        }
    }

    // --- Tap check (Sword mode) ---
    if (currentMode === 'sword') {
        for (const fruit of fruits) {
            if (fruit.sliced) continue;
            const dx = pointerPos.x - fruit.x;
            const dy = pointerPos.y - fruit.y;
            let swordR = hasPower('pow_thick') ? fruit.radius * 1.4 : fruit.radius;
            // Shadow Blade: +50% blade width in sword mode too
            if (bladeBonus === 'wider') swordR *= 1.5;
            if (dx * dx + dy * dy <= swordR * swordR) {
                sliceFruit(fruit);
            }
        }
    }
}

function checkAndApplyUnlocks() {
    if (!unlockedArchery && score >= ARCHERY_THRESHOLD) {
        unlockedArchery = true;
        unlockMessage = 'ARCHERY MODE UNLOCKED!';
        saveUnlocks();
    } else if (unlockedArchery && !unlockedSword && score >= SWORD_THRESHOLD) {
        unlockedSword = true;
        unlockMessage = 'SWORD MODE UNLOCKED!';
        saveUnlocks();
    }
}

function update(dt) {
    // Update dust motes always
    for (const d of dustMotes) {
        d.y += d.vy * dt;
        d.x += d.vx * dt + Math.sin(performance.now() * 0.001 + d.phase) * 0.3;
        if (d.y < -10) { d.y = H + 10; d.x = Math.random() * W; }
        if (d.x < -10) d.x = W + 10;
        if (d.x > W + 10) d.x = -10;
    }

    // Update start screen fruits
    if (state === 'start') {
        for (const f of startScreenFruits) {
            f.x += f.vx * dt;
            f.y += f.vy * dt;
            f.rotation += f.rotSpeed * dt;
            if (f.x < f.radius) { f.x = f.radius; f.vx *= -1; }
            if (f.x > W - f.radius) { f.x = W - f.radius; f.vx *= -1; }
            if (f.y < f.radius) { f.y = f.radius; f.vy *= -1; }
            if (f.y > H - f.radius) { f.y = H - f.radius; f.vy *= -1; }
        }
    }

    if (state !== 'playing') return;

    gameTime += dt;

    // Slow-motion decay (use real dt, not scaled)
    if (slowMoTimer > 0) {
        slowMoTimer -= dt;
        if (slowMoTimer <= 0) {
            timeScale = 1;
            slowMoTimer = 0;
        } else {
            // Ease back toward normal speed
            timeScale = 0.25 + (1 - 0.25) * (1 - slowMoTimer / 0.08);
        }
    }

    // Slice lines fade
    for (const sl of sliceLines) sl.life -= dt;
    sliceLines = sliceLines.filter(sl => sl.life > 0);

    // Screen shake decay
    if (screenShake.timer > 0) {
        screenShake.timer -= dt;
        const intensity = screenShake.timer * 30;
        screenShake.x = (Math.random() - 0.5) * intensity;
        screenShake.y = (Math.random() - 0.5) * intensity;
    } else {
        screenShake.x = 0;
        screenShake.y = 0;
    }

    // Screen flash decay
    if (screenFlash > 0) screenFlash -= dt * 4;

    // Splatters fade
    for (const s of splatters) s.life -= dt;
    splatters = splatters.filter(s => s.life > 0);

    // Shockwaves
    for (const sw of shockwaves) {
        sw.life -= dt;
        sw.radius += (sw.maxRadius - 10) * dt / sw.maxLife;
    }
    shockwaves = shockwaves.filter(sw => sw.life > 0);

    // Blade sparkles
    if (isPointerDown && bladePoints.length >= 2) {
        const last = bladePoints[bladePoints.length - 1];
        const prev = bladePoints[bladePoints.length - 2];
        const speed = Math.hypot(last.x - prev.x, last.y - prev.y);
        if (speed > 2) {
            const sparkCount = speed > 15 ? 4 : 2;
            for (let i = 0; i < sparkCount; i++) {
                bladeSparkles.push({
                    x: last.x + (Math.random() - 0.5) * 14,
                    y: last.y + (Math.random() - 0.5) * 14,
                    vx: (Math.random() - 0.5) * 80,
                    vy: (Math.random() - 0.5) * 80 - 40,
                    life: 0.3 + Math.random() * 0.4,
                    maxLife: 0.7,
                    radius: 1 + Math.random() * 3,
                });
            }
        }
    }
    for (const s of bladeSparkles) {
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        s.life -= dt;
    }
    bladeSparkles = bladeSparkles.filter(s => s.life > 0);

    // Hourglass effect
    if (hourglassActive) {
        hourglassTimer -= dt;
        if (hourglassTimer <= 0) {
            hourglassActive = false;
            hourglassTimer = 0;
        }
    }

    // Storm Blade: every 10s, slice all on-screen fruits
    if (getEquippedBlade().bonus === 'storm') {
        stormTimer += dt;
        if (stormTimer >= 10) {
            stormTimer = 0;
            chainSlicing = true;
            let stormCount = 0;
            for (const f of fruits) {
                if (!f.sliced && !f.isBomb) {
                    sliceFruit(f);
                    stormCount++;
                }
            }
            chainSlicing = false;
            if (stormCount > 0) {
                screenFlash = 0.25;
                screenShake = { x: 0, y: 0, timer: 0.3 };
                popups.push({ x: W/2, y: H*0.4, text: 'STORM! x' + stormCount, life: 1.5, vy: -60, size: 40, color: '#aabbff', scale: 2.0 });
            }
        }
    }

    // Meteor Blade: every 15s, a meteor scores +10
    if (getEquippedBlade().bonus === 'meteor') {
        meteorTimer += dt;
        if (meteorTimer >= 15) {
            meteorTimer = 0;
            score += 10;
            screenFlash = 0.2;
            screenShake = { x: 0, y: 0, timer: 0.2 };
            popups.push({ x: W/2, y: H*0.3, text: 'METEOR! +10', life: 1.5, vy: -50, size: 38, color: '#ff8844', scale: 2.0 });
            // Meteor particles
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 100 + Math.random() * 300;
                particles.push({ x: W/2, y: H*0.3, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0.6 + Math.random() * 0.5, maxLife: 1.1, radius: 3 + Math.random() * 5, color: Math.random() > 0.5 ? '#ff6600' : '#ffaa00' });
            }
            shockwaves.push({ x: W/2, y: H*0.3, radius: 10, maxRadius: 200, life: 0.5, maxLife: 0.5 });
        }
    }

    // Difficulty scaling: more owned items = harder game
    // Count non-default owned items (exclude blade_classic and bg_classic)
    const ownedCount = shopData.owned.filter(id => id !== 'blade_classic' && id !== 'bg_classic').length;
    const difficultyMult = 1 + ownedCount * 0.03; // +3% difficulty per owned item

    // Difficulty ramp
    let baseInterval = Math.max(0.3, (1.8 - gameTime * 0.015) / difficultyMult);
    if (hourglassActive) baseInterval *= 2.5;
    // Slow Start powerup: slower spawn for first 10 seconds
    if (hasPower('pow_slow') && gameTime < 10) baseInterval *= 1.8;
    // Fruit Frenzy extra: more fruits spawn (shorter interval)
    if (hasExtra('ext_frenzy')) baseInterval *= 0.75;
    spawnInterval = baseInterval;
    let bombChance = Math.min(0.35, (0.05 + gameTime * 0.003) * difficultyMult);
    // Bomb Defuser extra: 50% less bombs
    if (hasExtra('ext_defuser')) bombChance *= 0.5;
    let specialChance = Math.min(0.35, 0.10 + gameTime * 0.005);
    // Lucky Star powerup: more specials
    if (hasPower('pow_lucky')) specialChance = Math.min(0.5, specialChance * 1.5);
    const burstChance = Math.min(0.5, gameTime * 0.005);
    const burstMax = Math.min(5, 2 + Math.floor(gameTime / 20));

    // Spawn
    spawnTimer += dt;
    if (spawnTimer >= spawnInterval) {
        spawnTimer -= spawnInterval;
        const count = Math.random() < burstChance ? 2 : 1;
        for (let i = 0; i < count; i++) {
            const roll = Math.random();
            if (roll < bombChance) {
                spawnBomb();
            } else if (roll < bombChance + specialChance) {
                spawnSpecial();
            } else {
                spawnFruit();
            }
        }
    }

    // Combo timer
    if (comboTimer > 0) {
        comboTimer -= dt;
        if (comboTimer <= 0) comboCount = 0;
    }

    // Check slicing
    checkSlicing();

    // Update arrows
    for (const arrow of arrows) {
        // Home in on target fruit if it's still alive
        if (arrow.target && !arrow.target.sliced && !arrow.target.missed) {
            const dx = arrow.target.x - arrow.x;
            const dy = arrow.target.y - arrow.y;
            const dist = Math.hypot(dx, dy) || 1;
            arrow.vx = (dx / dist) * ARROW_SPEED;
            arrow.vy = (dy / dist) * ARROW_SPEED;
            arrow.angle = Math.atan2(dy, dx);
        }
        const prevX = arrow.x;
        const prevY = arrow.y;
        arrow.x += arrow.vx * dt;
        arrow.y += arrow.vy * dt;
        arrow.life -= dt;
        // Check collision with fruits
        for (const fruit of fruits) {
            if (fruit.sliced) continue;
            if (segmentCircleIntersect(prevX, prevY, arrow.x, arrow.y, fruit.x, fruit.y, fruit.radius)) {
                sliceFruit(fruit);
                arrow.life = 0;
                break;
            }
        }
    }
    arrows = arrows.filter(a => a.life > 0);

    // Update fruits
    const hgMult = hourglassActive ? 0.5 : 1;
    const currentBlade = getEquippedBlade();
    const currentBg = getEquippedBg();

    // Determine effective gravity based on background
    let effectiveGravity = GRAVITY;
    if (currentBg.mechanic === 'low_gravity') effectiveGravity *= 0.6;   // Space: 40% reduction
    else if (currentBg.mechanic === 'updraft') effectiveGravity *= 0.8;  // Sunset: 20% reduction

    for (const f of fruits) {
        if (f.sliced) continue;

        // Ice Blade: freeze fruits near pointer
        if (currentBlade.bonus === 'freeze' && isPointerDown) {
            const distToPointer = Math.hypot(f.x - pointerPos.x, f.y - pointerPos.y);
            if (distToPointer <= 150) {
                if (!f.frozenTimer) f.frozenTimer = 0;
                f.frozenTimer = 1.0; // 1 second freeze
            }
        }
        if (f.frozenTimer && f.frozenTimer > 0) {
            f.frozenTimer -= dt;
            // Frozen fruits move at 20% speed
            f.x += f.vx * dt * hgMult * 0.2;
            f.y += f.vy * dt * 0.2;
            f.vy += effectiveGravity * dt * 0.2;
        } else {
            f.x += f.vx * dt * hgMult;
            f.y += f.vy * dt;
            f.vy += effectiveGravity * dt;
        }

        // Galaxy Blade: gravitational pull toward pointer
        if (currentBlade.bonus === 'gravity' && isPointerDown) {
            const dx = pointerPos.x - f.x;
            const dy = pointerPos.y - f.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 0 && dist <= 200) {
                const accel = 100; // 100 units/s^2
                f.vx += (dx / dist) * accel * dt;
                f.vy += (dy / dist) * accel * dt;
            }
        }

        // Wind Blade: push nearby falling fruits upward
        if (currentBlade.bonus === 'push' && isPointerDown) {
            const dx = f.x - pointerPos.x;
            const dy = f.y - pointerPos.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 0 && dist <= 130 && f.vy > 0) {
                f.vy -= 400 * dt; // push upward
            }
        }

        f.rotation += f.rotSpeed * dt;
        if (f.isBomb) f.fuseAngle += 12 * dt;

        // Ice shelf (Frozen bg): catch fruit on platform
        if (f.iceCaught) {
            f.iceCaughtTimer -= dt;
            if (f.iceCaughtTimer <= 0) {
                f.iceCaught = false; // unfreeze, let it fall
            } else {
                f.vx = 0;
                f.vy = 0;
                continue; // skip miss detection, fruit is sitting on shelf
            }
        }

        // Platform collision (forest branches, neon platforms, frozen ice shelves)
        if (currentBg.mechanic === 'branches' || currentBg.mechanic === 'platforms' || currentBg.mechanic === 'ice_shelf') {
            if (f.vy > 0) { // only when falling
                for (const plat of bgPlatforms) {
                    if (f.x + f.radius > plat.x && f.x - f.radius < plat.x + plat.width &&
                        f.y + f.radius >= plat.y && f.y + f.radius <= plat.y + 20) {
                        if (currentBg.mechanic === 'ice_shelf') {
                            // Ice shelf: catch and hold for 2 seconds
                            f.iceCaught = true;
                            f.iceCaughtTimer = 2.0;
                            f.y = plat.y - f.radius;
                            f.vx = 0;
                            f.vy = 0;
                        } else {
                            // Bounce: reverse vy at 60% (forest/neon)
                            f.vy = -Math.abs(f.vy) * 0.6;
                            f.y = plat.y - f.radius;
                        }
                        break;
                    }
                }
            }
        }

        if (!f.missed && f.vy > 0 && f.y > H + f.radius + 20) {
            // Ocean waves: 50% chance to bounce back
            if (currentBg.mechanic === 'waves' && !f.isBomb && !f.isSpecial && Math.random() < 0.5 && !f.waveBounced) {
                f.waveBounced = true;
                f.y = H - f.radius;
                f.vy = -Math.abs(f.vy) * 0.7;
                // Wave splash particles
                for (let i = 0; i < 8; i++) {
                    particles.push({
                        x: f.x + (Math.random() - 0.5) * 40,
                        y: H - 10,
                        vx: (Math.random() - 0.5) * 100,
                        vy: -50 - Math.random() * 100,
                        life: 0.5 + Math.random() * 0.4,
                        maxLife: 0.9,
                        radius: 2 + Math.random() * 4,
                        color: '#66aaff',
                    });
                }
                continue;
            }

            // Void Blade: missed fruits get sucked back (60% chance)
            if (currentBlade.bonus === 'void_pull' && !f.isBomb && !f.isSpecial && Math.random() < 0.6 && !f.voidPulled) {
                f.voidPulled = true;
                f.y = H - f.radius - 10;
                const targetY = H * (0.25 + Math.random() * 0.25);
                f.vy = -Math.sqrt(2 * GRAVITY * (H - targetY + 40));
                f.vx = (Math.random() - 0.5) * 150;
                for (let i = 0; i < 10; i++) {
                    particles.push({ x: f.x, y: H, vx: (Math.random()-0.5)*80, vy: -40 - Math.random()*80, life: 0.5, maxLife: 0.5, radius: 2 + Math.random()*3, color: '#8844cc' });
                }
                popups.push({ x: f.x, y: H - 40, text: 'VOID PULL!', life: 0.7, vy: -70, size: 20, color: '#aa66ee', scale: 1.1 });
                continue;
            }

            // Time Blade: 50% chance to undo a miss
            if (currentBlade.bonus === 'rewind' && !f.isBomb && !f.isSpecial && Math.random() < 0.5 && !f.timeRewound) {
                f.timeRewound = true;
                f.y = H + f.radius + 10;
                const targetY = H * (0.2 + Math.random() * 0.3);
                f.vy = -Math.sqrt(2 * GRAVITY * (H - targetY + 50));
                f.vx = (Math.random() - 0.5) * 180;
                for (let i = 0; i < 10; i++) {
                    particles.push({ x: f.x, y: H, vx: (Math.random()-0.5)*60, vy: -30 - Math.random()*60, life: 0.5, maxLife: 0.5, radius: 2 + Math.random()*3, color: '#88ccff' });
                }
                popups.push({ x: f.x, y: H - 40, text: 'REWIND!', life: 0.7, vy: -70, size: 20, color: '#88ddff', scale: 1.1 });
                continue;
            }

            // Sakura Blade: 40% chance missed fruit respawns
            if (currentBlade.bonus === 'second_life' && !f.isBomb && !f.isSpecial && Math.random() < 0.4 && !f.respawned) {
                f.respawned = true;
                f.y = H + f.radius + 10;
                const targetY = H * (0.2 + Math.random() * 0.3);
                f.vy = -Math.sqrt(2 * GRAVITY * (H - targetY + 50));
                f.vx = (Math.random() - 0.5) * 200;
                // Pink petal burst
                for (let i = 0; i < 12; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 60 + Math.random() * 120;
                    particles.push({
                        x: f.x, y: H,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 40,
                        life: 0.6 + Math.random() * 0.5,
                        maxLife: 1.1,
                        radius: 2 + Math.random() * 4,
                        color: Math.random() > 0.5 ? '#ffaacc' : '#ff88bb',
                    });
                }
                continue;
            }

            f.missed = true;
            if (!f.isBomb && !f.isSpecial) {
                lives--;
                const missesInRow = MAX_LIVES - lives;
                popups.push({
                    x: Math.min(Math.max(f.x, 40), W - 40),
                    y: H - 60,
                    text: missesInRow >= MAX_LIVES ? 'STRIKE 3!' : 'MISS x' + missesInRow,
                    life: 1,
                    vy: -60,
                    size: 28 + missesInRow * 4,
                    color: missesInRow >= MAX_LIVES ? '#ff0000' : '#ff4444',
                    scale: 1.2 + missesInRow * 0.3,
                });
                // Reset score streak on miss
                if (hasExtra('ext_streak')) scoreStreak = 0;
                if (lives <= 0) {
                    triggerGameOver();
                }
            }
        }
    }
    fruits = fruits.filter(f => !(f.sliced || f.missed));

    // Update lightning bolts
    for (const lb of lightningBolts) lb.life -= dt;
    lightningBolts = lightningBolts.filter(lb => lb.life > 0);

    // Update lava bubbles (volcano bg)
    if (currentBg.mechanic === 'lava_pop') {
        lavaBubbleTimer -= dt;
        if (lavaBubbleTimer <= 0) {
            lavaBubbleTimer = 3 + Math.random() * 2; // 3-5 seconds
            lavaBubbles.push({
                x: W * 0.15 + Math.random() * W * 0.7,
                y: H + 20,
                vy: -150 - Math.random() * 100,
                radius: 12 + Math.random() * 10,
                life: 4.0,
            });
        }
        for (const lb of lavaBubbles) {
            lb.y += lb.vy * dt;
            lb.life -= dt;
            // Check if lava bubble hits any fruit
            for (const f of fruits) {
                if (f.sliced) continue;
                const dist = Math.hypot(f.x - lb.x, f.y - lb.y);
                if (dist < f.radius + lb.radius) {
                    f.sliced = true;
                    // Burst particles but no coins for lava pop
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 40 + Math.random() * 200;
                        particles.push({
                            x: f.x, y: f.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            life: 0.4 + Math.random() * 0.5,
                            maxLife: 0.9,
                            radius: 2 + Math.random() * 4,
                            color: Math.random() > 0.5 ? '#ff6600' : '#ffaa00',
                        });
                    }
                    // Add points but no coins
                    const lavaPts = f.isBomb ? 0 : f.points;
                    if (lavaPts > 0) {
                        score += lavaPts;
                        popups.push({ x: f.x, y: f.y, text: '+' + lavaPts + ' LAVA', life: 0.8, vy: -80, size: 24, color: '#ff8800', scale: 1.1 });
                    }
                    lb.life = 0;
                    break;
                }
            }
        }
        lavaBubbles = lavaBubbles.filter(lb => lb.life > 0);
    }

    // Update wave phase for ocean bg
    if (currentBg.mechanic === 'waves') {
        wavePhase += dt * 2;
    }

    // Update halves
    for (const h of halves) {
        h.x += h.vx * dt;
        h.y += h.vy * dt;
        h.vy += GRAVITY * dt;
        h.rotation += h.rotSpeed * dt;
        h.life -= dt;
    }
    halves = halves.filter(h => h.life > 0);

    // Update particles
    for (const p of particles) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += GRAVITY * 0.5 * dt;
        p.life -= dt;
    }
    particles = particles.filter(p => p.life > 0);

    // Update popups
    for (const p of popups) {
        p.y += p.vy * dt;
        p.life -= dt;
        // Combo scale bounce: starts at p.scale, decays toward 1
        if (p.isCombo && p.scale > 1) {
            p.scale = 1 + (p.scale - 1) * Math.pow(0.02, dt);
        }
    }
    popups = popups.filter(p => p.life > 0);

    // Update coin popups
    for (const cp of coinPopups) {
        cp.y += cp.vy * dt;
        cp.life -= dt;
    }
    coinPopups = coinPopups.filter(cp => cp.life > 0);

    // Trim blade trail (dragon blade keeps trail longer for lingering hitbox)
    const trailNow = performance.now();
    const trailRetain = getEquippedBlade().bonus === 'fire_breath' ? 500 : 220;
    bladePoints = bladePoints.filter(p => trailNow - p.t < trailRetain);
}

// ===========================================
//  DRAWING — BACKGROUND
// ===========================================
function drawBackground() {
    const wallBottom = H * 0.48;
    const floorTop = wallBottom + 10;

    // === WALL — bright sunlit plaster ===
    const wallGrad = ctx.createLinearGradient(0, 0, 0, wallBottom);
    wallGrad.addColorStop(0, '#c8b89a');
    wallGrad.addColorStop(0.15, '#d4c4a6');
    wallGrad.addColorStop(0.5, '#ddd0b8');
    wallGrad.addColorStop(0.85, '#d0c0a2');
    wallGrad.addColorStop(1, '#baa882');
    ctx.fillStyle = wallGrad;
    ctx.fillRect(0, 0, W, wallBottom);
    // Plaster texture noise
    ctx.globalAlpha = 0.04;
    ctx.fillStyle = '#8a7a60';
    for (let y = 0; y < wallBottom; y += 4) {
        for (let x = 0; x < W; x += 4) {
            if (Math.sin(x * 0.19 + y * 0.23) + Math.cos(x * 0.07 - y * 0.11) > 0.6) {
                ctx.fillRect(x, y, 2, 2);
            }
        }
    }
    ctx.globalAlpha = 1;

    // === SUNLIGHT WASH (warm light from upper-right) ===
    const sunGrad = ctx.createRadialGradient(W * 0.8, 0, 0, W * 0.7, H * 0.15, W * 0.7);
    sunGrad.addColorStop(0, 'rgba(255, 240, 200, 0.25)');
    sunGrad.addColorStop(0.3, 'rgba(255, 230, 180, 0.12)');
    sunGrad.addColorStop(0.7, 'rgba(255, 220, 160, 0.04)');
    sunGrad.addColorStop(1, 'rgba(255, 210, 140, 0)');
    ctx.fillStyle = sunGrad;
    ctx.fillRect(0, 0, W, wallBottom);

    // === WOOD CEILING BEAM ===
    const beamH = H * 0.028;
    const beamGrad = ctx.createLinearGradient(0, 0, 0, beamH);
    beamGrad.addColorStop(0, '#4a3422');
    beamGrad.addColorStop(0.4, '#5e4432');
    beamGrad.addColorStop(0.6, '#503828');
    beamGrad.addColorStop(1, '#3e2a1c');
    ctx.fillStyle = beamGrad;
    ctx.fillRect(0, 0, W, beamH);
    ctx.fillStyle = 'rgba(220,190,140,0.12)';
    ctx.fillRect(0, beamH * 0.3, W, 1);
    // Beam shadow on wall
    const beamShadow = ctx.createLinearGradient(0, beamH, 0, beamH + 12);
    beamShadow.addColorStop(0, 'rgba(0,0,0,0.12)');
    beamShadow.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = beamShadow;
    ctx.fillRect(0, beamH, W, 12);

    // === WOOD BASEBOARD ===
    const trimY = wallBottom - 5;
    const trimH = 16;
    const trimGrad = ctx.createLinearGradient(0, trimY, 0, trimY + trimH);
    trimGrad.addColorStop(0, '#5a3e28');
    trimGrad.addColorStop(0.3, '#6e4e34');
    trimGrad.addColorStop(0.7, '#5e4230');
    trimGrad.addColorStop(1, '#4a3420');
    ctx.fillStyle = trimGrad;
    ctx.fillRect(0, trimY, W, trimH);
    ctx.fillStyle = 'rgba(220,190,140,0.12)';
    ctx.fillRect(0, trimY + 1, W, 1);

    // === TATAMI FLOOR (sunlit) ===
    const floorGrad = ctx.createLinearGradient(0, floorTop, 0, H);
    floorGrad.addColorStop(0, '#baa870');
    floorGrad.addColorStop(0.15, '#b09a65');
    floorGrad.addColorStop(0.4, '#a08e58');
    floorGrad.addColorStop(0.7, '#8a7a4a');
    floorGrad.addColorStop(1, '#6a5a38');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, floorTop, W, H - floorTop);
    // Sunlight on floor (warm patch)
    const floorSun = ctx.createRadialGradient(W * 0.6, floorTop + (H - floorTop) * 0.3, 0, W * 0.6, floorTop + (H - floorTop) * 0.3, W * 0.4);
    floorSun.addColorStop(0, 'rgba(255, 240, 200, 0.15)');
    floorSun.addColorStop(0.5, 'rgba(255, 230, 180, 0.06)');
    floorSun.addColorStop(1, 'rgba(255, 220, 160, 0)');
    ctx.fillStyle = floorSun;
    ctx.fillRect(0, floorTop, W, H - floorTop);
    // Woven texture
    ctx.globalAlpha = 0.07;
    ctx.strokeStyle = '#6a5a38';
    ctx.lineWidth = 1;
    for (let y = floorTop; y < H; y += 5) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(W, y);
        ctx.stroke();
    }
    for (let y = floorTop; y < H; y += 10) {
        for (let x = (y % 20 === 0 ? 0 : 3); x < W; x += 6) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + 5);
            ctx.stroke();
        }
    }
    ctx.globalAlpha = 1;
    // Mat borders
    const matCols = Math.max(2, Math.floor(W / 300));
    const matRows = Math.max(2, Math.floor((H - floorTop) / 200));
    const matW = W / matCols;
    const matH = (H - floorTop) / matRows;
    ctx.strokeStyle = 'rgba(80, 65, 35, 0.35)';
    ctx.lineWidth = 3;
    for (let r = 0; r <= matRows; r++) {
        ctx.beginPath(); ctx.moveTo(0, floorTop + r * matH); ctx.lineTo(W, floorTop + r * matH); ctx.stroke();
    }
    for (let c = 0; c <= matCols; c++) {
        ctx.beginPath(); ctx.moveTo(c * matW, floorTop); ctx.lineTo(c * matW, H); ctx.stroke();
    }
    // Scuff marks on floor
    ctx.globalAlpha = 0.08;
    ctx.strokeStyle = '#5a4a30';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    const scuffs = [[0.2,0.6,40,0.1],[0.5,0.7,55,-0.15],[0.7,0.55,35,0.2],[0.35,0.8,30,-0.05],[0.8,0.75,45,0.12]];
    for (const [sx, sy, sl, sa] of scuffs) {
        ctx.beginPath();
        ctx.moveTo(W * sx, floorTop + (H - floorTop) * sy);
        ctx.lineTo(W * sx + Math.cos(sa) * sl, floorTop + (H - floorTop) * sy + Math.sin(sa) * sl);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
    ctx.lineCap = 'butt';

    // =========================================
    //  WALL DECORATIONS
    // =========================================

    // --- DOJO BANNER (top center) ---
    const bannerX = W * 0.5;
    const bannerTop = beamH + 2;
    const bannerW = Math.min(180, W * 0.2);
    const bannerH = wallBottom * 0.35;
    // Fabric
    const banGrad = ctx.createLinearGradient(bannerX - bannerW / 2, bannerTop, bannerX + bannerW / 2, bannerTop);
    banGrad.addColorStop(0, 'rgba(160,20,20,0.8)');
    banGrad.addColorStop(0.15, 'rgba(190,30,30,0.88)');
    banGrad.addColorStop(0.5, 'rgba(200,35,35,0.92)');
    banGrad.addColorStop(0.85, 'rgba(190,30,30,0.88)');
    banGrad.addColorStop(1, 'rgba(160,20,20,0.8)');
    ctx.fillStyle = banGrad;
    // Banner shape with pointed bottom
    ctx.beginPath();
    ctx.moveTo(bannerX - bannerW / 2, bannerTop);
    ctx.lineTo(bannerX + bannerW / 2, bannerTop);
    ctx.lineTo(bannerX + bannerW / 2, bannerTop + bannerH * 0.8);
    ctx.lineTo(bannerX, bannerTop + bannerH);
    ctx.lineTo(bannerX - bannerW / 2, bannerTop + bannerH * 0.8);
    ctx.closePath();
    ctx.fill();
    // Gold border
    ctx.strokeStyle = 'rgba(200,170,80,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Gold inner border
    ctx.beginPath();
    ctx.moveTo(bannerX - bannerW / 2 + 6, bannerTop + 6);
    ctx.lineTo(bannerX + bannerW / 2 - 6, bannerTop + 6);
    ctx.lineTo(bannerX + bannerW / 2 - 6, bannerTop + bannerH * 0.8 - 5);
    ctx.lineTo(bannerX, bannerTop + bannerH - 10);
    ctx.lineTo(bannerX - bannerW / 2 + 6, bannerTop + bannerH * 0.8 - 5);
    ctx.closePath();
    ctx.strokeStyle = 'rgba(200,170,80,0.3)';
    ctx.lineWidth = 1;
    ctx.stroke();
    // Kanji text on banner
    ctx.font = `bold ${Math.floor(bannerH * 0.22)}px serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(220,190,90,0.7)';
    ctx.fillText('\u5FCD', bannerX, bannerTop + bannerH * 0.35); // 忍
    ctx.font = `bold ${Math.floor(bannerH * 0.18)}px serif`;
    ctx.fillText('\u8005', bannerX, bannerTop + bannerH * 0.55); // 者
    // Hanging rod
    ctx.fillStyle = '#1a0e06';
    ctx.fillRect(bannerX - bannerW / 2 - 8, bannerTop - 3, bannerW + 16, 6);
    // Hanging string
    ctx.strokeStyle = 'rgba(120,100,60,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(bannerX, bannerTop - 3);
    ctx.quadraticCurveTo(bannerX, bannerTop - 10, bannerX, beamH);
    ctx.stroke();

    // --- WEAK SPOTS POSTER (left side) ---
    const wpX = W * 0.08;
    const wpY = beamH + H * 0.04;
    const wpW = Math.min(120, W * 0.14);
    const wpH = wallBottom * 0.65;
    // Aged paper background
    const wpGrad = ctx.createLinearGradient(wpX, wpY, wpX + wpW, wpY + wpH);
    wpGrad.addColorStop(0, 'rgba(240,230,205,0.8)');
    wpGrad.addColorStop(0.5, 'rgba(248,238,215,0.85)');
    wpGrad.addColorStop(1, 'rgba(235,225,200,0.78)');
    ctx.fillStyle = wpGrad;
    ctx.fillRect(wpX, wpY, wpW, wpH);
    ctx.strokeStyle = 'rgba(60,40,20,0.35)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(wpX, wpY, wpW, wpH);
    // Title
    ctx.font = `bold ${Math.max(8, Math.floor(wpW * 0.09))}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(160,30,20,0.7)';
    ctx.fillText('VITAL POINTS', wpX + wpW / 2, wpY + wpH * 0.07);
    // Human figure outline
    const figX = wpX + wpW / 2;
    const figTop = wpY + wpH * 0.12;
    const figH = wpH * 0.72;
    const figScale = figH / 120;
    ctx.save();
    ctx.translate(figX, figTop);
    ctx.scale(figScale, figScale);
    ctx.strokeStyle = 'rgba(40,30,20,0.5)';
    ctx.lineWidth = 2 / figScale;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    // Head
    ctx.beginPath();
    ctx.arc(0, 10, 10, 0, Math.PI * 2);
    ctx.stroke();
    // Neck
    ctx.beginPath(); ctx.moveTo(0, 20); ctx.lineTo(0, 26); ctx.stroke();
    // Torso
    ctx.beginPath(); ctx.moveTo(0, 26); ctx.lineTo(-16, 32); ctx.stroke(); // left shoulder
    ctx.beginPath(); ctx.moveTo(0, 26); ctx.lineTo(16, 32); ctx.stroke();  // right shoulder
    ctx.beginPath(); ctx.moveTo(-16, 32); ctx.lineTo(-18, 60); ctx.stroke(); // left side
    ctx.beginPath(); ctx.moveTo(16, 32); ctx.lineTo(18, 60); ctx.stroke();  // right side
    ctx.beginPath(); ctx.moveTo(-18, 60); ctx.lineTo(18, 60); ctx.stroke(); // waist
    // Arms
    ctx.beginPath(); ctx.moveTo(-16, 32); ctx.lineTo(-24, 48); ctx.lineTo(-20, 65); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(16, 32); ctx.lineTo(24, 48); ctx.lineTo(20, 65); ctx.stroke();
    // Legs
    ctx.beginPath(); ctx.moveTo(-8, 60); ctx.lineTo(-12, 85); ctx.lineTo(-14, 110); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(8, 60); ctx.lineTo(12, 85); ctx.lineTo(14, 110); ctx.stroke();
    // Weak spot circles (red targets)
    const weakSpots = [
        [0, 4, 'Temple'],    // top of head
        [0, 22, 'Throat'],   // throat
        [0, 40, 'Solar P.'], // solar plexus
        [-18, 60, 'Kidney'], // left kidney
        [18, 60, 'Kidney'],  // right kidney
        [0, 58, 'Groin'],    // groin
        [-12, 85, 'Knee'],   // left knee
        [12, 85, 'Knee'],    // right knee
    ];
    for (const [wx, wy, label] of weakSpots) {
        // Red target circle
        ctx.beginPath();
        ctx.arc(wx, wy, 4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(220,30,20,0.5)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(220,30,20,0.7)';
        ctx.lineWidth = 1 / figScale;
        ctx.stroke();
        // Inner dot
        ctx.beginPath();
        ctx.arc(wx, wy, 1.5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,60,40,0.8)';
        ctx.fill();
    }
    ctx.restore();
    // Label at bottom
    ctx.font = `${Math.max(6, Math.floor(wpW * 0.07))}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(60,40,20,0.5)';
    ctx.fillText('Know thy enemy', wpX + wpW / 2, wpY + wpH * 0.93);
    // Pin/tack
    ctx.beginPath();
    ctx.arc(wpX + wpW / 2, wpY - 1, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(180,50,40,0.7)';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(wpX + wpW / 2, wpY - 1, 4, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(120,30,20,0.5)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(wpX + wpW / 2 - 1, wpY - 2, 1.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,200,200,0.5)';
    ctx.fill();

    // --- TECHNIQUE POSTER (left-center) ---
    const tpX = W * 0.24;
    const tpY = beamH + H * 0.05;
    const tpW = Math.min(115, W * 0.13);
    const tpH = wallBottom * 0.58;
    // Paper
    const tpGrad = ctx.createLinearGradient(tpX, tpY, tpX + tpW, tpY + tpH);
    tpGrad.addColorStop(0, 'rgba(242,232,208,0.78)');
    tpGrad.addColorStop(1, 'rgba(235,225,200,0.82)');
    ctx.fillStyle = tpGrad;
    ctx.fillRect(tpX, tpY, tpW, tpH);
    ctx.strokeStyle = 'rgba(60,40,20,0.3)';
    ctx.lineWidth = 1.5;
    ctx.strokeRect(tpX, tpY, tpW, tpH);
    // Title
    ctx.font = `bold ${Math.max(7, Math.floor(tpW * 0.09))}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(30,20,10,0.6)';
    ctx.fillText('TECHNIQUE', tpX + tpW / 2, tpY + tpH * 0.07);
    // Three fighting stance figures
    const stanceY = tpY + tpH * 0.14;
    const stanceH = tpH * 0.24;
    const stS = stanceH / 50;
    for (let si = 0; si < 3; si++) {
        const sCx = tpX + tpW * (0.25 + si * 0.25);
        const sCy = stanceY + si * stanceH * 1.05;
        ctx.save();
        ctx.translate(sCx, sCy);
        ctx.scale(stS, stS);
        ctx.strokeStyle = 'rgba(40,30,20,0.45)';
        ctx.lineWidth = 1.8 / stS;
        ctx.lineCap = 'round';
        // Head
        ctx.beginPath(); ctx.arc(0, 6, 6, 0, Math.PI * 2); ctx.stroke();
        if (si === 0) {
            // Ready stance
            ctx.beginPath(); ctx.moveTo(0, 12); ctx.lineTo(0, 32); ctx.stroke(); // body
            ctx.beginPath(); ctx.moveTo(0, 18); ctx.lineTo(-14, 28); ctx.stroke(); // left arm
            ctx.beginPath(); ctx.moveTo(0, 18); ctx.lineTo(14, 28); ctx.stroke(); // right arm
            ctx.beginPath(); ctx.moveTo(0, 32); ctx.lineTo(-10, 48); ctx.stroke(); // left leg
            ctx.beginPath(); ctx.moveTo(0, 32); ctx.lineTo(10, 48); ctx.stroke(); // right leg
            // Arrow showing guard position
            ctx.strokeStyle = 'rgba(180,40,30,0.4)';
            ctx.beginPath(); ctx.moveTo(16, 22); ctx.lineTo(8, 18); ctx.stroke();
        } else if (si === 1) {
            // High kick
            ctx.beginPath(); ctx.moveTo(0, 12); ctx.lineTo(-2, 32); ctx.stroke(); // body leaning
            ctx.beginPath(); ctx.moveTo(-2, 18); ctx.lineTo(-16, 24); ctx.stroke(); // left arm back
            ctx.beginPath(); ctx.moveTo(-2, 18); ctx.lineTo(10, 14); ctx.stroke(); // right arm forward
            ctx.beginPath(); ctx.moveTo(-2, 32); ctx.lineTo(-8, 48); ctx.stroke(); // standing leg
            ctx.beginPath(); ctx.moveTo(-2, 32); ctx.lineTo(18, 20); ctx.stroke(); // kicking leg up
            // Motion arc
            ctx.strokeStyle = 'rgba(180,40,30,0.3)';
            ctx.beginPath(); ctx.arc(0, 32, 18, -Math.PI * 0.7, -Math.PI * 0.2); ctx.stroke();
        } else {
            // Sword slash
            ctx.beginPath(); ctx.moveTo(0, 12); ctx.lineTo(2, 32); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(2, 18); ctx.lineTo(-12, 12); ctx.stroke(); // left arm up
            ctx.beginPath(); ctx.moveTo(2, 18); ctx.lineTo(16, 8); ctx.stroke(); // right arm up with sword
            // Sword
            ctx.strokeStyle = 'rgba(150,150,150,0.5)';
            ctx.lineWidth = 1.2 / stS;
            ctx.beginPath(); ctx.moveTo(16, 8); ctx.lineTo(14, -10); ctx.stroke();
            ctx.strokeStyle = 'rgba(40,30,20,0.45)';
            ctx.lineWidth = 1.8 / stS;
            ctx.beginPath(); ctx.moveTo(2, 32); ctx.lineTo(-6, 48); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(2, 32); ctx.lineTo(10, 48); ctx.stroke();
            // Slash arc
            ctx.strokeStyle = 'rgba(180,40,30,0.3)';
            ctx.beginPath(); ctx.arc(15, 8, 14, -Math.PI * 0.8, Math.PI * 0.1); ctx.stroke();
        }
        ctx.restore();
    }
    // Stance labels
    ctx.font = `${Math.max(6, Math.floor(tpW * 0.065))}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(40,30,20,0.4)';
    const stLabels = ['Guard', 'Strike', 'Slash'];
    for (let si = 0; si < 3; si++) {
        ctx.fillText(stLabels[si], tpX + tpW * (0.25 + si * 0.25), stanceY + si * stanceH * 1.05 + stanceH + 4);
    }
    // Pin
    ctx.beginPath();
    ctx.arc(tpX + tpW / 2, tpY - 1, 3.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(60,120,180,0.6)';
    ctx.fill();

    // --- DOJO RULES SCROLL (right-center area) ---
    const rulesX = W * 0.62;
    const rulesTop = beamH + H * 0.03;
    const rulesW = Math.min(100, W * 0.12);
    const rulesH = wallBottom * 0.68;
    // Scroll paper
    const rGrad = ctx.createLinearGradient(rulesX, rulesTop, rulesX + rulesW, rulesTop);
    rGrad.addColorStop(0, 'rgba(238,228,200,0.75)');
    rGrad.addColorStop(0.5, 'rgba(245,235,210,0.82)');
    rGrad.addColorStop(1, 'rgba(235,225,195,0.72)');
    ctx.fillStyle = rGrad;
    ctx.fillRect(rulesX, rulesTop, rulesW, rulesH);
    ctx.strokeStyle = 'rgba(60,40,20,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(rulesX, rulesTop, rulesW, rulesH);
    // Roller rods
    ctx.fillStyle = '#2a1608';
    ctx.fillRect(rulesX - 6, rulesTop - 3, rulesW + 12, 7);
    ctx.fillRect(rulesX - 6, rulesTop + rulesH - 3, rulesW + 12, 7);
    // Rod caps
    ctx.fillStyle = '#1a0e06';
    for (const ry of [rulesTop, rulesTop + rulesH]) {
        ctx.beginPath(); ctx.arc(rulesX - 6, ry, 4, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(rulesX + rulesW + 6, ry, 4, 0, Math.PI * 2); ctx.fill();
    }
    // Title
    ctx.font = `bold ${Math.max(7, Math.floor(rulesW * 0.1))}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(160,30,20,0.6)';
    ctx.fillText('DOJO RULES', rulesX + rulesW / 2, rulesTop + rulesH * 0.08);
    // Red underline
    ctx.strokeStyle = 'rgba(160,30,20,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(rulesX + 8, rulesTop + rulesH * 0.095);
    ctx.lineTo(rulesX + rulesW - 8, rulesTop + rulesH * 0.095);
    ctx.stroke();
    // Rules text
    const rules = [
        '1. Respect the dojo',
        '2. Honor thy sensei',
        '3. No fear, only focus',
        '4. Blade before self',
        '5. Train every day',
        '6. Never waste a cut',
        '7. Patience is power',
    ];
    ctx.font = `${Math.max(5, Math.floor(rulesW * 0.072))}px sans-serif`;
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(30,20,10,0.5)';
    for (let i = 0; i < rules.length; i++) {
        ctx.fillText(rules[i], rulesX + 6, rulesTop + rulesH * (0.16 + i * 0.095));
    }
    // Hanging string
    ctx.strokeStyle = 'rgba(120,100,60,0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(rulesX + rulesW / 2, rulesTop - 3);
    ctx.lineTo(rulesX + rulesW / 2, beamH);
    ctx.stroke();

    // --- SWORD BARREL (right side, against wall) ---
    const barrelX = W * 0.87;
    const barrelBot = wallBottom + 6;
    const barrelW = Math.min(70, W * 0.08);
    const barrelH = wallBottom * 0.4;
    const barrelTop = barrelBot - barrelH;
    // Barrel body (wooden barrel shape)
    const bGrad = ctx.createLinearGradient(barrelX - barrelW / 2, barrelTop, barrelX + barrelW / 2, barrelTop);
    bGrad.addColorStop(0, 'rgba(100,65,32,0.88)');
    bGrad.addColorStop(0.15, 'rgba(135,90,45,0.92)');
    bGrad.addColorStop(0.5, 'rgba(150,100,50,0.95)');
    bGrad.addColorStop(0.85, 'rgba(125,80,40,0.92)');
    bGrad.addColorStop(1, 'rgba(90,55,25,0.88)');
    ctx.fillStyle = bGrad;
    // Barrel with slight taper
    ctx.beginPath();
    ctx.moveTo(barrelX - barrelW / 2 + 3, barrelTop);
    ctx.lineTo(barrelX + barrelW / 2 - 3, barrelTop);
    ctx.lineTo(barrelX + barrelW / 2, barrelBot);
    ctx.lineTo(barrelX - barrelW / 2, barrelBot);
    ctx.closePath();
    ctx.fill();
    // Barrel wood grain
    ctx.globalAlpha = 0.1;
    ctx.strokeStyle = '#3a2010';
    ctx.lineWidth = 1;
    for (let y = barrelTop + 5; y < barrelBot; y += 6) {
        ctx.beginPath();
        ctx.moveTo(barrelX - barrelW / 2 + 4, y + Math.sin(y * 0.1) * 2);
        ctx.lineTo(barrelX + barrelW / 2 - 4, y + Math.sin(y * 0.1 + 1) * 2);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
    // Metal bands
    ctx.strokeStyle = 'rgba(100,100,100,0.6)';
    ctx.lineWidth = 3;
    for (const bandY of [barrelTop + 8, barrelTop + barrelH * 0.4, barrelBot - 8]) {
        ctx.beginPath();
        ctx.moveTo(barrelX - barrelW / 2 + 1, bandY);
        ctx.lineTo(barrelX + barrelW / 2 - 1, bandY);
        ctx.stroke();
        // Band highlight
        ctx.strokeStyle = 'rgba(180,180,180,0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(barrelX - barrelW / 2 + 2, bandY - 1);
        ctx.lineTo(barrelX + barrelW / 2 - 2, bandY - 1);
        ctx.stroke();
        ctx.strokeStyle = 'rgba(100,100,100,0.6)';
        ctx.lineWidth = 3;
    }
    // Barrel rim (top ellipse)
    ctx.beginPath();
    ctx.ellipse(barrelX, barrelTop, barrelW / 2 - 2, 6, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(60,35,15,0.8)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Inner rim
    ctx.beginPath();
    ctx.ellipse(barrelX, barrelTop, barrelW / 2 - 6, 4, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(30,18,8,0.7)';
    ctx.fill();

    // Swords sticking out of barrel (5 bokken/katana)
    const swords = [
        { angle: -0.3, len: barrelH * 1.4, color: '#c8c8c8', handleColor: '#cc2222', isBlade: true },
        { angle: -0.12, len: barrelH * 1.6, color: '#8a6a3a', handleColor: '#2a1a0e', isBlade: false },
        { angle: 0.05, len: barrelH * 1.5, color: '#d0d0d0', handleColor: '#1a3a8a', isBlade: true },
        { angle: 0.22, len: barrelH * 1.3, color: '#7a5a30', handleColor: '#2a1a0e', isBlade: false },
        { angle: 0.35, len: barrelH * 1.45, color: '#b8b8b8', handleColor: '#8a2222', isBlade: true },
    ];
    for (const sw of swords) {
        ctx.save();
        ctx.translate(barrelX + sw.angle * barrelW * 0.5, barrelTop - 2);
        ctx.rotate(sw.angle);
        if (sw.isBlade) {
            // Katana blade
            const blGrad = ctx.createLinearGradient(-1.5, 0, 1.5, 0);
            blGrad.addColorStop(0, 'rgba(160,160,165,0.7)');
            blGrad.addColorStop(0.3, 'rgba(220,220,225,0.8)');
            blGrad.addColorStop(0.5, 'rgba(240,240,245,0.85)');
            blGrad.addColorStop(0.7, 'rgba(200,200,210,0.8)');
            blGrad.addColorStop(1, 'rgba(150,150,160,0.7)');
            ctx.fillStyle = blGrad;
            ctx.beginPath();
            ctx.moveTo(-1.5, 0);
            ctx.lineTo(-1, -sw.len);
            ctx.quadraticCurveTo(0, -sw.len - 4, 1, -sw.len);
            ctx.lineTo(1.5, 0);
            ctx.closePath();
            ctx.fill();
            // Guard
            ctx.beginPath();
            ctx.ellipse(0, 2, 2, 6, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(160,140,60,0.7)';
            ctx.fill();
        } else {
            // Wooden bokken
            ctx.fillStyle = sw.color;
            ctx.globalAlpha = 0.7;
            ctx.beginPath();
            ctx.moveTo(-2.5, 0);
            ctx.lineTo(-2, -sw.len);
            ctx.quadraticCurveTo(0, -sw.len - 3, 2, -sw.len);
            ctx.lineTo(2.5, 0);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        // Handle wrapping (visible near barrel top)
        ctx.strokeStyle = sw.handleColor;
        ctx.globalAlpha = 0.6;
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.moveTo(-2.5, 4 + i * 5);
            ctx.lineTo(2.5, 7 + i * 5);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }

    // --- SHURIKEN DISPLAY (wall, between barrel and rules) ---
    const shX = W * 0.77;
    const shY = wallBottom * 0.25;
    // Small wooden mount board
    ctx.fillStyle = 'rgba(70,45,22,0.65)';
    ctx.fillRect(shX - 20, shY - 20, 40, 40);
    ctx.strokeStyle = 'rgba(100,70,35,0.4)';
    ctx.lineWidth = 1;
    ctx.strokeRect(shX - 20, shY - 20, 40, 40);
    // Shuriken (4-point star)
    ctx.save();
    ctx.translate(shX, shY);
    const shR = 14;
    ctx.fillStyle = 'rgba(160,160,170,0.6)';
    ctx.strokeStyle = 'rgba(120,120,130,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < 4; i++) {
        const a = i * Math.PI / 2 - Math.PI / 4;
        ctx.lineTo(Math.cos(a) * shR, Math.sin(a) * shR);
        const b = a + Math.PI / 4;
        ctx.lineTo(Math.cos(b) * shR * 0.35, Math.sin(b) * shR * 0.35);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    // Center hole
    ctx.beginPath();
    ctx.arc(0, 0, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(40,25,12,0.6)';
    ctx.fill();
    // Metallic highlight
    ctx.beginPath();
    ctx.arc(-3, -3, 4, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fill();
    ctx.restore();

    // Second shuriken below
    ctx.save();
    ctx.translate(shX, shY + 48);
    ctx.rotate(Math.PI / 8);
    ctx.fillStyle = 'rgba(150,150,160,0.5)';
    ctx.beginPath();
    for (let i = 0; i < 4; i++) {
        const a = i * Math.PI / 2 - Math.PI / 4;
        ctx.lineTo(Math.cos(a) * shR * 0.9, Math.sin(a) * shR * 0.9);
        const b = a + Math.PI / 4;
        ctx.lineTo(Math.cos(b) * shR * 0.3, Math.sin(b) * shR * 0.3);
    }
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = 'rgba(120,120,130,0.4)';
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI * 2); ctx.fillStyle = 'rgba(40,25,12,0.5)'; ctx.fill();
    ctx.restore();

    // --- NUNCHUCKS hanging on nail (far left wall) ---
    const nkX = W * 0.03;
    const nkY = wallBottom * 0.35;
    // Nail
    ctx.beginPath();
    ctx.arc(nkX, nkY, 2.5, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(140,140,140,0.5)';
    ctx.fill();
    // Rope
    ctx.strokeStyle = 'rgba(120,100,60,0.4)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(nkX - 8, nkY + 15);
    ctx.quadraticCurveTo(nkX, nkY + 2, nkX + 8, nkY + 15);
    ctx.stroke();
    // Left handle
    ctx.fillStyle = 'rgba(60,35,15,0.6)';
    ctx.save();
    ctx.translate(nkX - 8, nkY + 15);
    ctx.rotate(-0.15);
    ctx.fillRect(-3, 0, 6, 28);
    // Handle wrap
    ctx.strokeStyle = 'rgba(200,30,20,0.35)';
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 5; i++) { ctx.beginPath(); ctx.moveTo(-3, 4 + i * 5); ctx.lineTo(3, 7 + i * 5); ctx.stroke(); }
    ctx.restore();
    // Right handle
    ctx.save();
    ctx.translate(nkX + 8, nkY + 15);
    ctx.rotate(0.15);
    ctx.fillStyle = 'rgba(60,35,15,0.6)';
    ctx.fillRect(-3, 0, 6, 28);
    ctx.strokeStyle = 'rgba(200,30,20,0.35)';
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 5; i++) { ctx.beginPath(); ctx.moveTo(-3, 4 + i * 5); ctx.lineTo(3, 7 + i * 5); ctx.stroke(); }
    ctx.restore();

    // --- PAPER LANTERNS (hanging from ceiling beam) ---
    for (const [lx, flicker] of [[W * 0.35, 0.7], [W * 0.65, 1.3]]) {
        const ly = beamH + 6;
        const lSize = Math.min(22, W * 0.025);
        const pulse = 0.85 + 0.15 * Math.sin(performance.now() * 0.003 + flicker);
        // String
        ctx.strokeStyle = 'rgba(80,60,30,0.4)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(lx, beamH);
        ctx.lineTo(lx, ly);
        ctx.stroke();
        // Lantern glow
        const lgGrad = ctx.createRadialGradient(lx, ly + lSize, 0, lx, ly + lSize, lSize * 5);
        lgGrad.addColorStop(0, `rgba(255, 180, 80, ${0.05 * pulse})`);
        lgGrad.addColorStop(0.4, `rgba(255, 150, 50, ${0.02 * pulse})`);
        lgGrad.addColorStop(1, 'rgba(255, 120, 30, 0)');
        ctx.fillStyle = lgGrad;
        ctx.fillRect(lx - lSize * 5, ly - lSize * 2, lSize * 10, lSize * 8);
        // Lantern body (cylindrical paper lantern)
        const lbGrad = ctx.createRadialGradient(lx - lSize * 0.2, ly + lSize * 0.5, 0, lx, ly + lSize * 0.7, lSize * 1.2);
        lbGrad.addColorStop(0, `rgba(255, 200, 120, ${0.8 * pulse})`);
        lbGrad.addColorStop(0.4, `rgba(220, 80, 30, ${0.7 * pulse})`);
        lbGrad.addColorStop(1, `rgba(180, 40, 15, ${0.6 * pulse})`);
        ctx.fillStyle = lbGrad;
        ctx.beginPath();
        ctx.ellipse(lx, ly + lSize * 0.8, lSize * 0.75, lSize * 1.1, 0, 0, Math.PI * 2);
        ctx.fill();
        // Ribs
        ctx.strokeStyle = `rgba(120, 30, 10, ${0.25 * pulse})`;
        ctx.lineWidth = 0.7;
        for (let ri = 0; ri < 4; ri++) {
            const ry = ly + lSize * (0.2 + ri * 0.4);
            ctx.beginPath();
            ctx.ellipse(lx, ry, lSize * 0.7, 2, 0, 0, Math.PI * 2);
            ctx.stroke();
        }
        // Top/bottom caps
        ctx.fillStyle = 'rgba(50,30,15,0.6)';
        ctx.fillRect(lx - lSize * 0.35, ly - 2, lSize * 0.7, 5);
        ctx.fillRect(lx - lSize * 0.3, ly + lSize * 1.7, lSize * 0.6, 4);
        // Tassel
        ctx.strokeStyle = 'rgba(200,50,30,0.35)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(lx, ly + lSize * 1.9);
        ctx.lineTo(lx, ly + lSize * 2.4);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lx - 3, ly + lSize * 2.4);
        ctx.lineTo(lx, ly + lSize * 2.7);
        ctx.lineTo(lx + 3, ly + lSize * 2.4);
        ctx.stroke();
    }

    // === BACKGROUND TINT from equipped background ===
    const equippedBg = getEquippedBg();
    if (equippedBg.tint && equippedBg.alpha > 0) {
        ctx.globalAlpha = equippedBg.alpha;
        ctx.fillStyle = equippedBg.tint;
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
    }
    // Space background: draw twinkling stars
    if (equippedBg.id === 'bg_space') {
        if (spaceStars.length === 0) initSpaceStars();
        const nowS = performance.now() * 0.001;
        for (const star of spaceStars) {
            const twinkle = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(nowS * star.twinkleSpeed + star.twinklePhase));
            ctx.globalAlpha = twinkle * 0.8;
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // === SOFT VIGNETTE (subtle for daytime) ===
    const vg = ctx.createRadialGradient(W / 2, H / 2, Math.min(W, H) * 0.4, W / 2, H / 2, Math.max(W, H) * 0.8);
    vg.addColorStop(0, 'rgba(0,0,0,0)');
    vg.addColorStop(1, 'rgba(0,0,0,0.25)');
    ctx.fillStyle = vg;
    ctx.fillRect(0, 0, W, H);
}

function drawSplatters() {
    for (const s of splatters) {
        const alpha = Math.min(1, s.life / s.maxLife) * 0.35;
        ctx.globalAlpha = alpha;
        const sg = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius);
        sg.addColorStop(0, s.color);
        sg.addColorStop(0.6, s.color);
        sg.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = sg;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

function drawBgMechanics() {
    const bg = getEquippedBg();

    // Forest branches
    if (bg.mechanic === 'branches') {
        for (const plat of bgPlatforms) {
            // Wooden plank
            const bGrad = ctx.createLinearGradient(plat.x, plat.y, plat.x, plat.y + 12);
            bGrad.addColorStop(0, '#8B6914');
            bGrad.addColorStop(0.3, '#A0782A');
            bGrad.addColorStop(0.7, '#8B6914');
            bGrad.addColorStop(1, '#6B4E0A');
            ctx.fillStyle = bGrad;
            ctx.fillRect(plat.x, plat.y, plat.width, 12);
            // Wood grain lines
            ctx.strokeStyle = 'rgba(60,40,10,0.3)';
            ctx.lineWidth = 1;
            for (let y = plat.y + 3; y < plat.y + 12; y += 4) {
                ctx.beginPath();
                ctx.moveTo(plat.x + 2, y);
                ctx.lineTo(plat.x + plat.width - 2, y);
                ctx.stroke();
            }
            // Border
            ctx.strokeStyle = 'rgba(80,55,15,0.6)';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(plat.x, plat.y, plat.width, 12);
        }
    }

    // Neon platforms
    if (bg.mechanic === 'platforms') {
        const t = performance.now() * 0.003;
        for (let i = 0; i < bgPlatforms.length; i++) {
            const plat = bgPlatforms[i];
            const pulse = 0.6 + 0.4 * Math.sin(t + i * 2.1);
            // Glow
            ctx.save();
            ctx.shadowColor = plat.color;
            ctx.shadowBlur = 15 * pulse;
            ctx.fillStyle = plat.color;
            ctx.globalAlpha = 0.7 * pulse;
            ctx.fillRect(plat.x, plat.y, plat.width, 8);
            ctx.restore();
            // Solid core
            ctx.fillStyle = '#ffffff';
            ctx.globalAlpha = 0.5;
            ctx.fillRect(plat.x + 2, plat.y + 2, plat.width - 4, 4);
            ctx.globalAlpha = 1;
        }
    }

    // Frozen ice shelves
    if (bg.mechanic === 'ice_shelf') {
        for (const plat of bgPlatforms) {
            // Translucent blue ice
            ctx.fillStyle = 'rgba(160, 210, 255, 0.4)';
            ctx.fillRect(plat.x, plat.y, plat.width, 14);
            // Highlight
            ctx.fillStyle = 'rgba(220, 240, 255, 0.3)';
            ctx.fillRect(plat.x + 2, plat.y + 1, plat.width - 4, 4);
            // Border
            ctx.strokeStyle = 'rgba(180, 220, 255, 0.6)';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(plat.x, plat.y, plat.width, 14);
        }
    }

    // Ocean waves
    if (bg.mechanic === 'waves') {
        const waveY = H - 30;
        ctx.save();
        // Draw animated sine waves at bottom
        for (let layer = 0; layer < 3; layer++) {
            ctx.beginPath();
            ctx.moveTo(0, H);
            for (let x = 0; x <= W; x += 5) {
                const y = waveY + layer * 8 + Math.sin(x * 0.02 + wavePhase + layer * 1.5) * (8 - layer * 2);
                ctx.lineTo(x, y);
            }
            ctx.lineTo(W, H);
            ctx.closePath();
            ctx.fillStyle = `rgba(40, ${100 + layer * 30}, ${200 + layer * 20}, ${0.3 - layer * 0.08})`;
            ctx.fill();
        }
        // White foam on top wave
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        for (let x = 0; x <= W; x += 5) {
            const y = waveY + Math.sin(x * 0.02 + wavePhase) * 8;
            if (x === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.restore();
    }

    // Volcano lava bubbles
    if (bg.mechanic === 'lava_pop') {
        for (const lb of lavaBubbles) {
            const alpha = Math.min(1, lb.life);
            // Outer glow
            ctx.save();
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(lb.x, lb.y, lb.radius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 100, 0, ${alpha * 0.8})`;
            ctx.fill();
            ctx.restore();
            // Inner bright core
            ctx.beginPath();
            ctx.arc(lb.x, lb.y, lb.radius * 0.6, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 200, 50, ${alpha * 0.9})`;
            ctx.fill();
            // Highlight
            ctx.beginPath();
            ctx.arc(lb.x - lb.radius * 0.2, lb.y - lb.radius * 0.2, lb.radius * 0.25, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 200, ${alpha * 0.5})`;
            ctx.fill();
        }
    }
}

function drawLightningBolts() {
    for (const lb of lightningBolts) {
        const alpha = lb.life / lb.maxLife;
        ctx.save();
        ctx.strokeStyle = `rgba(255, 255, 100, ${alpha})`;
        ctx.lineWidth = 3;
        ctx.shadowColor = '#ffff00';
        ctx.shadowBlur = 10;
        // Draw jagged lightning bolt between two points
        const dx = lb.x2 - lb.x1;
        const dy = lb.y2 - lb.y1;
        const segments = 6;
        ctx.beginPath();
        ctx.moveTo(lb.x1, lb.y1);
        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const x = lb.x1 + dx * t + (Math.random() - 0.5) * 20;
            const y = lb.y1 + dy * t + (Math.random() - 0.5) * 20;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(lb.x2, lb.y2);
        ctx.stroke();
        // Draw a thinner white core
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(lb.x1, lb.y1);
        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const x = lb.x1 + dx * t + (Math.random() - 0.5) * 10;
            const y = lb.y1 + dy * t + (Math.random() - 0.5) * 10;
            ctx.lineTo(x, y);
        }
        ctx.lineTo(lb.x2, lb.y2);
        ctx.stroke();
        ctx.restore();
    }
}

function drawDustMotes() {
    for (const d of dustMotes) {
        ctx.globalAlpha = d.alpha;
        const dg = ctx.createRadialGradient(d.x, d.y, 0, d.x, d.y, d.size);
        dg.addColorStop(0, 'rgba(255,245,220,0.9)');
        dg.addColorStop(1, 'rgba(255,245,220,0)');
        ctx.beginPath();
        ctx.arc(d.x, d.y, d.size, 0, Math.PI * 2);
        ctx.fillStyle = dg;
        ctx.fill();
    }
    ctx.globalAlpha = 1;
}

// ===========================================
//  DRAWING — FRUIT SHADOWS
// ===========================================
function drawFruitShadow(f) {
    const shadowY = f.y + f.radius * 0.8;
    ctx.save();
    ctx.globalAlpha = 0.2;
    ctx.beginPath();
    ctx.ellipse(f.x + 5, shadowY + 5, f.radius * 0.7, f.radius * 0.25, 0, 0, Math.PI * 2);
    const sg = ctx.createRadialGradient(f.x + 5, shadowY + 5, 0, f.x + 5, shadowY + 5, f.radius * 0.7);
    sg.addColorStop(0, 'rgba(0,0,0,0.5)');
    sg.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = sg;
    ctx.fill();
    ctx.restore();
}

// ===========================================
//  DRAWING — INDIVIDUAL FRUITS (3D look)
// ===========================================
function drawWatermelon(r) {
    ctx.save();
    ctx.scale(1.15, 0.88);
    // Base dark green
    const bg = ctx.createRadialGradient(-r * 0.25, -r * 0.25, r * 0.05, 0, 0, r);
    bg.addColorStop(0, '#3a9a3a');
    bg.addColorStop(0.5, '#2d7a2d');
    bg.addColorStop(0.85, '#1a5a1a');
    bg.addColorStop(1, '#0e3e0e');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = bg;
    ctx.fill();
    // Stripes
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.clip();
    ctx.strokeStyle = '#4aad4a';
    ctx.lineWidth = 5;
    for (let i = -4; i <= 4; i++) {
        ctx.beginPath();
        ctx.moveTo(i * r * 0.28, -r * 1.1);
        ctx.quadraticCurveTo(i * r * 0.28 + r * 0.12, 0, i * r * 0.28, r * 1.1);
        ctx.stroke();
    }
    ctx.restore();
    ctx.restore();
    // 3D specular highlight
    const hl = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, -r * 0.3, -r * 0.3, r * 0.6);
    hl.addColorStop(0, 'rgba(255,255,255,0.35)');
    hl.addColorStop(0.5, 'rgba(255,255,255,0.1)');
    hl.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath();
    ctx.ellipse(0, 0, r * 1.15, r * 0.88, 0, 0, Math.PI * 2);
    ctx.fillStyle = hl;
    ctx.fill();
    // Rim light (bottom-right, for 3D depth)
    const rim = ctx.createRadialGradient(r * 0.3, r * 0.3, r * 0.6, 0, 0, r);
    rim.addColorStop(0, 'rgba(100,200,100,0.15)');
    rim.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.beginPath();
    ctx.ellipse(0, 0, r * 1.15, r * 0.88, 0, 0, Math.PI * 2);
    ctx.fillStyle = rim;
    ctx.fill();
}

function drawOrange(r) {
    // Base orange sphere with 3D gradient
    const bg = ctx.createRadialGradient(-r * 0.3, -r * 0.3, r * 0.05, 0, 0, r);
    bg.addColorStop(0, '#ffaa33');
    bg.addColorStop(0.4, '#f09020');
    bg.addColorStop(0.8, '#cc6600');
    bg.addColorStop(1, '#993300');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = bg;
    ctx.fill();
    // Dimpled texture
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.clip();
    ctx.fillStyle = 'rgba(180,80,0,0.15)';
    for (let i = 0; i < 30; i++) {
        const a = (i / 30) * Math.PI * 2 + i * 2.3;
        const d = r * 0.3 + (i % 7) * r * 0.09;
        const dx = Math.cos(a) * d;
        const dy = Math.sin(a) * d;
        ctx.beginPath();
        ctx.arc(dx, dy, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
    // Navel indent at bottom
    ctx.beginPath();
    ctx.arc(0, r * 0.6, r * 0.12, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(100,50,0,0.3)';
    ctx.fill();
    // Green stem/leaf at top
    ctx.save();
    ctx.translate(0, -r * 0.85);
    // Stem
    ctx.fillStyle = '#5a3a1a';
    ctx.fillRect(-2, -6, 4, 8);
    // Leaf
    ctx.beginPath();
    ctx.ellipse(5, -4, 8, 4, 0.3, 0, Math.PI * 2);
    ctx.fillStyle = '#3a8a2a';
    ctx.fill();
    ctx.restore();
    // Specular highlight
    const hl = ctx.createRadialGradient(-r * 0.3, -r * 0.35, 0, -r * 0.3, -r * 0.35, r * 0.5);
    hl.addColorStop(0, 'rgba(255,255,255,0.45)');
    hl.addColorStop(0.4, 'rgba(255,255,255,0.15)');
    hl.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = hl;
    ctx.fill();
    // Rim light
    const rim = ctx.createRadialGradient(r * 0.35, r * 0.25, r * 0.5, 0, 0, r);
    rim.addColorStop(0, 'rgba(255,180,80,0.2)');
    rim.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = rim;
    ctx.fill();
}

function drawApple(r) {
    // Heart-shape indent at top using two overlapping circles
    ctx.save();
    // Main body - two arcs creating heart-like shape
    ctx.beginPath();
    // Left lobe
    ctx.arc(-r * 0.22, -r * 0.1, r * 0.85, -Math.PI * 0.1, Math.PI * 1.0);
    // Bottom curve
    ctx.quadraticCurveTo(0, r * 1.15, r * 0.22, r * 0.6);
    // Right lobe
    ctx.arc(r * 0.22, -r * 0.1, r * 0.85, Math.PI * 0.0, -Math.PI * 0.9, true);
    ctx.closePath();
    // 3D gradient
    const bg = ctx.createRadialGradient(-r * 0.2, -r * 0.2, r * 0.05, 0, 0, r);
    bg.addColorStop(0, '#ee3333');
    bg.addColorStop(0.3, '#cc1111');
    bg.addColorStop(0.7, '#aa0000');
    bg.addColorStop(1, '#660000');
    ctx.fillStyle = bg;
    ctx.fill();
    ctx.restore();
    // Stem
    ctx.save();
    ctx.translate(0, -r * 0.8);
    ctx.rotate(-0.15);
    ctx.fillStyle = '#5a3a1a';
    ctx.fillRect(-1.5, -10, 3, 12);
    ctx.restore();
    // Leaf
    ctx.save();
    ctx.translate(3, -r * 0.85);
    ctx.rotate(0.3);
    ctx.beginPath();
    ctx.ellipse(5, -2, 10, 5, 0.2, 0, Math.PI * 2);
    ctx.fillStyle = '#3a9a2a';
    ctx.fill();
    // Leaf vein
    ctx.beginPath();
    ctx.moveTo(0, -2);
    ctx.lineTo(10, -2);
    ctx.strokeStyle = '#2a7a1a';
    ctx.lineWidth = 0.8;
    ctx.stroke();
    ctx.restore();
    // Specular
    const hl = ctx.createRadialGradient(-r * 0.3, -r * 0.35, 0, -r * 0.3, -r * 0.35, r * 0.55);
    hl.addColorStop(0, 'rgba(255,255,255,0.5)');
    hl.addColorStop(0.3, 'rgba(255,255,255,0.2)');
    hl.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = hl;
    ctx.fill();
    // Rim light
    const rim = ctx.createRadialGradient(r * 0.3, r * 0.2, r * 0.5, 0, 0, r);
    rim.addColorStop(0, 'rgba(255,100,100,0.2)');
    rim.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = rim;
    ctx.fill();
}

function drawBanana(r) {
    // Crescent shape
    const len = r * 2.3;
    const curve = r * 1.0;
    // Banana body
    ctx.beginPath();
    ctx.moveTo(-len / 2, 0);
    ctx.quadraticCurveTo(-len * 0.15, -curve, len / 2, -curve * 0.2);
    ctx.quadraticCurveTo(len / 2 + r * 0.3, -curve * 0.05, len / 2 + r * 0.1, curve * 0.15);
    ctx.quadraticCurveTo(-len * 0.15, curve * 0.5, -len / 2, 0);
    ctx.closePath();
    // 3D gradient
    const bg = ctx.createLinearGradient(0, -curve, 0, curve * 0.3);
    bg.addColorStop(0, '#f7e84a');
    bg.addColorStop(0.3, '#f0d800');
    bg.addColorStop(0.7, '#d4b800');
    bg.addColorStop(1, '#b89a00');
    ctx.fillStyle = bg;
    ctx.fill();
    // Edge outline for definition
    ctx.strokeStyle = 'rgba(120,90,0,0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Brown tips
    ctx.beginPath();
    ctx.arc(-len / 2, 0, 4, 0, Math.PI * 2);
    ctx.fillStyle = '#6a4a20';
    ctx.fill();
    ctx.beginPath();
    ctx.arc(len / 2 + r * 0.05, -curve * 0.1, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#6a4a20';
    ctx.fill();
    // Spotting
    ctx.fillStyle = 'rgba(120,80,20,0.15)';
    for (let i = 0; i < 5; i++) {
        const sx = -len * 0.3 + i * len * 0.15;
        const sy = -curve * 0.3 + Math.sin(i * 1.7) * r * 0.2;
        ctx.beginPath();
        ctx.arc(sx, sy, 2 + Math.random(), 0, Math.PI * 2);
        ctx.fill();
    }
    // Specular highlight along top curve
    const hl = ctx.createRadialGradient(-len * 0.1, -curve * 0.6, 0, -len * 0.1, -curve * 0.6, len * 0.4);
    hl.addColorStop(0, 'rgba(255,255,255,0.35)');
    hl.addColorStop(0.5, 'rgba(255,255,255,0.1)');
    hl.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath();
    ctx.moveTo(-len / 2, 0);
    ctx.quadraticCurveTo(-len * 0.15, -curve, len / 2, -curve * 0.2);
    ctx.quadraticCurveTo(len / 2 + r * 0.3, -curve * 0.05, len / 2 + r * 0.1, curve * 0.15);
    ctx.quadraticCurveTo(-len * 0.15, curve * 0.5, -len / 2, 0);
    ctx.closePath();
    ctx.fillStyle = hl;
    ctx.fill();
}

function drawStrawberry(r) {
    // Teardrop shape: wide at top, pointed at bottom
    ctx.beginPath();
    ctx.moveTo(0, r * 1.0); // bottom point
    ctx.bezierCurveTo(-r * 0.6, r * 0.4, -r * 0.9, -r * 0.2, -r * 0.55, -r * 0.7);
    ctx.quadraticCurveTo(0, -r * 1.1, r * 0.55, -r * 0.7);
    ctx.bezierCurveTo(r * 0.9, -r * 0.2, r * 0.6, r * 0.4, 0, r * 1.0);
    ctx.closePath();
    // 3D gradient
    const bg = ctx.createRadialGradient(-r * 0.15, -r * 0.2, r * 0.05, 0, 0, r);
    bg.addColorStop(0, '#ff4466');
    bg.addColorStop(0.4, '#dd2244');
    bg.addColorStop(0.8, '#aa1133');
    bg.addColorStop(1, '#770011');
    ctx.fillStyle = bg;
    ctx.fill();
    // Yellow seed dots
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(0, r * 1.0);
    ctx.bezierCurveTo(-r * 0.6, r * 0.4, -r * 0.9, -r * 0.2, -r * 0.55, -r * 0.7);
    ctx.quadraticCurveTo(0, -r * 1.1, r * 0.55, -r * 0.7);
    ctx.bezierCurveTo(r * 0.9, -r * 0.2, r * 0.6, r * 0.4, 0, r * 1.0);
    ctx.clip();
    ctx.fillStyle = '#ffcc44';
    for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 3; col++) {
            const sx = (col - 1) * r * 0.35 + (row % 2) * r * 0.17;
            const sy = -r * 0.5 + row * r * 0.35;
            ctx.beginPath();
            ctx.ellipse(sx, sy, 1.8, 2.5, 0.2, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    ctx.restore();
    // Green crown
    ctx.save();
    ctx.translate(0, -r * 0.75);
    for (let i = 0; i < 5; i++) {
        ctx.save();
        ctx.rotate((i - 2) * 0.35);
        ctx.beginPath();
        ctx.ellipse(0, -5, 4, 9, 0, 0, Math.PI * 2);
        ctx.fillStyle = '#3a9a2a';
        ctx.fill();
        ctx.restore();
    }
    ctx.restore();
    // Specular
    const hl = ctx.createRadialGradient(-r * 0.25, -r * 0.4, 0, -r * 0.25, -r * 0.4, r * 0.5);
    hl.addColorStop(0, 'rgba(255,255,255,0.4)');
    hl.addColorStop(0.4, 'rgba(255,255,255,0.1)');
    hl.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = hl;
    ctx.fill();
}

function drawKiwi(r) {
    // Brown fuzzy exterior
    const bg = ctx.createRadialGradient(-r * 0.25, -r * 0.25, r * 0.05, 0, 0, r);
    bg.addColorStop(0, '#8a6a3e');
    bg.addColorStop(0.5, '#6b4a26');
    bg.addColorStop(0.85, '#4a3018');
    bg.addColorStop(1, '#3a200e');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = bg;
    ctx.fill();
    // Fuzzy texture (dots around perimeter and surface)
    ctx.fillStyle = 'rgba(100,70,30,0.4)';
    for (let i = 0; i < 40; i++) {
        const a = (i / 40) * Math.PI * 2;
        const d = r * (0.5 + Math.random() * 0.45);
        ctx.beginPath();
        ctx.arc(Math.cos(a) * d, Math.sin(a) * d, 0.8 + Math.random() * 0.8, 0, Math.PI * 2);
        ctx.fill();
    }
    // Rough edge dots
    ctx.fillStyle = 'rgba(80,50,20,0.3)';
    for (let i = 0; i < 24; i++) {
        const a = (i / 24) * Math.PI * 2;
        ctx.beginPath();
        ctx.arc(Math.cos(a) * (r - 1), Math.sin(a) * (r - 1), 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
    // Specular
    const hl = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, -r * 0.3, -r * 0.3, r * 0.5);
    hl.addColorStop(0, 'rgba(255,255,255,0.3)');
    hl.addColorStop(0.4, 'rgba(255,255,255,0.08)');
    hl.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = hl;
    ctx.fill();
    // Rim light
    const rim = ctx.createRadialGradient(r * 0.3, r * 0.3, r * 0.5, 0, 0, r);
    rim.addColorStop(0, 'rgba(150,120,70,0.15)');
    rim.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = rim;
    ctx.fill();
}

function drawBomb(f) {
    const r = f.radius;
    // Red danger glow aura (pulsing)
    const pulse = 0.5 + 0.5 * Math.sin(performance.now() * 0.008);
    const glow = ctx.createRadialGradient(0, 0, r * 0.5, 0, 0, r * 2.2);
    glow.addColorStop(0, `rgba(255, 30, 0, ${0.15 + pulse * 0.15})`);
    glow.addColorStop(0.5, `rgba(255, 0, 0, ${0.05 + pulse * 0.08})`);
    glow.addColorStop(1, 'rgba(255, 0, 0, 0)');
    ctx.beginPath();
    ctx.arc(0, 0, r * 2.2, 0, Math.PI * 2);
    ctx.fillStyle = glow;
    ctx.fill();
    // Metallic dark sphere
    const bg = ctx.createRadialGradient(-r * 0.2, -r * 0.25, r * 0.05, 0, 0, r);
    bg.addColorStop(0, '#555555');
    bg.addColorStop(0.3, '#3a3a3a');
    bg.addColorStop(0.7, '#1a1a1a');
    bg.addColorStop(1, '#080808');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = bg;
    ctx.fill();
    // Metallic rim
    ctx.strokeStyle = 'rgba(100,100,100,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Metallic sheen
    const sheen = ctx.createRadialGradient(-r * 0.3, -r * 0.3, 0, -r * 0.3, -r * 0.3, r * 0.5);
    sheen.addColorStop(0, 'rgba(255,255,255,0.2)');
    sheen.addColorStop(0.5, 'rgba(255,255,255,0.05)');
    sheen.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = sheen;
    ctx.fill();
    // Thick bezier fuse
    ctx.beginPath();
    ctx.moveTo(0, -r + 2);
    ctx.bezierCurveTo(3, -r - 5, 8, -r - 10, 5, -r - 16);
    ctx.strokeStyle = '#8a7a6a';
    ctx.lineWidth = 4;
    ctx.stroke();
    ctx.strokeStyle = '#a09080';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Animated spark particles at fuse tip
    const fuseAngle = f.fuseAngle || 0;
    for (let i = 0; i < 4; i++) {
        const sa = fuseAngle + i * Math.PI / 2;
        const sd = 3 + Math.random() * 5;
        const sx = 5 + Math.cos(sa) * sd;
        const sy = -r - 16 + Math.sin(sa) * sd;
        const sparkR = 1.5 + Math.random() * 2.5;
        const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, sparkR);
        sg.addColorStop(0, '#ffffff');
        sg.addColorStop(0.3, '#ffcc00');
        sg.addColorStop(1, 'rgba(255, 100, 0, 0)');
        ctx.beginPath();
        ctx.arc(sx, sy, sparkR, 0, Math.PI * 2);
        ctx.fillStyle = sg;
        ctx.fill();
    }
    // Bright core spark
    const coreR = 3 + Math.random() * 2;
    const cg = ctx.createRadialGradient(5, -r - 16, 0, 5, -r - 16, coreR);
    cg.addColorStop(0, '#ffffff');
    cg.addColorStop(0.5, '#ffdd44');
    cg.addColorStop(1, 'rgba(255,150,0,0)');
    ctx.beginPath();
    ctx.arc(5, -r - 16, coreR, 0, Math.PI * 2);
    ctx.fillStyle = cg;
    ctx.fill();
}

// ===========================================
//  DRAWING — SPECIAL ITEMS
// ===========================================
function drawStar(r) {
    const spikes = 5;
    const outerR = r;
    const innerR = r * 0.45;
    // Pulsing glow
    const pulse = 0.7 + 0.3 * Math.sin(performance.now() * 0.005);
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 18 * pulse;
    // Star shape
    const grad = ctx.createRadialGradient(0, 0, innerR * 0.3, 0, 0, outerR);
    grad.addColorStop(0, '#fff8cc');
    grad.addColorStop(0.4, '#ffd700');
    grad.addColorStop(1, '#cc9900');
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
        const rad = (i % 2 === 0) ? outerR : innerR;
        const angle = -Math.PI / 2 + (i * Math.PI) / spikes;
        const method = i === 0 ? 'moveTo' : 'lineTo';
        ctx[method](Math.cos(angle) * rad, Math.sin(angle) * rad);
    }
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = '#aa7700';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Specular highlight
    ctx.beginPath();
    ctx.arc(-r * 0.15, -r * 0.15, r * 0.2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.fill();
    ctx.shadowBlur = 0;
}

function drawDiamond(r) {
    const w = r * 0.65;
    const h = r;
    // Rainbow shimmer
    const t = performance.now() * 0.003;
    const hue = (t * 60) % 360;
    ctx.shadowColor = `hsl(${hue}, 80%, 70%)`;
    ctx.shadowBlur = 20;
    // Diamond shape (tall rhombus)
    const grad = ctx.createLinearGradient(-w, 0, w, 0);
    grad.addColorStop(0, `hsl(${hue}, 70%, 85%)`);
    grad.addColorStop(0.3, '#ffffff');
    grad.addColorStop(0.5, `hsl(${(hue + 120) % 360}, 70%, 85%)`);
    grad.addColorStop(0.7, '#ffffff');
    grad.addColorStop(1, `hsl(${(hue + 240) % 360}, 70%, 85%)`);
    ctx.beginPath();
    ctx.moveTo(0, -h);
    ctx.lineTo(w, 0);
    ctx.lineTo(0, h);
    ctx.lineTo(-w, 0);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = 'rgba(100,150,255,0.6)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Inner facet lines
    ctx.strokeStyle = 'rgba(255,255,255,0.4)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, -h * 0.5);
    ctx.lineTo(w * 0.6, 0);
    ctx.lineTo(0, h * 0.5);
    ctx.lineTo(-w * 0.6, 0);
    ctx.closePath();
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function drawHeart(r) {
    const s = r * 0.035;
    ctx.shadowColor = '#ff4466';
    ctx.shadowBlur = 14;
    const grad = ctx.createRadialGradient(-r * 0.1, -r * 0.2, 0, 0, 0, r);
    grad.addColorStop(0, '#ff8899');
    grad.addColorStop(0.5, '#ff4466');
    grad.addColorStop(1, '#cc1133');
    ctx.beginPath();
    ctx.moveTo(0, s * 7);
    ctx.bezierCurveTo(-s * 1, s * 4, -s * 12, s * 1, -s * 12, -s * 4);
    ctx.bezierCurveTo(-s * 12, -s * 10, -s * 5, -s * 12, 0, -s * 7);
    ctx.bezierCurveTo(s * 5, -s * 12, s * 12, -s * 10, s * 12, -s * 4);
    ctx.bezierCurveTo(s * 12, s * 1, s * 1, s * 4, 0, s * 7);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    // Highlight
    ctx.beginPath();
    ctx.arc(-r * 0.25, -r * 0.2, r * 0.18, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fill();
    ctx.shadowBlur = 0;
}

function drawCoin(r) {
    ctx.shadowColor = '#ffd700';
    ctx.shadowBlur = 12;
    // Gold disc
    const grad = ctx.createRadialGradient(-r * 0.2, -r * 0.2, 0, 0, 0, r);
    grad.addColorStop(0, '#fff0a0');
    grad.addColorStop(0.4, '#ffd700');
    grad.addColorStop(0.8, '#cc9900');
    grad.addColorStop(1, '#997700');
    ctx.beginPath();
    ctx.arc(0, 0, r, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = '#886600';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Inner ring
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.75, 0, Math.PI * 2);
    ctx.strokeStyle = 'rgba(170,120,0,0.4)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // $ symbol
    ctx.font = `bold ${r * 1.1}px "Segoe UI", sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#886600';
    ctx.fillText('$', 0, 1);
    ctx.fillStyle = '#ffe066';
    ctx.fillText('$', -1, 0);
    ctx.shadowBlur = 0;
}

function drawHourglass(r) {
    ctx.shadowColor = '#4488ff';
    ctx.shadowBlur = 14;
    const grad = ctx.createLinearGradient(0, -r, 0, r);
    grad.addColorStop(0, '#88bbff');
    grad.addColorStop(0.5, '#4488ff');
    grad.addColorStop(1, '#2266cc');
    // Top triangle
    ctx.beginPath();
    ctx.moveTo(-r * 0.6, -r);
    ctx.lineTo(r * 0.6, -r);
    ctx.lineTo(0, 0);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    // Bottom triangle
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-r * 0.6, r);
    ctx.lineTo(r * 0.6, r);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    // Frame lines
    ctx.strokeStyle = '#2255aa';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(-r * 0.7, -r);
    ctx.lineTo(r * 0.7, -r);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-r * 0.7, r);
    ctx.lineTo(r * 0.7, r);
    ctx.stroke();
    // Sand (top)
    ctx.fillStyle = '#ffdd88';
    ctx.beginPath();
    ctx.moveTo(-r * 0.3, -r * 0.85);
    ctx.lineTo(r * 0.3, -r * 0.85);
    ctx.lineTo(0, -r * 0.15);
    ctx.closePath();
    ctx.fill();
    // Sand (bottom)
    ctx.beginPath();
    ctx.moveTo(-r * 0.35, r * 0.85);
    ctx.lineTo(r * 0.35, r * 0.85);
    ctx.lineTo(0, r * 0.25);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
}

function drawShield(r) {
    ctx.shadowColor = '#4488ff';
    ctx.shadowBlur = 16;
    // Shield shape
    const grad = ctx.createLinearGradient(0, -r, 0, r);
    grad.addColorStop(0, '#88ccff');
    grad.addColorStop(0.4, '#4488ff');
    grad.addColorStop(1, '#2255aa');
    ctx.beginPath();
    ctx.moveTo(0, -r);
    ctx.quadraticCurveTo(r, -r * 0.6, r, 0);
    ctx.quadraticCurveTo(r, r * 0.6, 0, r);
    ctx.quadraticCurveTo(-r, r * 0.6, -r, 0);
    ctx.quadraticCurveTo(-r, -r * 0.6, 0, -r);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = '#1144aa';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Cross emblem
    ctx.fillStyle = 'rgba(255,255,255,0.5)';
    ctx.fillRect(-r * 0.08, -r * 0.5, r * 0.16, r);
    ctx.fillRect(-r * 0.4, -r * 0.08, r * 0.8, r * 0.16);
    // Highlight
    ctx.beginPath();
    ctx.arc(-r * 0.25, -r * 0.3, r * 0.2, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fill();
    ctx.shadowBlur = 0;
}

function drawSkull(r) {
    // Toxic green glow
    ctx.shadowColor = '#44ff44';
    ctx.shadowBlur = 16;
    // Head
    const grad = ctx.createRadialGradient(-r * 0.1, -r * 0.15, 0, 0, 0, r);
    grad.addColorStop(0, '#cccccc');
    grad.addColorStop(0.6, '#999999');
    grad.addColorStop(1, '#555555');
    ctx.beginPath();
    ctx.arc(0, -r * 0.15, r * 0.7, 0, Math.PI * 2);
    ctx.fillStyle = grad;
    ctx.fill();
    // Jaw
    ctx.beginPath();
    ctx.moveTo(-r * 0.45, r * 0.15);
    ctx.quadraticCurveTo(-r * 0.3, r * 0.65, 0, r * 0.55);
    ctx.quadraticCurveTo(r * 0.3, r * 0.65, r * 0.45, r * 0.15);
    ctx.fillStyle = '#888';
    ctx.fill();
    // Eye sockets
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.ellipse(-r * 0.22, -r * 0.2, r * 0.16, r * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(r * 0.22, -r * 0.2, r * 0.16, r * 0.18, 0, 0, Math.PI * 2);
    ctx.fill();
    // Green glow in eyes
    ctx.fillStyle = 'rgba(68,255,68,0.5)';
    ctx.beginPath();
    ctx.arc(-r * 0.22, -r * 0.2, r * 0.08, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(r * 0.22, -r * 0.2, r * 0.08, 0, Math.PI * 2);
    ctx.fill();
    // Nose
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.moveTo(0, -r * 0.02);
    ctx.lineTo(-r * 0.07, r * 0.1);
    ctx.lineTo(r * 0.07, r * 0.1);
    ctx.closePath();
    ctx.fill();
    // Teeth
    ctx.fillStyle = '#ddd';
    for (let i = -2; i <= 2; i++) {
        ctx.fillRect(i * r * 0.11 - r * 0.04, r * 0.2, r * 0.08, r * 0.12);
    }
    ctx.shadowBlur = 0;
}

function drawRock(r) {
    ctx.shadowColor = '#666';
    ctx.shadowBlur = 6;
    // Irregular stone shape using bezier curves
    const grad = ctx.createRadialGradient(-r * 0.2, -r * 0.2, 0, 0, 0, r);
    grad.addColorStop(0, '#aaaaaa');
    grad.addColorStop(0.5, '#888888');
    grad.addColorStop(1, '#555555');
    ctx.beginPath();
    ctx.moveTo(-r * 0.8, -r * 0.3);
    ctx.lineTo(-r * 0.5, -r * 0.8);
    ctx.lineTo(r * 0.1, -r * 0.9);
    ctx.lineTo(r * 0.7, -r * 0.6);
    ctx.lineTo(r * 0.9, -r * 0.1);
    ctx.lineTo(r * 0.7, r * 0.5);
    ctx.lineTo(r * 0.2, r * 0.8);
    ctx.lineTo(-r * 0.4, r * 0.7);
    ctx.lineTo(-r * 0.8, r * 0.3);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Crack lines
    ctx.strokeStyle = 'rgba(60,60,60,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-r * 0.3, -r * 0.4);
    ctx.lineTo(r * 0.1, 0);
    ctx.lineTo(-r * 0.1, r * 0.3);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(r * 0.1, 0);
    ctx.lineTo(r * 0.4, -r * 0.15);
    ctx.stroke();
    // Light specular spot
    ctx.beginPath();
    ctx.arc(-r * 0.2, -r * 0.3, r * 0.15, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fill();
    ctx.shadowBlur = 0;
}

function drawPoison(r) {
    ctx.shadowColor = '#44ff44';
    ctx.shadowBlur = 14;
    // Bottle body
    const grad = ctx.createLinearGradient(-r * 0.4, 0, r * 0.4, 0);
    grad.addColorStop(0, '#228822');
    grad.addColorStop(0.3, '#44bb44');
    grad.addColorStop(0.7, '#33aa33');
    grad.addColorStop(1, '#1a6a1a');
    ctx.beginPath();
    ctx.moveTo(-r * 0.45, r * 0.8);
    ctx.lineTo(-r * 0.45, -r * 0.1);
    ctx.quadraticCurveTo(-r * 0.45, -r * 0.3, -r * 0.2, -r * 0.35);
    ctx.lineTo(-r * 0.2, -r * 0.6);
    ctx.lineTo(r * 0.2, -r * 0.6);
    ctx.lineTo(r * 0.2, -r * 0.35);
    ctx.quadraticCurveTo(r * 0.45, -r * 0.3, r * 0.45, -r * 0.1);
    ctx.lineTo(r * 0.45, r * 0.8);
    ctx.closePath();
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.strokeStyle = '#115511';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    // Cork
    ctx.fillStyle = '#8B6914';
    ctx.fillRect(-r * 0.15, -r * 0.8, r * 0.3, r * 0.22);
    // Skull label
    ctx.fillStyle = '#ffffcc';
    ctx.fillRect(-r * 0.28, -r * 0.05, r * 0.56, r * 0.5);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 0.8;
    ctx.strokeRect(-r * 0.28, -r * 0.05, r * 0.56, r * 0.5);
    // Mini skull on label
    ctx.fillStyle = '#333';
    ctx.beginPath();
    ctx.arc(0, r * 0.12, r * 0.12, 0, Math.PI * 2);
    ctx.fill();
    // Crossbones
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-r * 0.2, r * 0.3);
    ctx.lineTo(r * 0.2, r * 0.38);
    ctx.moveTo(r * 0.2, r * 0.3);
    ctx.lineTo(-r * 0.2, r * 0.38);
    ctx.stroke();
    ctx.shadowBlur = 0;
}

// ===========================================
//  DRAWING — drawFruit dispatcher
// ===========================================
function drawFruit(f) {
    ctx.save();
    ctx.translate(f.x, f.y);

    // Night background: glow aura around fruits
    if (getEquippedBg().mechanic === 'glow_fruits' && !f.isBomb) {
        ctx.save();
        const glowColor = f.isSpecial ? f.inner : f.outer;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = 25;
        ctx.beginPath();
        ctx.arc(0, 0, f.radius * 0.8, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,200,0.15)';
        ctx.fill();
        ctx.restore();
    }

    // Ice blade: frozen visual (blue tint overlay)
    if (f.frozenTimer && f.frozenTimer > 0) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(0, 0, f.radius + 5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(100, 200, 255, 0.25)';
        ctx.fill();
        ctx.restore();
    }

    ctx.rotate(f.rotation);

    if (f.isBomb) {
        drawBomb(f);
    } else if (f.isSpecial) {
        switch (f.name) {
            case 'star': drawStar(f.radius); break;
            case 'diamond': drawDiamond(f.radius); break;
            case 'heart': drawHeart(f.radius); break;
            case 'coin': drawCoin(f.radius); break;
            case 'hourglass': drawHourglass(f.radius); break;
            case 'shield': drawShield(f.radius); break;
            case 'skull': drawSkull(f.radius); break;
            case 'rock': drawRock(f.radius); break;
            case 'poison': drawPoison(f.radius); break;
        }
    } else {
        switch (f.name) {
            case 'watermelon': drawWatermelon(f.radius); break;
            case 'orange': drawOrange(f.radius); break;
            case 'apple': drawApple(f.radius); break;
            case 'banana': drawBanana(f.radius); break;
            case 'strawberry': drawStrawberry(f.radius); break;
            case 'kiwi': drawKiwi(f.radius); break;
        }
    }

    ctx.restore();
}

// ===========================================
//  DRAWING — FRUIT HALVES (cross-sections)
// ===========================================
function drawWatermelonHalf(r, side) {
    // Half circle outer rind
    ctx.beginPath();
    ctx.arc(0, 0, r, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    ctx.fillStyle = '#1a5a1a';
    ctx.fill();
    // White rind line
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.88, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    ctx.fillStyle = '#ccddaa';
    ctx.fill();
    // Red interior
    const ig = ctx.createRadialGradient(-r * 0.1, 0, 0, 0, 0, r * 0.85);
    ig.addColorStop(0, '#ff4444');
    ig.addColorStop(0.7, '#ee2222');
    ig.addColorStop(1, '#cc1111');
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.82, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    ctx.fillStyle = ig;
    ctx.fill();
    // Black seeds
    ctx.fillStyle = '#1a0a00';
    const seeds = [[-0.1, -0.4], [0.1, -0.2], [-0.15, 0.1], [0.2, 0.3], [-0.05, 0.45], [0.15, -0.5]];
    for (const [sx, sy] of seeds) {
        ctx.save();
        ctx.translate(r * sx, r * sy);
        ctx.rotate(Math.atan2(sy, sx - 0.3));
        ctx.beginPath();
        ctx.ellipse(0, 0, 3, 1.8, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
    // Flat face line
    ctx.beginPath();
    ctx.moveTo(0, -r);
    ctx.lineTo(0, r);
    ctx.strokeStyle = 'rgba(200,100,100,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawOrangeHalf(r, side) {
    // Outer rind
    ctx.beginPath();
    ctx.arc(0, 0, r, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    const og = ctx.createRadialGradient(-r * 0.1, 0, 0, 0, 0, r);
    og.addColorStop(0, '#ffcc66');
    og.addColorStop(0.8, '#ee8800');
    og.addColorStop(1, '#cc6600');
    ctx.fillStyle = og;
    ctx.fill();
    // Inner segments
    ctx.save();
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.85, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    ctx.clip();
    // Segment lines radiating from center
    ctx.strokeStyle = 'rgba(255,200,100,0.5)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
        const a = -Math.PI / 2 + (i / 8) * Math.PI;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(a) * r, Math.sin(a) * r);
        ctx.stroke();
    }
    // White pith circle
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.12, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,230,0.6)';
    ctx.fill();
    ctx.restore();
    // Flat face
    ctx.beginPath();
    ctx.moveTo(0, -r);
    ctx.lineTo(0, r);
    ctx.strokeStyle = 'rgba(200,150,50,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawAppleHalf(r, side) {
    ctx.beginPath();
    ctx.arc(0, 0, r, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    // Red exterior
    const og = ctx.createRadialGradient(-r * 0.1, 0, 0, 0, 0, r);
    og.addColorStop(0, '#ffeecc');
    og.addColorStop(0.75, '#ffddaa');
    og.addColorStop(0.9, '#cc1111');
    og.addColorStop(1, '#aa0000');
    ctx.fillStyle = og;
    ctx.fill();
    // Seed pocket in center
    ctx.beginPath();
    ctx.ellipse(r * 0.05, 0, r * 0.08, r * 0.2, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(140,100,50,0.4)';
    ctx.fill();
    // Seeds
    ctx.fillStyle = '#4a3020';
    ctx.beginPath();
    ctx.ellipse(r * 0.05, -r * 0.08, 2, 4, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(r * 0.05, r * 0.08, 2, 4, 0.3, 0, Math.PI * 2);
    ctx.fill();
    // Flat face
    ctx.beginPath();
    ctx.moveTo(0, -r);
    ctx.lineTo(0, r);
    ctx.strokeStyle = 'rgba(180,150,100,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawBananaHalf(r, side) {
    // Banana half - crescent cut
    const len = r * 1.1;
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.8, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    // Yellow exterior thin ring
    ctx.fillStyle = '#d4b800';
    ctx.fill();
    // White/cream interior
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.65, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    ctx.fillStyle = '#fff9e0';
    ctx.fill();
    // Flat face
    ctx.beginPath();
    ctx.moveTo(0, -r * 0.8);
    ctx.lineTo(0, r * 0.8);
    ctx.strokeStyle = 'rgba(180,150,50,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawStrawberryHalf(r, side) {
    // Teardrop half
    ctx.beginPath();
    ctx.arc(0, 0, r, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    const sg = ctx.createRadialGradient(-r * 0.1, 0, 0, 0, 0, r);
    sg.addColorStop(0, '#ff8899');
    sg.addColorStop(0.6, '#ee4466');
    sg.addColorStop(0.9, '#cc2244');
    sg.addColorStop(1, '#aa1133');
    ctx.fillStyle = sg;
    ctx.fill();
    // White core line
    ctx.beginPath();
    ctx.moveTo(0, -r * 0.6);
    ctx.lineTo(r * 0.15, 0);
    ctx.lineTo(0, r * 0.6);
    ctx.strokeStyle = 'rgba(255,230,230,0.4)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Tiny seeds in cross section
    ctx.fillStyle = '#ffcc44';
    for (let i = 0; i < 6; i++) {
        const a = -Math.PI / 3 + (i / 5) * (Math.PI * 2 / 3);
        ctx.beginPath();
        ctx.arc(Math.cos(a) * r * 0.5, Math.sin(a) * r * 0.5, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
    // Flat face
    ctx.beginPath();
    ctx.moveTo(0, -r);
    ctx.lineTo(0, r);
    ctx.strokeStyle = 'rgba(200,100,100,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawKiwiHalf(r, side) {
    // Brown exterior ring
    ctx.beginPath();
    ctx.arc(0, 0, r, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    ctx.fillStyle = '#5a3a18';
    ctx.fill();
    // Bright green interior
    const kg = ctx.createRadialGradient(r * 0.05, 0, 0, 0, 0, r * 0.88);
    kg.addColorStop(0, '#ffffff');
    kg.addColorStop(0.15, '#d4f0a0');
    kg.addColorStop(0.5, '#a8e06c');
    kg.addColorStop(0.85, '#7cc040');
    kg.addColorStop(1, '#5a9a28');
    ctx.beginPath();
    ctx.arc(0, 0, r * 0.88, -Math.PI / 2, Math.PI / 2);
    ctx.closePath();
    ctx.fillStyle = kg;
    ctx.fill();
    // White center core
    ctx.beginPath();
    ctx.ellipse(r * 0.05, 0, r * 0.06, r * 0.35, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fill();
    // Seed ring
    ctx.fillStyle = '#2a1a0a';
    for (let i = 0; i < 12; i++) {
        const a = (i / 12) * Math.PI * 2;
        const d = r * 0.45;
        const sx = r * 0.05 + Math.cos(a) * d;
        const sy = Math.sin(a) * d;
        // Only draw seeds in the right half
        if (sx >= -r * 0.1) {
            ctx.beginPath();
            ctx.ellipse(sx, sy, 1.5, 0.8, a, 0, Math.PI * 2);
            ctx.fill();
        }
    }
    // Flat face
    ctx.beginPath();
    ctx.moveTo(0, -r);
    ctx.lineTo(0, r);
    ctx.strokeStyle = 'rgba(100,80,40,0.3)';
    ctx.lineWidth = 2;
    ctx.stroke();
}

function drawHalf(h) {
    ctx.save();
    ctx.translate(h.x, h.y);
    ctx.rotate(h.rotation);

    const alpha = Math.min(1, h.life);
    ctx.globalAlpha = alpha;

    // Scale by side for mirror effect
    ctx.scale(h.side, 1);

    switch (h.name) {
        case 'watermelon': drawWatermelonHalf(h.radius, h.side); break;
        case 'orange': drawOrangeHalf(h.radius, h.side); break;
        case 'apple': drawAppleHalf(h.radius, h.side); break;
        case 'banana': drawBananaHalf(h.radius, h.side); break;
        case 'strawberry': drawStrawberryHalf(h.radius, h.side); break;
        case 'kiwi': drawKiwiHalf(h.radius, h.side); break;
    }

    ctx.globalAlpha = 1;
    ctx.restore();
}

// ===========================================
//  DRAWING — BLADE TRAIL (tapered, sparkles)
// ===========================================
function drawBladeTrail() {
    if (!isPointerDown || bladePoints.length < 2) return;
    const now = performance.now();
    const recent = bladePoints.filter(p => now - p.t < 220);
    if (recent.length < 2) return;

    ctx.save();

    // Build tapered polygon points
    const topEdge = [];
    const bottomEdge = [];
    for (let i = 0; i < recent.length; i++) {
        const t = i / (recent.length - 1); // 0 at tail, 1 at head
        const width = 1 + t * 12; // thinner at tail, wider at head

        let nx, ny;
        if (i < recent.length - 1) {
            const dx = recent[i + 1].x - recent[i].x;
            const dy = recent[i + 1].y - recent[i].y;
            const len = Math.hypot(dx, dy) || 1;
            nx = -dy / len;
            ny = dx / len;
        } else {
            const dx = recent[i].x - recent[i - 1].x;
            const dy = recent[i].y - recent[i - 1].y;
            const len = Math.hypot(dx, dy) || 1;
            nx = -dy / len;
            ny = dx / len;
        }
        topEdge.push({ x: recent[i].x + nx * width, y: recent[i].y + ny * width });
        bottomEdge.push({ x: recent[i].x - nx * width, y: recent[i].y - ny * width });
    }

    // Outer glow layer
    ctx.beginPath();
    ctx.moveTo(topEdge[0].x, topEdge[0].y);
    for (let i = 1; i < topEdge.length; i++) {
        if (i < topEdge.length - 1) {
            const cx = (topEdge[i].x + topEdge[i + 1].x) / 2;
            const cy = (topEdge[i].y + topEdge[i + 1].y) / 2;
            ctx.quadraticCurveTo(topEdge[i].x, topEdge[i].y, cx, cy);
        } else {
            ctx.lineTo(topEdge[i].x, topEdge[i].y);
        }
    }
    for (let i = bottomEdge.length - 1; i >= 0; i--) {
        if (i > 0) {
            const cx = (bottomEdge[i].x + bottomEdge[i - 1].x) / 2;
            const cy = (bottomEdge[i].y + bottomEdge[i - 1].y) / 2;
            ctx.quadraticCurveTo(bottomEdge[i].x, bottomEdge[i].y, cx, cy);
        } else {
            ctx.lineTo(bottomEdge[i].x, bottomEdge[i].y);
        }
    }
    ctx.closePath();

    // Get equipped blade colors
    const blade = getEquippedBlade();
    let glowColor = blade.glow;
    let fillColor = blade.fill;
    let midColor = blade.mid;
    let coreColor = blade.core;

    // Rainbow blade cycles colors
    if (blade.special === 'rainbow') {
        const hue = (performance.now() * 0.15) % 360;
        glowColor = `hsla(${hue}, 100%, 60%, 0.7)`;
        fillColor = `hsla(${hue}, 100%, 70%, 0.3)`;
        midColor = `hsla(${(hue + 60) % 360}, 100%, 75%, 0.55)`;
        coreColor = `hsla(${(hue + 120) % 360}, 100%, 90%, 0.9)`;
    }

    // Glow fill
    ctx.shadowColor = glowColor;
    ctx.shadowBlur = 22;
    ctx.fillStyle = fillColor;
    ctx.fill();
    ctx.shadowBlur = 0;

    // Mid layer
    ctx.fillStyle = midColor;
    ctx.fill();

    // Bright core line (along center)
    ctx.beginPath();
    ctx.moveTo(recent[0].x, recent[0].y);
    for (let i = 1; i < recent.length; i++) {
        if (i < recent.length - 1) {
            const cx = (recent[i].x + recent[i + 1].x) / 2;
            const cy = (recent[i].y + recent[i + 1].y) / 2;
            ctx.quadraticCurveTo(recent[i].x, recent[i].y, cx, cy);
        } else {
            ctx.lineTo(recent[i].x, recent[i].y);
        }
    }
    ctx.strokeStyle = coreColor;
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.stroke();

    // Special blade particle effects along trail
    if (blade.special && recent.length >= 2) {
        const head = recent[recent.length - 1];
        if (blade.special === 'sakura') {
            // Pink petal particles
            for (let i = 0; i < 2; i++) {
                const px = head.x + (Math.random() - 0.5) * 20;
                const py = head.y + (Math.random() - 0.5) * 20;
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(Math.random() * Math.PI * 2);
                ctx.globalAlpha = 0.5 + Math.random() * 0.3;
                ctx.fillStyle = Math.random() > 0.5 ? '#ffb0c8' : '#ff88aa';
                ctx.beginPath();
                ctx.ellipse(0, 0, 3, 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        } else if (blade.special === 'galaxy') {
            // Star sparkles
            for (let i = 0; i < 2; i++) {
                const px = head.x + (Math.random() - 0.5) * 24;
                const py = head.y + (Math.random() - 0.5) * 24;
                const sr = 1 + Math.random() * 2;
                ctx.save();
                ctx.globalAlpha = 0.6 + Math.random() * 0.4;
                ctx.fillStyle = Math.random() > 0.5 ? '#ffffff' : '#c090ff';
                ctx.beginPath();
                // 4-point star
                for (let j = 0; j < 8; j++) {
                    const a = j * Math.PI / 4;
                    const r2 = j % 2 === 0 ? sr : sr * 0.3;
                    ctx[j === 0 ? 'moveTo' : 'lineTo'](px + Math.cos(a) * r2, py + Math.sin(a) * r2);
                }
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        } else if (blade.special === 'dragon') {
            // Ember particles
            for (let i = 0; i < 3; i++) {
                const px = head.x + (Math.random() - 0.5) * 22;
                const py = head.y + (Math.random() - 0.5) * 22;
                const er = 1 + Math.random() * 3;
                const eg = ctx.createRadialGradient(px, py, 0, px, py, er);
                eg.addColorStop(0, 'rgba(255,200,50,0.8)');
                eg.addColorStop(0.5, 'rgba(255,80,0,0.5)');
                eg.addColorStop(1, 'rgba(255,30,0,0)');
                ctx.beginPath();
                ctx.arc(px, py, er, 0, Math.PI * 2);
                ctx.fillStyle = eg;
                ctx.fill();
            }
        } else if (blade.special === 'crystal') {
            // Prismatic sparkles
            for (let i = 0; i < 2; i++) {
                const px = head.x + (Math.random() - 0.5) * 20;
                const py = head.y + (Math.random() - 0.5) * 20;
                const hue2 = (performance.now() * 0.3 + i * 120) % 360;
                ctx.save();
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = `hsl(${hue2}, 80%, 85%)`;
                ctx.beginPath();
                // Diamond shape
                const ds = 2 + Math.random() * 2;
                ctx.moveTo(px, py - ds);
                ctx.lineTo(px + ds * 0.6, py);
                ctx.lineTo(px, py + ds);
                ctx.lineTo(px - ds * 0.6, py);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                ctx.restore();
            }
        }
    }

    ctx.restore();
}

function drawBladeSparkles() {
    const blade = getEquippedBlade();
    const sparkBase = blade.sparkle || 'rgba(180,220,255,';
    for (const s of bladeSparkles) {
        const alpha = Math.max(0, s.life / s.maxLife);
        const sg = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.radius * 2);
        sg.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
        sg.addColorStop(0.4, sparkBase + `${alpha * 0.5})`);
        sg.addColorStop(1, sparkBase + '0)');
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.radius * 2, 0, Math.PI * 2);
        ctx.fillStyle = sg;
        ctx.fill();
    }
}

// ===========================================
//  DRAWING — PARTICLES (enhanced with gradients & motion blur)
// ===========================================
function drawParticles() {
    for (const p of particles) {
        const alpha = Math.max(0, p.life / (p.maxLife || 1));
        ctx.globalAlpha = alpha;

        // Motion blur: elongate in direction of travel
        const speed = Math.hypot(p.vx, p.vy);
        if (speed > 50) {
            ctx.save();
            ctx.translate(p.x, p.y);
            const angle = Math.atan2(p.vy, p.vx);
            ctx.rotate(angle);
            const stretch = Math.min(3, speed / 150);
            // Radial gradient particle
            const pg = ctx.createRadialGradient(0, 0, 0, 0, 0, p.radius * (1 + stretch));
            pg.addColorStop(0, p.color);
            pg.addColorStop(0.5, p.color);
            pg.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.beginPath();
            ctx.ellipse(0, 0, p.radius * (1 + stretch), p.radius, 0, 0, Math.PI * 2);
            ctx.fillStyle = pg;
            ctx.fill();
            ctx.restore();
        } else {
            // Soft glow particle
            const pg = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.radius * 1.5);
            pg.addColorStop(0, p.color);
            pg.addColorStop(0.6, p.color);
            pg.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * 1.5, 0, Math.PI * 2);
            ctx.fillStyle = pg;
            ctx.fill();
        }
    }
    ctx.globalAlpha = 1;
}

// ===========================================
//  DRAWING — SHOCKWAVES
// ===========================================
function drawShockwaves() {
    for (const sw of shockwaves) {
        const alpha = Math.max(0, sw.life / sw.maxLife) * 0.6;
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 4 * (sw.life / sw.maxLife);
        ctx.stroke();
        // Inner ring
        ctx.beginPath();
        ctx.arc(sw.x, sw.y, sw.radius * 0.7, 0, Math.PI * 2);
        ctx.strokeStyle = '#ffaa00';
        ctx.lineWidth = 2 * (sw.life / sw.maxLife);
        ctx.stroke();
    }
    ctx.globalAlpha = 1;
}

// ===========================================
//  DRAWING — SLICE LINES (cut flash visual)
// ===========================================
function drawSliceLines() {
    for (const sl of sliceLines) {
        const t = sl.life / sl.maxLife;
        ctx.save();
        // Outer glow
        ctx.globalAlpha = t * 0.6;
        ctx.strokeStyle = sl.color;
        ctx.lineWidth = 14 * t;
        ctx.lineCap = 'round';
        ctx.shadowColor = sl.color;
        ctx.shadowBlur = 25 * t;
        ctx.beginPath();
        ctx.moveTo(sl.x1, sl.y1);
        ctx.lineTo(sl.x2, sl.y2);
        ctx.stroke();
        // Bright white core
        ctx.globalAlpha = t * 0.9;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3 * t;
        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 12 * t;
        ctx.beginPath();
        ctx.moveTo(sl.x1, sl.y1);
        ctx.lineTo(sl.x2, sl.y2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

// ===========================================
//  DRAWING — POPUPS (enhanced)
// ===========================================
function drawPopups() {
    const nightGlow = getEquippedBg().mechanic === 'glow_fruits';
    for (const p of popups) {
        const alpha = Math.max(0, Math.min(1, p.life));
        ctx.globalAlpha = alpha;

        let scale = p.scale || 1;
        // Night background: score popups are 1.5x larger
        if (nightGlow) scale *= 1.5;
        ctx.save();
        ctx.translate(p.x, p.y);
        if (scale !== 1) ctx.scale(scale, scale);

        ctx.font = `bold ${p.size}px "Segoe UI", sans-serif`;
        ctx.textAlign = 'center';
        // Text outline for readability
        ctx.strokeStyle = 'rgba(0,0,0,0.7)';
        ctx.lineWidth = 4;
        ctx.lineJoin = 'round';
        ctx.strokeText(p.text, 0, 0);
        ctx.fillStyle = p.color;
        ctx.fillText(p.text, 0, 0);

        ctx.restore();
    }
    ctx.globalAlpha = 1;
}

// ===========================================
//  DRAWING — HUD (enhanced with outlines, fruit icons)
// ===========================================
function drawHUD() {
    // Score - larger with outline
    ctx.font = 'bold 38px "Segoe UI", sans-serif';
    ctx.textAlign = 'left';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 5;
    ctx.lineJoin = 'round';
    ctx.strokeText('Score: ' + score, 20, 44);
    ctx.fillStyle = '#fff';
    ctx.fillText('Score: ' + score, 20, 44);

    // Best score
    ctx.textAlign = 'right';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.strokeText('Best: ' + bestScore, W - 20, 44);
    ctx.fillStyle = '#ffdd44';
    ctx.fillText('Best: ' + bestScore, W - 20, 44);

    // Coins earned this game
    ctx.font = 'bold 22px "Segoe UI", sans-serif';
    ctx.textAlign = 'right';
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 3;
    ctx.strokeText('Coins: +' + coinsEarnedThisGame, W - 20, 72);
    ctx.fillStyle = '#ffd700';
    ctx.fillText('Coins: +' + coinsEarnedThisGame, W - 20, 72);

    // Draw coin popups
    for (const cp of coinPopups) {
        const alpha = Math.max(0, Math.min(1, cp.life * 2));
        ctx.globalAlpha = alpha;
        ctx.font = 'bold 16px "Segoe UI", sans-serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 2;
        ctx.strokeText(cp.text, cp.x, cp.y);
        ctx.fillStyle = '#ffd700';
        ctx.fillText(cp.text, cp.x, cp.y);
    }
    ctx.globalAlpha = 1;

    // Lives as mini apple icons
    const lifeSpacing = 44;
    const lifeStartX = W / 2 - (MAX_LIVES - 1) * lifeSpacing / 2;
    for (let i = 0; i < MAX_LIVES; i++) {
        const lx = lifeStartX + i * lifeSpacing;
        const ly = 32;
        const lr = 12;

        ctx.save();
        ctx.translate(lx, ly);

        if (i < lives) {
            // Mini apple (active life)
            const ag = ctx.createRadialGradient(-lr * 0.2, -lr * 0.2, 0, 0, 0, lr);
            ag.addColorStop(0, '#ee3333');
            ag.addColorStop(0.7, '#cc1111');
            ag.addColorStop(1, '#880000');
            ctx.beginPath();
            ctx.arc(0, 0, lr, 0, Math.PI * 2);
            ctx.fillStyle = ag;
            ctx.fill();
            // Tiny specular
            const ah = ctx.createRadialGradient(-lr * 0.3, -lr * 0.3, 0, -lr * 0.3, -lr * 0.3, lr * 0.4);
            ah.addColorStop(0, 'rgba(255,255,255,0.5)');
            ah.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.beginPath();
            ctx.arc(0, 0, lr, 0, Math.PI * 2);
            ctx.fillStyle = ah;
            ctx.fill();
            // Mini stem
            ctx.fillStyle = '#5a3a1a';
            ctx.fillRect(-1, -lr - 3, 2, 5);
            // Mini leaf
            ctx.beginPath();
            ctx.ellipse(3, -lr - 1, 4, 2, 0.3, 0, Math.PI * 2);
            ctx.fillStyle = '#3a9a2a';
            ctx.fill();
        } else {
            // Lost life - faded apple with red X
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, lr, 0, Math.PI * 2);
            ctx.fillStyle = '#662222';
            ctx.fill();
            ctx.globalAlpha = 0.7;
            // Red X
            ctx.strokeStyle = '#ff2222';
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(-lr * 0.6, -lr * 0.6);
            ctx.lineTo(lr * 0.6, lr * 0.6);
            ctx.moveTo(lr * 0.6, -lr * 0.6);
            ctx.lineTo(-lr * 0.6, lr * 0.6);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        ctx.restore();
    }

    // Mode indicator (bottom-left, only for Sword/Archery)
    if (currentMode === 'sword' || currentMode === 'archery') {
        const label = currentMode === 'sword' ? 'SWORD MODE' : 'ARCHERY MODE';
        const color = currentMode === 'sword' ? '#ff8800' : '#44bb44';
        ctx.font = 'bold 20px "Segoe UI", sans-serif';
        ctx.textAlign = 'left';
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.lineWidth = 3;
        ctx.lineJoin = 'round';
        ctx.strokeText(label, 20, H - 20);
        ctx.fillStyle = color;
        ctx.fillText(label, 20, H - 20);
    }

    // Active effect indicators (bottom-right)
    let indicatorY = H - 24;
    ctx.textAlign = 'right';
    ctx.font = 'bold 22px "Segoe UI", sans-serif';
    ctx.lineWidth = 3;
    ctx.lineJoin = 'round';

    if (hourglassActive) {
        const text = 'SLOW: ' + Math.ceil(hourglassTimer) + 's';
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.strokeText(text, W - 20, indicatorY);
        ctx.fillStyle = '#88bbff';
        ctx.fillText(text, W - 20, indicatorY);
        indicatorY -= 30;
    }

    if (shieldActive) {
        const pulse = 0.7 + 0.3 * Math.sin(performance.now() * 0.006);
        const text = 'SHIELD ACTIVE';
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.strokeText(text, W - 20, indicatorY);
        ctx.fillStyle = `rgba(136,204,255,${pulse})`;
        ctx.fillText(text, W - 20, indicatorY);
        // Pulsing border around text
        const tw = ctx.measureText(text).width;
        ctx.strokeStyle = `rgba(136,204,255,${pulse * 0.6})`;
        ctx.lineWidth = 2;
        ctx.strokeRect(W - 24 - tw, indicatorY - 18, tw + 8, 24);
        indicatorY -= 30;
    }

    // Restart button (bottom-center)
    const rbtnX = W / 2;
    const rbtnY = H - 30;
    ctx.font = 'bold 18px "Segoe UI", sans-serif';
    ctx.textAlign = 'center';
    const rbtnW = 100, rbtnH = 32;
    ctx.fillStyle = 'rgba(0,0,0,0.4)';
    ctx.beginPath();
    ctx.roundRect(rbtnX - rbtnW/2, rbtnY - rbtnH/2, rbtnW, rbtnH, 8);
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.fillText('RESTART', rbtnX, rbtnY + 6);
}

// ===========================================
//  DRAWING — START SCREEN (with floating fruits)
// ===========================================
function drawStartScreen() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
    ctx.fillRect(0, 0, W, H);

    // Draw decorative floating fruits
    ctx.globalAlpha = 0.3;
    for (const f of startScreenFruits) {
        ctx.save();
        ctx.translate(f.x, f.y);
        ctx.rotate(f.rotation);
        switch (f.name) {
            case 'watermelon': drawWatermelon(f.radius); break;
            case 'orange': drawOrange(f.radius); break;
            case 'apple': drawApple(f.radius); break;
            case 'banana': drawBanana(f.radius); break;
            case 'strawberry': drawStrawberry(f.radius); break;
            case 'kiwi': drawKiwi(f.radius); break;
        }
        ctx.restore();
    }
    ctx.globalAlpha = 1;

    ctx.textAlign = 'center';

    // Title with thick outline
    ctx.font = 'bold 64px "Segoe UI", sans-serif';
    ctx.strokeStyle = 'rgba(0,0,0,0.8)';
    ctx.lineWidth = 8;
    ctx.lineJoin = 'round';
    ctx.strokeText('FRUIT NINJA', W / 2, H * 0.32);
    // Red fill with gradient
    const tg = ctx.createLinearGradient(W / 2 - 200, H * 0.28, W / 2 + 200, H * 0.34);
    tg.addColorStop(0, '#ff4444');
    tg.addColorStop(0.5, '#ff6666');
    tg.addColorStop(1, '#ff3333');
    ctx.fillStyle = tg;
    ctx.fillText('FRUIT NINJA', W / 2, H * 0.32);

    const modes = getAvailableModes();
    const hasSelector = modes.length > 1;

    if (hasSelector) {
        // Mode selector
        const modeY = H * 0.44;
        const modeNames = { blade: 'BLADE', sword: 'SWORD', archery: 'ARCHERY' };
        const modeColors = { blade: '#ff4444', sword: '#ff8800', archery: '#44bb44' };
        const modeDescs = { blade: 'Swipe to slice', sword: 'Tap to slice', archery: 'Click to shoot' };
        const spacing = 120;
        const totalW = (modes.length - 1) * spacing;
        const startX = W / 2 - totalW / 2;

        for (let i = 0; i < modes.length; i++) {
            const mx = startX + i * spacing;
            const mode = modes[i];
            const selected = i === selectedModeIndex;

            ctx.font = `bold ${selected ? 26 : 20}px "Segoe UI", sans-serif`;
            ctx.strokeStyle = 'rgba(0,0,0,0.6)';
            ctx.lineWidth = selected ? 4 : 3;
            ctx.lineJoin = 'round';
            ctx.strokeText(modeNames[mode], mx, modeY);
            ctx.fillStyle = selected ? modeColors[mode] : 'rgba(180,180,180,0.5)';
            ctx.fillText(modeNames[mode], mx, modeY);

            // Underline selected
            if (selected) {
                const tw = ctx.measureText(modeNames[mode]).width;
                ctx.fillStyle = modeColors[mode];
                ctx.fillRect(mx - tw / 2, modeY + 4, tw, 3);
            }
        }

        // Description of selected mode
        const selMode = modes[selectedModeIndex];
        ctx.font = '18px "Segoe UI", sans-serif';
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 3;
        ctx.strokeText(modeDescs[selMode], W / 2, modeY + 30);
        ctx.fillStyle = '#ccc';
        ctx.fillText(modeDescs[selMode], W / 2, modeY + 30);

        // Instruction
        ctx.font = '16px "Segoe UI", sans-serif';
        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
        ctx.lineWidth = 2;
        ctx.strokeText('Tap Mode to Switch', W / 2, modeY + 55);
        ctx.fillStyle = 'rgba(200,200,200,0.7)';
        ctx.fillText('Tap Mode to Switch', W / 2, modeY + 55);

        // Best score
        if (bestScore > 0) {
            ctx.font = '22px "Segoe UI", sans-serif';
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 3;
            ctx.strokeText('Best Score: ' + bestScore, W / 2, H * 0.62);
            ctx.fillStyle = '#ccc';
            ctx.fillText('Best Score: ' + bestScore, W / 2, H * 0.62);
        }

        // Start prompt (pulsing)
        ctx.font = '20px "Segoe UI", sans-serif';
        const pulse = 0.5 + 0.5 * Math.sin(performance.now() * 0.004);
        ctx.strokeStyle = `rgba(0, 0, 0, ${0.3 + pulse * 0.3})`;
        ctx.lineWidth = 3;
        ctx.strokeText('Tap Here to Start', W / 2, H * 0.72);
        ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + pulse * 0.6})`;
        ctx.fillText('Tap Here to Start', W / 2, H * 0.72);
    } else {
        // No modes unlocked — original layout
        ctx.font = 'bold 28px "Segoe UI", sans-serif';
        ctx.strokeStyle = 'rgba(0,0,0,0.6)';
        ctx.lineWidth = 4;
        ctx.strokeText('Swipe to Slice!', W / 2, H * 0.42);
        ctx.fillStyle = '#ffdd44';
        ctx.fillText('Swipe to Slice!', W / 2, H * 0.42);

        // Best score
        if (bestScore > 0) {
            ctx.font = '22px "Segoe UI", sans-serif';
            ctx.strokeStyle = 'rgba(0,0,0,0.5)';
            ctx.lineWidth = 3;
            ctx.strokeText('Best Score: ' + bestScore, W / 2, H * 0.52);
            ctx.fillStyle = '#ccc';
            ctx.fillText('Best Score: ' + bestScore, W / 2, H * 0.52);
        }

        // Start prompt (pulsing)
        ctx.font = '20px "Segoe UI", sans-serif';
        const pulse = 0.5 + 0.5 * Math.sin(performance.now() * 0.004);
        ctx.strokeStyle = `rgba(0, 0, 0, ${0.3 + pulse * 0.3})`;
        ctx.lineWidth = 3;
        ctx.strokeText('Tap or Click to Start', W / 2, H * 0.65);
        ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + pulse * 0.6})`;
        ctx.fillText('Tap or Click to Start', W / 2, H * 0.65);
    }

    // === SHOP BUTTON (always visible on start screen) ===
    const shopBtnY = H * 0.82;
    const shopBtnW = 160;
    const shopBtnH = 48;
    // Button background
    const sbGrad = ctx.createLinearGradient(W / 2 - shopBtnW / 2, shopBtnY - shopBtnH / 2, W / 2 + shopBtnW / 2, shopBtnY + shopBtnH / 2);
    sbGrad.addColorStop(0, 'rgba(120, 80, 20, 0.9)');
    sbGrad.addColorStop(0.5, 'rgba(160, 110, 30, 0.95)');
    sbGrad.addColorStop(1, 'rgba(120, 80, 20, 0.9)');
    ctx.fillStyle = sbGrad;
    // Rounded rect for button
    const bx = W / 2 - shopBtnW / 2;
    const by = shopBtnY - shopBtnH / 2;
    const br = 12;
    ctx.beginPath();
    ctx.moveTo(bx + br, by);
    ctx.lineTo(bx + shopBtnW - br, by);
    ctx.quadraticCurveTo(bx + shopBtnW, by, bx + shopBtnW, by + br);
    ctx.lineTo(bx + shopBtnW, by + shopBtnH - br);
    ctx.quadraticCurveTo(bx + shopBtnW, by + shopBtnH, bx + shopBtnW - br, by + shopBtnH);
    ctx.lineTo(bx + br, by + shopBtnH);
    ctx.quadraticCurveTo(bx, by + shopBtnH, bx, by + shopBtnH - br);
    ctx.lineTo(bx, by + br);
    ctx.quadraticCurveTo(bx, by, bx + br, by);
    ctx.closePath();
    ctx.fill();
    // Gold border
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Button text
    ctx.textAlign = 'center';
    ctx.font = 'bold 24px "Segoe UI", sans-serif';
    ctx.fillStyle = '#ffd700';
    ctx.fillText('SHOP', W / 2, shopBtnY + 8);

    // Coin display below shop button
    ctx.font = '18px "Segoe UI", sans-serif';
    ctx.fillStyle = '#ffd700';
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.strokeText('Coins: ' + shopData.coins, W / 2, shopBtnY + 36);
    ctx.fillText('Coins: ' + shopData.coins, W / 2, shopBtnY + 36);
}

// ===========================================
//  DRAWING — SHOP SCREEN
// ===========================================
function drawShopItemIcon(item, x, y, size) {
    ctx.save();
    ctx.translate(x, y);
    const s = size / 40; // scale factor

    if (item.id.startsWith('blade_')) {
        // Draw a small blade/sword icon with the blade's color
        const blade = BLADE_ITEMS.find(b => b.id === item.id);
        if (blade) {
            // Blade line
            ctx.strokeStyle = blade.core;
            ctx.lineWidth = 3 * s;
            ctx.lineCap = 'round';
            ctx.shadowColor = blade.glow;
            ctx.shadowBlur = 8 * s;
            ctx.beginPath();
            ctx.moveTo(-12 * s, 12 * s);
            ctx.lineTo(12 * s, -12 * s);
            ctx.stroke();
            // Glow
            ctx.strokeStyle = blade.fill;
            ctx.lineWidth = 8 * s;
            ctx.beginPath();
            ctx.moveTo(-12 * s, 12 * s);
            ctx.lineTo(12 * s, -12 * s);
            ctx.stroke();
            ctx.shadowBlur = 0;
            // Handle
            ctx.fillStyle = '#8a6a40';
            ctx.fillRect(-14 * s, 10 * s, 6 * s, 8 * s);
        }
    } else if (item.id.startsWith('bg_')) {
        // Draw a small landscape icon with the bg tint
        const bg = BG_ITEMS.find(b => b.id === item.id);
        // Frame
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 2 * s;
        ctx.strokeRect(-14 * s, -10 * s, 28 * s, 20 * s);
        // Sky
        ctx.fillStyle = bg && bg.tint ? bg.tint : '#87CEEB';
        ctx.globalAlpha = bg && bg.tint ? 0.7 : 0.4;
        ctx.fillRect(-13 * s, -9 * s, 26 * s, 12 * s);
        ctx.globalAlpha = 1;
        // Ground
        ctx.fillStyle = '#5a8a3a';
        ctx.fillRect(-13 * s, 3 * s, 26 * s, 6 * s);
        if (bg && bg.id === 'bg_space') {
            // Stars
            ctx.fillStyle = '#fff';
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.arc((-10 + i * 5) * s, (-6 + (i % 3) * 3) * s, 1 * s, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    } else if (item.id.startsWith('pow_')) {
        // Draw power-specific icons
        const id = item.id;
        if (id === 'pow_extralife') {
            // Heart
            ctx.fillStyle = '#ff4466';
            ctx.beginPath();
            ctx.arc(-4 * s, -4 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(4 * s, -4 * s, 6 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-10 * s, -1 * s);
            ctx.lineTo(0, 12 * s);
            ctx.lineTo(10 * s, -1 * s);
            ctx.fill();
        } else if (id === 'pow_headstart') {
            // Arrow up
            ctx.fillStyle = '#44dd44';
            ctx.beginPath();
            ctx.moveTo(0, -12 * s);
            ctx.lineTo(10 * s, 0);
            ctx.lineTo(4 * s, 0);
            ctx.lineTo(4 * s, 12 * s);
            ctx.lineTo(-4 * s, 12 * s);
            ctx.lineTo(-4 * s, 0);
            ctx.lineTo(-10 * s, 0);
            ctx.closePath();
            ctx.fill();
        } else if (id === 'pow_magnet') {
            // Magnet shape
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 4 * s;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, -2 * s, 8 * s, Math.PI, 0);
            ctx.stroke();
            ctx.strokeStyle = '#cc0000';
            ctx.beginPath();
            ctx.moveTo(-8 * s, -2 * s);
            ctx.lineTo(-8 * s, 10 * s);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(8 * s, -2 * s);
            ctx.lineTo(8 * s, 10 * s);
            ctx.stroke();
        } else if (id === 'pow_lucky') {
            // Star
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            for (let i = 0; i < 10; i++) {
                const a = -Math.PI / 2 + i * Math.PI / 5;
                const r = i % 2 === 0 ? 12 * s : 5 * s;
                ctx[i === 0 ? 'moveTo' : 'lineTo'](Math.cos(a) * r, Math.sin(a) * r);
            }
            ctx.closePath();
            ctx.fill();
        } else if (id === 'pow_slow') {
            // Clock
            ctx.strokeStyle = '#4488ff';
            ctx.lineWidth = 2 * s;
            ctx.beginPath();
            ctx.arc(0, 0, 10 * s, 0, Math.PI * 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -7 * s);
            ctx.moveTo(0, 0);
            ctx.lineTo(5 * s, 2 * s);
            ctx.stroke();
        } else if (id === 'pow_thick') {
            // Wide blade
            ctx.fillStyle = 'rgba(200,230,255,0.7)';
            ctx.fillRect(-3 * s, -12 * s, 6 * s, 24 * s);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2 * s;
            ctx.strokeRect(-3 * s, -12 * s, 6 * s, 24 * s);
        } else if (id === 'pow_combo') {
            // Lightning bolt
            ctx.fillStyle = '#ffdd44';
            ctx.beginPath();
            ctx.moveTo(2 * s, -12 * s);
            ctx.lineTo(-6 * s, 2 * s);
            ctx.lineTo(0, 2 * s);
            ctx.lineTo(-2 * s, 12 * s);
            ctx.lineTo(6 * s, -2 * s);
            ctx.lineTo(0, -2 * s);
            ctx.closePath();
            ctx.fill();
        } else if (id === 'pow_shield') {
            // Shield
            ctx.fillStyle = '#4488ff';
            ctx.beginPath();
            ctx.moveTo(0, -10 * s);
            ctx.quadraticCurveTo(12 * s, -6 * s, 10 * s, 2 * s);
            ctx.quadraticCurveTo(6 * s, 10 * s, 0, 12 * s);
            ctx.quadraticCurveTo(-6 * s, 10 * s, -10 * s, 2 * s);
            ctx.quadraticCurveTo(-12 * s, -6 * s, 0, -10 * s);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            ctx.fillRect(-2 * s, -6 * s, 4 * s, 12 * s);
            ctx.fillRect(-6 * s, -2 * s, 12 * s, 4 * s);
        }
    } else if (item.id.startsWith('ext_')) {
        // Extras icons
        const id = item.id;
        if (id === 'ext_double') {
            // x2
            ctx.font = `bold ${16 * s}px "Segoe UI", sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffd700';
            ctx.fillText('x2', 0, 0);
        } else if (id === 'ext_defuser') {
            // Bomb with X
            ctx.fillStyle = '#333';
            ctx.beginPath();
            ctx.arc(0, 2 * s, 8 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ff3333';
            ctx.lineWidth = 3 * s;
            ctx.beginPath();
            ctx.moveTo(-10 * s, -10 * s);
            ctx.lineTo(10 * s, 10 * s);
            ctx.moveTo(10 * s, -10 * s);
            ctx.lineTo(-10 * s, 10 * s);
            ctx.stroke();
        } else if (id === 'ext_frenzy') {
            // Multiple fruits
            ctx.fillStyle = '#ff3333';
            ctx.beginPath(); ctx.arc(-5 * s, -3 * s, 5 * s, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#e87800';
            ctx.beginPath(); ctx.arc(5 * s, -3 * s, 4 * s, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#44bb44';
            ctx.beginPath(); ctx.arc(0, 5 * s, 4.5 * s, 0, Math.PI * 2); ctx.fill();
        } else if (id === 'ext_diamond') {
            // Diamond
            ctx.fillStyle = '#88ddff';
            ctx.beginPath();
            ctx.moveTo(0, -10 * s);
            ctx.lineTo(7 * s, 0);
            ctx.lineTo(0, 10 * s);
            ctx.lineTo(-7 * s, 0);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1 * s;
            ctx.stroke();
        } else if (id === 'ext_revive') {
            // Revive heart with plus
            ctx.fillStyle = '#ff4466';
            ctx.beginPath();
            ctx.arc(-3 * s, -3 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(3 * s, -3 * s, 5 * s, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(-8 * s, -1 * s);
            ctx.lineTo(0, 10 * s);
            ctx.lineTo(8 * s, -1 * s);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillRect(-1.5 * s, -6 * s, 3 * s, 8 * s);
            ctx.fillRect(-4 * s, -3.5 * s, 8 * s, 3 * s);
        } else if (id === 'ext_streak') {
            // Fire streak
            ctx.fillStyle = '#ff8800';
            ctx.beginPath();
            ctx.moveTo(0, -12 * s);
            ctx.quadraticCurveTo(8 * s, -4 * s, 4 * s, 4 * s);
            ctx.quadraticCurveTo(6 * s, 8 * s, 0, 12 * s);
            ctx.quadraticCurveTo(-6 * s, 8 * s, -4 * s, 4 * s);
            ctx.quadraticCurveTo(-8 * s, -4 * s, 0, -12 * s);
            ctx.fill();
            ctx.fillStyle = '#ffdd44';
            ctx.beginPath();
            ctx.moveTo(0, -4 * s);
            ctx.quadraticCurveTo(3 * s, 0, 2 * s, 4 * s);
            ctx.quadraticCurveTo(0, 8 * s, -2 * s, 4 * s);
            ctx.quadraticCurveTo(-3 * s, 0, 0, -4 * s);
            ctx.fill();
        }
    }

    ctx.restore();
}

function drawShop() {
    // Dark overlay
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, W, H);

    // Shop title bar
    ctx.fillStyle = 'rgba(40, 20, 10, 0.95)';
    ctx.fillRect(0, 0, W, 50);

    // Back button
    ctx.font = 'bold 24px "Segoe UI", sans-serif';
    ctx.textAlign = 'left';
    ctx.fillStyle = '#ff6644';
    ctx.fillText('< BACK', 15, 34);

    // Title
    ctx.textAlign = 'center';
    ctx.font = 'bold 28px "Segoe UI", sans-serif';
    ctx.fillStyle = '#ffd700';
    ctx.fillText('SHOP', W / 2, 36);

    // Coin display
    ctx.textAlign = 'right';
    ctx.font = 'bold 22px "Segoe UI", sans-serif';
    ctx.fillStyle = '#ffd700';
    ctx.fillText('Coins: ' + shopData.coins, W - 15, 34);

    // Category tabs
    const tabY = 55;
    const tabH = 40;
    const tabW = W / SHOP_CATEGORIES.length;
    for (let i = 0; i < SHOP_CATEGORIES.length; i++) {
        const cat = SHOP_CATEGORIES[i];
        const isActive = i === shopCategory;
        // Tab background
        ctx.fillStyle = isActive ? 'rgba(80, 50, 20, 0.9)' : 'rgba(30, 15, 5, 0.8)';
        ctx.fillRect(i * tabW, tabY, tabW, tabH);
        // Tab text
        ctx.textAlign = 'center';
        ctx.font = `bold ${isActive ? 18 : 15}px "Segoe UI", sans-serif`;
        ctx.fillStyle = isActive ? '#ffd700' : '#999';
        ctx.fillText(cat.label, i * tabW + tabW / 2, tabY + tabH / 2 + 6);
        // Active tab underline
        if (isActive) {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(i * tabW + 10, tabY + tabH - 3, tabW - 20, 3);
        }
        // Tab separator
        if (i > 0) {
            ctx.fillStyle = 'rgba(100,80,50,0.3)';
            ctx.fillRect(i * tabW, tabY + 5, 1, tabH - 10);
        }
    }

    // Item grid
    const gridTop = 110;
    const cat = SHOP_CATEGORIES[shopCategory];
    const items = cat.items;
    const cols = Math.max(2, Math.min(4, Math.floor(W / 140)));
    const cardW = (W - 20) / cols - 10;
    const hasGameplayDesc = (cat.key === 'blades' || cat.key === 'backgrounds');
    const cardH = hasGameplayDesc ? 150 : 130;

    // Clip to grid area
    ctx.save();
    ctx.beginPath();
    ctx.rect(0, gridTop - 5, W, H - gridTop + 5);
    ctx.clip();

    // Smooth scroll
    if (!shopDragging) {
        shopScrollY += (shopScrollTarget - shopScrollY) * 0.15;
        // Inertia
        shopScrollTarget += shopScrollVelocity * 0.5;
        shopScrollVelocity *= 0.92;
        if (Math.abs(shopScrollVelocity) < 0.5) shopScrollVelocity = 0;
    }
    // Clamp scroll
    const totalRows = Math.ceil(items.length / cols);
    const maxScroll = Math.max(0, totalRows * (cardH + 10) - (H - gridTop) + 20);
    if (shopScrollY < 0) shopScrollY = 0;
    if (shopScrollY > maxScroll) shopScrollY = maxScroll;
    if (shopScrollTarget < 0) shopScrollTarget = 0;
    if (shopScrollTarget > maxScroll) shopScrollTarget = maxScroll;

    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const row = Math.floor(i / cols);
        const col = i % cols;
        const cx = 15 + col * (cardW + 10) + cardW / 2;
        const cy = gridTop + row * (cardH + 10) + cardH / 2 - shopScrollY;

        // Skip if off screen
        if (cy + cardH / 2 < gridTop - 10 || cy - cardH / 2 > H + 10) continue;

        const isOwned = shopData.owned.includes(item.id);
        let isEquipped = false;
        if (cat.key === 'blades') isEquipped = shopData.equipped.blade === item.id;
        else if (cat.key === 'backgrounds') isEquipped = shopData.equipped.background === item.id;
        else if (cat.key === 'powers') isEquipped = shopData.equipped.powers && shopData.equipped.powers.includes(item.id);
        else if (cat.key === 'extras') isEquipped = isOwned;

        // Card background
        let borderColor = '#555'; // locked
        if (isEquipped) borderColor = '#ffd700'; // equipped = gold
        else if (isOwned) borderColor = '#44bb44'; // owned = green

        // Card bg
        ctx.fillStyle = 'rgba(50, 35, 20, 0.9)';
        const cardLeft = cx - cardW / 2;
        const cardTop = cy - cardH / 2;

        // Rounded rect
        const rr = 8;
        ctx.beginPath();
        ctx.moveTo(cardLeft + rr, cardTop);
        ctx.lineTo(cardLeft + cardW - rr, cardTop);
        ctx.quadraticCurveTo(cardLeft + cardW, cardTop, cardLeft + cardW, cardTop + rr);
        ctx.lineTo(cardLeft + cardW, cardTop + cardH - rr);
        ctx.quadraticCurveTo(cardLeft + cardW, cardTop + cardH, cardLeft + cardW - rr, cardTop + cardH);
        ctx.lineTo(cardLeft + rr, cardTop + cardH);
        ctx.quadraticCurveTo(cardLeft, cardTop + cardH, cardLeft, cardTop + cardH - rr);
        ctx.lineTo(cardLeft, cardTop + rr);
        ctx.quadraticCurveTo(cardLeft, cardTop, cardLeft + rr, cardTop);
        ctx.closePath();
        ctx.fill();

        // Border
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = isEquipped ? 3 : 2;
        ctx.stroke();

        // Icon area
        drawShopItemIcon(item, cx, cy - 22, Math.min(cardW * 0.6, 50));

        // Item name
        ctx.textAlign = 'center';
        ctx.font = `bold ${Math.min(13, cardW * 0.11)}px "Segoe UI", sans-serif`;
        ctx.fillStyle = '#fff';
        ctx.fillText(item.name, cx, cy + 22);

        // Gameplay description for blades (bonusDesc) and backgrounds (mechanicDesc)
        const gameplayDesc = item.bonusDesc || item.mechanicDesc;
        if (gameplayDesc && gameplayDesc !== 'No bonus') {
            ctx.font = `${Math.min(9, cardW * 0.075)}px "Segoe UI", sans-serif`;
            ctx.fillStyle = '#88ccff';
            ctx.fillText(gameplayDesc, cx, cy + 35);
        } else if (gameplayDesc === 'No bonus') {
            ctx.font = `${Math.min(9, cardW * 0.075)}px "Segoe UI", sans-serif`;
            ctx.fillStyle = '#777';
            ctx.fillText(gameplayDesc, cx, cy + 35);
        }

        // Description for powers/extras
        if (item.desc) {
            ctx.font = `${Math.min(10, cardW * 0.08)}px "Segoe UI", sans-serif`;
            ctx.fillStyle = '#aaa';
            ctx.fillText(item.desc, cx, cy + 42);
        }

        // Price / Status label
        const statusY = hasGameplayDesc ? cy + 66 : cy + 56;
        if (isEquipped) {
            ctx.font = `bold ${Math.min(13, cardW * 0.1)}px "Segoe UI", sans-serif`;
            ctx.fillStyle = '#ffd700';
            if (cat.key === 'extras') {
                ctx.fillText('OWNED', cx, statusY);
            } else {
                ctx.fillText('EQUIPPED', cx, statusY);
            }
        } else if (isOwned) {
            ctx.font = `bold ${Math.min(13, cardW * 0.1)}px "Segoe UI", sans-serif`;
            if (cat.key === 'powers') {
                ctx.fillStyle = '#aaa';
                ctx.fillText('TAP TO EQUIP', cx, statusY);
            } else {
                ctx.fillStyle = '#44bb44';
                ctx.fillText('TAP TO EQUIP', cx, statusY);
            }
        } else {
            // Price
            ctx.font = `bold ${Math.min(14, cardW * 0.11)}px "Segoe UI", sans-serif`;
            const canAfford = shopData.coins >= item.price;
            ctx.fillStyle = canAfford ? '#ffd700' : '#ff4444';
            ctx.fillText(item.price === 0 ? 'FREE' : item.price + ' coins', cx, statusY);
        }
    }

    ctx.restore();

    // Scroll indicator
    if (maxScroll > 0) {
        const scrollBarH = Math.max(30, (H - gridTop) * (H - gridTop) / (totalRows * (cardH + 10)));
        const scrollBarY = gridTop + (shopScrollY / maxScroll) * (H - gridTop - scrollBarH);
        ctx.fillStyle = 'rgba(255,200,100,0.3)';
        ctx.fillRect(W - 6, scrollBarY, 4, scrollBarH);
    }
}

// ===========================================
//  DRAWING — GAME OVER (dramatic effects)
// ===========================================
function drawGameOver() {
    // Dark overlay with red tint
    ctx.fillStyle = 'rgba(40, 0, 0, 0.7)';
    ctx.fillRect(0, 0, W, H);

    // Cracked/shattered lines radiating from center
    ctx.save();
    ctx.strokeStyle = 'rgba(255, 50, 50, 0.25)';
    ctx.lineWidth = 2;
    const cx = W / 2, cy = H * 0.35;
    for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2 + 0.3;
        const len = 80 + Math.sin(i * 3.7) * 60;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        const mx = cx + Math.cos(angle) * len * 0.5;
        const my = cy + Math.sin(angle) * len * 0.5;
        ctx.lineTo(mx + Math.sin(i * 2.1) * 15, my + Math.cos(i * 1.8) * 15);
        ctx.lineTo(cx + Math.cos(angle) * len, cy + Math.sin(angle) * len);
        ctx.stroke();
        // Branch cracks
        const ba = angle + (Math.sin(i * 4.2) > 0 ? 0.4 : -0.4);
        ctx.beginPath();
        ctx.moveTo(mx, my);
        ctx.lineTo(mx + Math.cos(ba) * 30, my + Math.sin(ba) * 30);
        ctx.stroke();
    }
    ctx.restore();

    ctx.textAlign = 'center';

    // GAME OVER text
    ctx.font = 'bold 60px "Segoe UI", sans-serif';
    ctx.strokeStyle = 'rgba(0,0,0,0.8)';
    ctx.lineWidth = 8;
    ctx.lineJoin = 'round';
    ctx.strokeText('GAME OVER', W / 2, H * 0.30);
    ctx.fillStyle = '#ff3333';
    ctx.fillText('GAME OVER', W / 2, H * 0.30);

    // Score
    ctx.font = 'bold 40px "Segoe UI", sans-serif';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 5;
    ctx.strokeText('Score: ' + score, W / 2, H * 0.42);
    ctx.fillStyle = '#fff';
    ctx.fillText('Score: ' + score, W / 2, H * 0.42);

    if (score >= bestScore && score > 0) {
        ctx.font = 'bold 26px "Segoe UI", sans-serif';
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 4;
        ctx.strokeText('NEW BEST!', W / 2, H * 0.50);
        const pulse = 0.7 + 0.3 * Math.sin(performance.now() * 0.006);
        ctx.fillStyle = `rgba(255, 221, 68, ${pulse})`;
        ctx.fillText('NEW BEST!', W / 2, H * 0.50);
    } else {
        ctx.font = '22px "Segoe UI", sans-serif';
        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
        ctx.lineWidth = 3;
        ctx.strokeText('Best: ' + bestScore, W / 2, H * 0.50);
        ctx.fillStyle = '#ccc';
        ctx.fillText('Best: ' + bestScore, W / 2, H * 0.50);
    }

    // Coins earned
    ctx.font = 'bold 24px "Segoe UI", sans-serif';
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 4;
    ctx.strokeText('Coins Earned: +' + coinsEarnedThisGame, W / 2, H * 0.56);
    ctx.fillStyle = '#ffd700';
    ctx.fillText('Coins Earned: +' + coinsEarnedThisGame, W / 2, H * 0.56);

    // Unlock notification
    let retryY = H * 0.66;
    if (unlockMessage) {
        const unlockPulse = 0.7 + 0.3 * Math.sin(performance.now() * 0.005);
        ctx.font = 'bold 28px "Segoe UI", sans-serif';
        ctx.strokeStyle = 'rgba(0,0,0,0.7)';
        ctx.lineWidth = 5;
        ctx.lineJoin = 'round';
        ctx.strokeText(unlockMessage, W / 2, H * 0.62);
        ctx.fillStyle = `rgba(255, 200, 50, ${unlockPulse})`;
        ctx.fillText(unlockMessage, W / 2, H * 0.62);
        retryY = H * 0.72;
    }

    ctx.font = '20px "Segoe UI", sans-serif';
    const pulse = 0.5 + 0.5 * Math.sin(performance.now() * 0.004);
    ctx.strokeStyle = `rgba(0, 0, 0, ${0.3 + pulse * 0.3})`;
    ctx.lineWidth = 3;
    ctx.strokeText('Tap or Click to Retry', W / 2, retryY);
    ctx.fillStyle = `rgba(255, 255, 255, ${0.4 + pulse * 0.6})`;
    ctx.fillText('Tap or Click to Retry', W / 2, retryY);
}

// ===========================================
//  DRAWING — SCREEN FLASH
// ===========================================
function drawScreenFlash() {
    if (screenFlash > 0) {
        ctx.globalAlpha = Math.min(0.4, screenFlash);
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;
    }
}

// ===========================================
//  DRAWING — ARROWS
// ===========================================
function drawArrows() {
    for (const a of arrows) {
        ctx.save();
        ctx.translate(a.x, a.y);
        ctx.rotate(a.angle);
        // Shaft
        ctx.strokeStyle = '#6a4a2a';
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(-70, 0);
        ctx.lineTo(18, 0);
        ctx.stroke();
        // Arrowhead
        ctx.fillStyle = '#aaa';
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(32, 0);
        ctx.lineTo(16, -9);
        ctx.lineTo(18, 0);
        ctx.lineTo(16, 9);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        // Fletching
        ctx.fillStyle = '#cc3333';
        ctx.beginPath();
        ctx.moveTo(-70, 0);
        ctx.lineTo(-58, -9);
        ctx.lineTo(-52, 0);
        ctx.closePath();
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(-70, 0);
        ctx.lineTo(-58, 9);
        ctx.lineTo(-52, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
}

// ===========================================
//  DRAWING — CURSOR
// ===========================================
function drawCursor() {
    if (isPointerDown) {
        const cg = ctx.createRadialGradient(pointerPos.x, pointerPos.y, 0, pointerPos.x, pointerPos.y, 8);
        cg.addColorStop(0, 'rgba(255,255,255,0.7)');
        cg.addColorStop(0.5, 'rgba(200,230,255,0.3)');
        cg.addColorStop(1, 'rgba(150,200,255,0)');
        ctx.beginPath();
        ctx.arc(pointerPos.x, pointerPos.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = cg;
        ctx.fill();
    }
}

// ===========================================
//  MAIN LOOP
// ===========================================
let lastTime = 0;
let accumulator = 0;

function gameLoop(timestamp) {
    requestAnimationFrame(gameLoop);

    if (lastTime === 0) { lastTime = timestamp; return; }
    let frameDt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if (frameDt > 0.1) frameDt = 0.1;

    // Apply slow-motion time scale
    accumulator += frameDt * timeScale;
    while (accumulator >= FIXED_DT) {
        update(FIXED_DT);
        accumulator -= FIXED_DT;
    }

    // Draw
    ctx.clearRect(0, 0, W, H);

    // Apply screen shake
    const shaking = screenShake.timer > 0;
    if (shaking) {
        ctx.save();
        ctx.translate(screenShake.x, screenShake.y);
    }

    drawBackground();
    drawSplatters();
    drawDustMotes();

    if (state === 'playing') {
        drawBgMechanics();
        // Fruit shadows
        for (const f of fruits) if (!f.isBomb) drawFruitShadow(f);
        drawParticles();
        drawShockwaves();
        for (const h of halves) drawHalf(h);
        for (const f of fruits) drawFruit(f);
        drawLightningBolts();
        drawArrows();
        drawBladeTrail();
        drawBladeSparkles();
        drawSliceLines();
        drawPopups();
        drawHUD();
        drawScreenFlash();
        drawCursor();
    } else if (state === 'start') {
        drawStartScreen();
        drawCursor();
    } else if (state === 'shop') {
        drawShop();
    } else if (state === 'gameover') {
        drawParticles();
        drawShockwaves();
        drawSliceLines();
        for (const h of halves) drawHalf(h);
        drawPopups();
        drawScreenFlash();
        drawGameOver();
        drawCursor();
    }

    if (shaking) {
        ctx.restore();
    }
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>

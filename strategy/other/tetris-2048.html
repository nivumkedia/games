<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a4e;
            overflow: hidden;
            font-family: 'Segoe UI', Arial, sans-serif;
            color: #fff;
            user-select: none;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }
    </style>
</head>
<body>

<canvas id="mainCanvas"></canvas>

<script>
const ROWS = 20;
const TRAY_H = 4;
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');

const COLORS = ['#00f0f0','#f0f000','#a000f0','#00f000','#f00000','#5555ff','#f0a000'];

const SHAPES = [
    [[1,0],[1,1],[1,2],[1,3]],
    [[0,0],[0,1],[1,0],[1,1]],
    [[0,1],[1,0],[1,1],[1,2]],
    [[0,1],[0,2],[1,0],[1,1]],
    [[0,0],[0,1],[1,1],[1,2]],
    [[0,0],[1,0],[1,1],[1,2]],
    [[0,2],[1,0],[1,1],[1,2]],
];
const BOUNDS = [4,2,3,3,3,3,3];

function buildKicks() {
    const data = {
        '01':[[-1,0],[-1,1],[0,-2],[-1,-2]], '10':[[1,0],[1,-1],[0,2],[1,2]],
        '12':[[1,0],[1,-1],[0,2],[1,2]],      '21':[[-1,0],[-1,1],[0,-2],[-1,-2]],
        '23':[[1,0],[1,1],[0,-2],[1,-2]],      '32':[[-1,0],[-1,-1],[0,2],[-1,2]],
        '30':[[-1,0],[-1,-1],[0,2],[-1,2]],   '03':[[1,0],[1,1],[0,-2],[1,-2]],
    };
    const iData = {
        '01':[[-2,0],[1,0],[-2,-1],[1,2]],  '10':[[2,0],[-1,0],[2,1],[-1,-2]],
        '12':[[-1,0],[2,0],[-1,2],[2,-1]],  '21':[[1,0],[-2,0],[1,-2],[-2,1]],
        '23':[[2,0],[-1,0],[2,1],[-1,-2]],  '32':[[-2,0],[1,0],[-2,-1],[1,2]],
        '30':[[1,0],[-2,0],[1,-2],[-2,1]],  '03':[[-1,0],[2,0],[-1,2],[2,-1]],
    };
    return { normal: data, I: iData };
}
const KICKS = buildKicks();

let CELL, COLS;
let boardX, boardY; // pixel offset of board on canvas

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    CELL = Math.floor(canvas.height / (ROWS + TRAY_H));
    CELL = Math.max(CELL, 16);
    COLS = Math.floor(canvas.width / CELL);
    COLS = Math.max(COLS, 10);
    // Center the board if it doesn't fill exactly
    boardX = Math.floor((canvas.width - COLS * CELL) / 2);
    boardY = Math.floor((canvas.height - (ROWS + TRAY_H) * CELL) / 2);
    // Resize grid if needed
    if (grid && grid[0].length !== COLS) {
        const oldCols = grid[0].length;
        for (let r = 0; r < ROWS; r++) {
            if (COLS > oldCols) {
                grid[r] = grid[r].concat(new Array(COLS - oldCols).fill(-1));
            } else {
                grid[r] = grid[r].slice(0, COLS);
            }
        }
    }
}

let grid, score, level, lines, gameOver, paused;
let cur, nextQueue, bag;
let dragging, dragOffX, dragOffY, hoverX, hoverY, hoverValid;
let particles = [];
let explosionRows = [];
let animId, lastFrame;

function shuffledBag() {
    const a = [0,1,2,3,4,5,6];
    for (let i = 6; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}
function nextType() {
    if (bag.length === 0) bag = shuffledBag();
    return bag.pop();
}

function makePiece(type) {
    return { type, cells: SHAPES[type].map(([r,c]) => [r,c]), rot: 0 };
}

function rotateCells(cells, type, dir) {
    const size = BOUNDS[type];
    if (dir === 1) return cells.map(([r,c]) => [c, size-1-r]);
    return cells.map(([r,c]) => [size-1-c, r]);
}

function cellBounds(cells) {
    let minR=99,maxR=0,minC=99,maxC=0;
    for (const [r,c] of cells) {
        minR=Math.min(minR,r); maxR=Math.max(maxR,r);
        minC=Math.min(minC,c); maxC=Math.max(maxC,c);
    }
    return {minR,maxR,minC,maxC,w:maxC-minC+1,h:maxR-minR+1};
}

function valid(cells, px, py) {
    for (const [r,c] of cells) {
        const bx=px+c, by=py+r;
        if (bx<0||bx>=COLS||by<0||by>=ROWS) return false;
        if (grid[by][bx]!==-1) return false;
    }
    return true;
}

function landingY(cells, px, startY) {
    let y = startY;
    while (valid(cells, px, y+1)) y++;
    return y;
}

function trayPos() {
    if (!cur) return {x:0,y:0};
    const b = cellBounds(cur.cells);
    const px = Math.floor((COLS - b.w) / 2) - b.minC;
    const py = ROWS + Math.floor((TRAY_H - b.h) / 2) - b.minR;
    return {x: boardX + px * CELL, y: boardY + py * CELL};
}

function placePiece(px) {
    const ly = landingY(cur.cells, px, 0);
    if (!valid(cur.cells, px, ly)) { gameOver = true; return; }
    for (const [r,c] of cur.cells) grid[ly+r][px+c] = cur.type;
    checkLines();
    spawnNext();
}

function checkLines() {
    for (let r = ROWS - 1; r >= 0; r--) {
        if (grid[r].every(c => c !== -1)) {
            explosionRows.push({ row: r, timer: 0, maxTime: 600 });
            spawnRowParticles(r);
        }
    }
}

function clearExplodedRows() {
    const rowsToClear = explosionRows.map(e => e.row).sort((a,b) => b-a);
    let cleared = 0;
    for (const r of rowsToClear) {
        grid.splice(r, 1);
        grid.unshift(new Array(COLS).fill(-1));
        cleared++;
    }
    explosionRows = [];
    if (cleared > 0) {
        const pts = [0,100,300,500,800];
        score += (pts[cleared]||800) * level;
        lines += cleared;
        const nl = Math.floor(lines/10)+1;
        if (nl > level) level = nl;
    }
}

function spawnRowParticles(row) {
    for (let c = 0; c < COLS; c++) {
        const color = COLORS[grid[row][c]] || '#fff';
        const cx = boardX + c * CELL + CELL/2;
        const cy = boardY + row * CELL + CELL/2;
        for (let i = 0; i < 6; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 80 + Math.random() * 200;
            particles.push({
                x: cx, y: cy,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 60,
                life: 0.6 + Math.random() * 0.4,
                maxLife: 0.6 + Math.random() * 0.4,
                size: 3 + Math.random() * 4,
                color,
            });
        }
    }
}

function spawnNext() {
    cur = makePiece(nextQueue.shift());
    nextQueue.push(nextType());
    dragging = false;
    hoverValid = false;
}

// Drawing helpers
function drawBlock(col, row, type, alpha) {
    if (type < 0) return;
    ctx.globalAlpha = alpha || 1;
    const pad = 1;
    const x = boardX + col*CELL+pad, y = boardY + row*CELL+pad, s = CELL-pad*2;
    ctx.fillStyle = COLORS[type];
    ctx.fillRect(x, y, s, s);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(x, y, s, 2); ctx.fillRect(x, y, 2, s);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(x, y+s-2, s, 2); ctx.fillRect(x+s-2, y, 2, s);
    ctx.globalAlpha = 1;
}

function drawBlockPx(px, py, type, alpha) {
    if (type < 0) return;
    ctx.globalAlpha = alpha || 1;
    const pad = 1, s = CELL-pad*2;
    ctx.fillStyle = COLORS[type];
    ctx.fillRect(px+pad, py+pad, s, s);
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.fillRect(px+pad, py+pad, s, 2); ctx.fillRect(px+pad, py+pad, 2, s);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(px+pad, py+pad+s-2, s, 2); ctx.fillRect(px+pad+s-2, py+pad, 2, s);
    ctx.globalAlpha = 1;
}

function drawMiniPiece(type, cx, cy, cellSize) {
    if (type < 0) return;
    const cells = SHAPES[type];
    const b = cellBounds(cells);
    const ox = cx - b.w*cellSize/2, oy = cy - b.h*cellSize/2;
    for (const [r,c] of cells) {
        const px = ox + (c-b.minC)*cellSize, py = oy + (r-b.minR)*cellSize;
        const pad=1, s=cellSize-pad*2;
        ctx.fillStyle = COLORS[type];
        ctx.fillRect(px+pad,py+pad,s,s);
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        ctx.fillRect(px+pad,py+pad,s,2); ctx.fillRect(px+pad,py+pad,2,s);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fillRect(px+pad,py+pad+s-2,s,2); ctx.fillRect(px+pad+s-2,py+pad,2,s);
    }
}

function render() {
    // Clear
    ctx.fillStyle = '#1a1a4e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Board background
    ctx.fillStyle = '#000';
    ctx.fillRect(boardX, boardY, COLS*CELL, ROWS*CELL);

    // Grid lines
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1;
    for (let r = 0; r <= ROWS; r++) {
        ctx.beginPath(); ctx.moveTo(boardX, boardY+r*CELL); ctx.lineTo(boardX+COLS*CELL, boardY+r*CELL); ctx.stroke();
    }
    for (let c = 0; c <= COLS; c++) {
        ctx.beginPath(); ctx.moveTo(boardX+c*CELL, boardY); ctx.lineTo(boardX+c*CELL, boardY+ROWS*CELL); ctx.stroke();
    }

    // Tray
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(boardX, boardY+ROWS*CELL, COLS*CELL, TRAY_H*CELL);
    ctx.strokeStyle = '#444'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(boardX, boardY+ROWS*CELL); ctx.lineTo(boardX+COLS*CELL, boardY+ROWS*CELL); ctx.stroke();

    // Exploding rows
    const explodingSet = new Set(explosionRows.map(e => e.row));

    // Placed blocks
    for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
            if (grid[r][c] !== -1) {
                if (explodingSet.has(r)) {
                    const eData = explosionRows.find(e => e.row === r);
                    const prog = eData.timer / eData.maxTime;
                    const flash = prog < 0.3 ? 1 : Math.max(0, 1-(prog-0.3)/0.7);
                    ctx.globalAlpha = flash;
                    const pad=1, x=boardX+c*CELL+pad, y=boardY+r*CELL+pad, s=CELL-pad*2;
                    ctx.fillStyle = COLORS[grid[r][c]];
                    ctx.fillRect(x, y, s, s);
                    if (prog < 0.3) {
                        ctx.fillStyle = `rgba(255,255,255,${1-prog/0.3})`;
                        ctx.fillRect(x, y, s, s);
                    }
                    ctx.globalAlpha = 1;
                } else {
                    drawBlock(c, r, grid[r][c]);
                }
            }
        }
    }

    // Ghost (drag)
    if (cur && !gameOver && hoverValid && dragging) {
        const ly = landingY(cur.cells, hoverX, 0);
        if (valid(cur.cells, hoverX, ly)) {
            for (const [r,c] of cur.cells) drawBlock(hoverX+c, ly+r, cur.type, 0.35);
        }
    }
    // Ghost (keyboard)
    if (cur && !gameOver && !dragging && kbX !== null) {
        const ly = landingY(cur.cells, kbX, 0);
        if (valid(cur.cells, kbX, ly)) {
            for (const [r,c] of cur.cells) drawBlock(kbX+c, ly+r, cur.type, 0.35);
        }
    }

    // Current piece
    if (cur && !gameOver) {
        if (dragging) {
            for (const [r,c] of cur.cells) drawBlockPx(dragPxX+c*CELL, dragPxY+r*CELL, cur.type, 0.85);
        } else {
            const tp = trayPos();
            for (const [r,c] of cur.cells) drawBlockPx(tp.x+c*CELL, tp.y+r*CELL, cur.type, 1);
        }
    }

    // Particles
    for (const p of particles) {
        const alpha = p.life / p.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size*alpha, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size*alpha*0.4, 0, Math.PI*2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // HUD - draw on canvas
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px "Segoe UI", Arial';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    const hx = boardX + 12, hy = boardY + ROWS*CELL + 10;
    ctx.fillStyle = '#888'; ctx.font = '11px "Segoe UI", Arial';
    ctx.fillText('SCORE', hx, hy);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 22px "Segoe UI", Arial';
    ctx.fillText(score, hx, hy + 14);

    const hx2 = hx + 120;
    ctx.fillStyle = '#888'; ctx.font = '11px "Segoe UI", Arial';
    ctx.fillText('LEVEL', hx2, hy);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 22px "Segoe UI", Arial';
    ctx.fillText(level, hx2, hy + 14);

    const hx3 = hx2 + 100;
    ctx.fillStyle = '#888'; ctx.font = '11px "Segoe UI", Arial';
    ctx.fillText('LINES', hx3, hy);
    ctx.fillStyle = '#fff'; ctx.font = 'bold 22px "Segoe UI", Arial';
    ctx.fillText(lines, hx3, hy + 14);

    // Next pieces in tray area (right side)
    ctx.fillStyle = '#888'; ctx.font = '11px "Segoe UI", Arial';
    ctx.textAlign = 'center';
    const nx = boardX + COLS*CELL - 60;
    ctx.fillText('NEXT', nx, hy);
    for (let i = 0; i < Math.min(3, nextQueue.length); i++) {
        drawMiniPiece(nextQueue[i], nx - 40 + i * 45, hy + 36, 14);
    }

    // Controls hint
    ctx.fillStyle = '#555'; ctx.font = '11px "Segoe UI", Arial';
    ctx.textAlign = 'right';
    ctx.fillText('Drag to place | Scroll/R rotate | Arrows+Space | P pause', boardX + COLS*CELL - 12, boardY + (ROWS+TRAY_H)*CELL - 8);

    // Game over
    if (gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px "Segoe UI", Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2-24);
        ctx.font = 'bold 24px "Segoe UI", Arial';
        ctx.fillStyle = '#f0a000';
        ctx.fillText('Score: ' + score, canvas.width/2, canvas.height/2+12);
        ctx.font = '16px "Segoe UI", Arial';
        ctx.fillStyle = '#aaa';
        ctx.fillText('Press Enter to restart', canvas.width/2, canvas.height/2+44);
    }

    if (paused && !gameOver) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px "Segoe UI", Arial';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
    }
}

// Input
let dragPxX = 0, dragPxY = 0;
let kbX = null;

function getCanvasPos(e) {
    return { x: e.clientX, y: e.clientY };
}

function pieceHitTest(mx, my) {
    if (!cur) return false;
    const tp = trayPos();
    for (const [r,c] of cur.cells) {
        const px = tp.x+c*CELL, py = tp.y+r*CELL;
        if (mx>=px && mx<px+CELL && my>=py && my<py+CELL) return true;
    }
    return false;
}

function snapToGrid(pxX) {
    const b = cellBounds(cur.cells);
    const centerX = pxX - boardX + (b.minC + b.w/2) * CELL;
    const col = Math.round(centerX / CELL - b.w/2);
    return Math.max(-b.minC, Math.min(COLS - b.maxC - 1, col));
}

canvas.addEventListener('mousedown', e => {
    if (gameOver || paused || !cur || explosionRows.length > 0) return;
    const pos = getCanvasPos(e);
    if (pieceHitTest(pos.x, pos.y)) {
        dragging = true; kbX = null;
        const tp = trayPos();
        dragOffX = pos.x - tp.x; dragOffY = pos.y - tp.y;
        dragPxX = tp.x; dragPxY = tp.y;
    }
});

canvas.addEventListener('mousemove', e => {
    if (!dragging || !cur) return;
    const pos = getCanvasPos(e);
    dragPxX = pos.x - dragOffX; dragPxY = pos.y - dragOffY;
    const col = snapToGrid(dragPxX);
    if (valid(cur.cells, col, 0)) { hoverX = col; hoverValid = true; }
    else hoverValid = false;
});

canvas.addEventListener('mouseup', e => {
    if (!dragging || !cur) return;
    const pos = getCanvasPos(e);
    dragging = false;
    if (pos.y < boardY + ROWS*CELL + CELL && hoverValid) {
        const col = snapToGrid(dragPxX);
        if (valid(cur.cells, col, 0)) placePiece(col);
    }
    hoverValid = false;
});

canvas.addEventListener('mouseleave', () => { dragging = false; hoverValid = false; });

canvas.addEventListener('wheel', e => {
    if (gameOver || paused || !cur || explosionRows.length > 0) return;
    e.preventDefault();
    doRotate(e.deltaY > 0 ? 1 : -1);
});

function doRotate(dir) {
    if (cur.type === 1) return;
    cur.cells = rotateCells(cur.cells, cur.type, dir);
    cur.rot = (cur.rot + dir + 4) % 4;
    if (kbX !== null) {
        const b = cellBounds(cur.cells);
        kbX = Math.max(-b.minC, Math.min(COLS - b.maxC - 1, kbX));
    }
}

document.addEventListener('keydown', e => {
    if (e.repeat) return;
    if (gameOver && e.key === 'Enter') { init(); return; }
    if (e.key === 'p' || e.key === 'P') { if (!gameOver) paused = !paused; return; }
    if (gameOver || paused || !cur || explosionRows.length > 0) return;

    switch(e.key) {
        case 'ArrowLeft': {
            if (kbX === null) { const b = cellBounds(cur.cells); kbX = Math.floor((COLS-b.w)/2)-b.minC; }
            const b2 = cellBounds(cur.cells);
            if (kbX-1 >= -b2.minC) kbX--;
            e.preventDefault(); break;
        }
        case 'ArrowRight': {
            if (kbX === null) { const b = cellBounds(cur.cells); kbX = Math.floor((COLS-b.w)/2)-b.minC; }
            const b2 = cellBounds(cur.cells);
            if (kbX+1 <= COLS-b2.maxC-1) kbX++;
            e.preventDefault(); break;
        }
        case 'ArrowUp': case 'r': case 'R':
            doRotate(1); e.preventDefault(); break;
        case 'ArrowDown': case 'z': case 'Z':
            doRotate(-1); e.preventDefault(); break;
        case ' ': case 'Enter':
            if (kbX === null) { const b = cellBounds(cur.cells); kbX = Math.floor((COLS-b.w)/2)-b.minC; }
            if (valid(cur.cells, kbX, 0)) { placePiece(kbX); kbX = null; }
            e.preventDefault(); break;
    }
});

// Game loop
function update(dt) {
    if (gameOver || paused) return;
    let anyDone = false;
    for (const e of explosionRows) { e.timer += dt; if (e.timer >= e.maxTime) anyDone = true; }
    if (anyDone && explosionRows.every(e => e.timer >= e.maxTime)) clearExplodedRows();
    for (const p of particles) {
        p.x += p.vx*dt/1000; p.y += p.vy*dt/1000;
        p.vy += 400*dt/1000; p.life -= dt/1000;
    }
    particles = particles.filter(p => p.life > 0);
}

function gameLoop(time) {
    animId = requestAnimationFrame(gameLoop);
    if (!lastFrame) lastFrame = time;
    const dt = Math.min(time - lastFrame, 100);
    lastFrame = time;
    update(dt);
    render();
}

function init() {
    resize();
    grid = Array.from({length:ROWS}, () => new Array(COLS).fill(-1));
    score = 0; level = 1; lines = 0;
    gameOver = false; paused = false;
    bag = []; nextQueue = [];
    for (let i = 0; i < 5; i++) nextQueue.push(nextType());
    particles = []; explosionRows = [];
    dragging = false; hoverValid = false; kbX = null; lastFrame = 0;
    spawnNext();
    if (animId) cancelAnimationFrame(animId);
    animId = requestAnimationFrame(gameLoop);
}

window.addEventListener('resize', () => { resize(); });
init();
</script>

</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Harry Potter: Wizard's Duel</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');

:root {
    --bg-dark: #0a0a1a;
    --bg-medium: #14142e;
    --bg-light: #1e1e3f;
    --gold: #d4a843;
    --gold-light: #f0d078;
    --purple: #7b2fbe;
    --purple-dark: #4a1a6b;
    --blue: #2a6fdb;
    --blue-dark: #1a3a7a;
    --red: #c0392b;
    --red-dark: #8b1a1a;
    --green: #27ae60;
    --green-dark: #1a6b3a;
    --text: #e8e8f0;
    --text-dim: #8888aa;
    --text-bright: #ffffff;
}

body {
    background: var(--bg-dark);
    color: var(--text);
    font-family: 'Crimson Text', Georgia, serif;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
}

/* ========== PARTICLES BACKGROUND ========== */
#particles-canvas {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    pointer-events: none;
}

/* ========== TITLE SCREEN ========== */
#title-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    padding: 20px 10px;
    z-index: 10;
    background: radial-gradient(ellipse at center, #1a1a3f 0%, #0a0a1a 70%);
    overflow-y: auto;
}

.title-container {
    text-align: center;
    margin-bottom: 15px;
}

.title-main {
    font-family: 'Cinzel', serif;
    font-size: 3.5em;
    font-weight: 900;
    color: var(--gold);
    text-shadow: 0 0 30px rgba(212, 168, 67, 0.5), 0 0 60px rgba(212, 168, 67, 0.2);
    letter-spacing: 3px;
    margin-bottom: 5px;
}

.title-sub {
    font-family: 'Cinzel', serif;
    font-size: 1.6em;
    color: var(--gold-light);
    opacity: 0.7;
    letter-spacing: 6px;
    text-transform: uppercase;
}

.selection-section {
    margin: 8px 0;
    text-align: center;
}

.section-label {
    font-family: 'Cinzel', serif;
    font-size: 1.1em;
    color: var(--gold);
    margin-bottom: 12px;
    letter-spacing: 2px;
    text-transform: uppercase;
}

.character-grid {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
    max-width: 920px;
}

.char-card {
    width: 140px;
    padding: 14px 10px;
    background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
    border: 2px solid rgba(212, 168, 67, 0.2);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.char-card:hover {
    border-color: var(--gold);
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(212, 168, 67, 0.2);
}

.char-card.selected {
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(212, 168, 67, 0.4), inset 0 0 20px rgba(212, 168, 67, 0.1);
}

.char-avatar {
    font-size: 3em;
    margin-bottom: 8px;
}

.char-name {
    font-family: 'Cinzel', serif;
    font-size: 1em;
    color: var(--gold-light);
    margin-bottom: 6px;
}

.char-trait {
    font-size: 0.8em;
    color: var(--text-dim);
    font-style: italic;
    margin-bottom: 8px;
}

.char-stats {
    font-size: 0.78em;
    color: var(--text-dim);
    line-height: 1.5;
}

.char-stats span {
    color: var(--gold);
}

/* Difficulty selection */
.difficulty-grid {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

.diff-btn {
    padding: 10px 22px;
    background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
    border: 2px solid rgba(212, 168, 67, 0.2);
    border-radius: 8px;
    color: var(--text);
    font-family: 'Cinzel', serif;
    font-size: 0.95em;
    cursor: pointer;
    transition: all 0.3s ease;
}

.diff-btn:hover {
    border-color: var(--gold);
    transform: translateY(-2px);
}

.diff-btn.selected {
    border-color: var(--gold);
    box-shadow: 0 0 15px rgba(212, 168, 67, 0.3);
    background: linear-gradient(135deg, var(--purple-dark), var(--bg-medium));
}

.diff-desc {
    font-family: 'Crimson Text', serif;
    font-size: 0.75em;
    color: var(--text-dim);
    margin-top: 4px;
}

/* Mode toggle */
.mode-toggle {
    display: flex;
    gap: 12px;
    justify-content: center;
    margin-bottom: 6px;
}

.mode-btn {
    padding: 8px 24px;
    background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
    border: 2px solid rgba(212, 168, 67, 0.2);
    border-radius: 8px;
    color: var(--text);
    font-family: 'Cinzel', serif;
    font-size: 0.95em;
    cursor: pointer;
    transition: all 0.3s ease;
}

.mode-btn:hover {
    border-color: var(--gold);
    transform: translateY(-2px);
}

.mode-btn.selected {
    border-color: var(--gold);
    box-shadow: 0 0 15px rgba(212, 168, 67, 0.3);
    background: linear-gradient(135deg, var(--purple-dark), var(--bg-medium));
}

/* P2 character selection */
.p2-section {
    transition: max-height 0.3s ease, opacity 0.3s ease;
    overflow: hidden;
}

.p2-section.hidden {
    max-height: 0;
    opacity: 0;
    margin: 0;
    pointer-events: none;
}

.p2-char-card {
    width: 140px;
    padding: 14px 10px;
    background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
    border: 2px solid rgba(192, 57, 43, 0.2);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
}

.p2-char-card:hover {
    border-color: var(--red);
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(192, 57, 43, 0.2);
}

.p2-char-card.selected {
    border-color: var(--red);
    box-shadow: 0 0 20px rgba(192, 57, 43, 0.4), inset 0 0 20px rgba(192, 57, 43, 0.1);
}

.planning-player-label {
    font-family: 'Cinzel', serif;
    font-size: 1.3em;
    color: var(--gold);
    margin-bottom: 8px;
    text-align: center;
}

.planning-player-label.p2 {
    color: var(--red);
}

/* Start button */
.start-btn {
    margin-top: 15px;
    padding: 14px 50px;
    background: linear-gradient(135deg, var(--gold), #b8922a);
    border: none;
    border-radius: 8px;
    color: var(--bg-dark);
    font-family: 'Cinzel', serif;
    font-size: 1.3em;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 2px;
    text-transform: uppercase;
}

.start-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 30px rgba(212, 168, 67, 0.5);
}

.start-btn:active {
    transform: translateY(0);
}

/* ========== PLANNING SCREEN ========== */
#planning-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    z-index: 10;
    background: radial-gradient(ellipse at center, #1a1a3f 0%, #0a0a1a 70%);
    padding: 20px;
    overflow-y: auto;
}

.planning-header {
    text-align: center;
    margin-bottom: 10px;
    margin-top: 10px;
}

.mana-info {
    font-family: 'Cinzel', serif;
    font-size: 0.9em;
    color: var(--blue);
    margin-top: 6px;
}

.spell-reference {
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 920px;
    margin-bottom: 12px;
}

.plan-spell-card {
    width: 115px;
    padding: 10px 8px;
    background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
    border: 2px solid rgba(212, 168, 67, 0.15);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.25s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
    user-select: none;
}

.plan-spell-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 3px;
}

.plan-spell-card.attack::before { background: linear-gradient(90deg, #c0392b, #e74c3c); }
.plan-spell-card.defense::before { background: linear-gradient(90deg, #2a6fdb, #3498db); }
.plan-spell-card.utility::before { background: linear-gradient(90deg, #27ae60, #2ecc71); }
.plan-spell-card.wait-card::before { background: linear-gradient(90deg, var(--text-dim), var(--text-dim)); }

.plan-spell-card:hover:not(.maxed) {
    border-color: var(--gold);
    transform: translateY(-6px);
    box-shadow: 0 8px 25px rgba(212, 168, 67, 0.3);
}

.plan-spell-card:active {
    transform: translateY(-2px);
    box-shadow: 0 2px 10px rgba(212, 168, 67, 0.4);
}

.plan-spell-card.just-added {
    animation: card-pop 0.35s ease;
}

@keyframes card-pop {
    0% { transform: scale(1); }
    40% { transform: scale(0.92); border-color: var(--green); box-shadow: 0 0 20px rgba(39, 174, 96, 0.5); }
    100% { transform: scale(1); }
}

.plan-spell-card .plan-icon { font-size: 1.6em; margin-bottom: 4px; }
.plan-spell-card .plan-name {
    font-family: 'Cinzel', serif;
    font-size: 0.72em;
    color: var(--gold-light);
    margin-bottom: 3px;
    line-height: 1.2;
}
.plan-spell-card .plan-cost { font-size: 0.65em; color: var(--blue); margin-bottom: 2px; }
.plan-spell-card .plan-desc {
    font-size: 0.6em;
    color: var(--text-dim);
    line-height: 1.2;
}

.plan-spell-card .plan-uses {
    font-size: 0.6em;
    color: var(--text-dim);
    margin-top: 3px;
}

.plan-spell-card.maxed {
    opacity: 0.35;
    cursor: not-allowed;
    filter: grayscale(0.5);
}

.queue-section {
    width: 100%;
    max-width: 800px;
    text-align: center;
    margin: 10px 0;
}

.spell-queue {
    display: flex;
    gap: 6px;
    justify-content: center;
    flex-wrap: wrap;
    min-height: 55px;
    padding: 12px;
    background: rgba(30, 30, 63, 0.5);
    border: 2px dashed rgba(212, 168, 67, 0.3);
    border-radius: 12px;
    margin: 8px 0;
    align-items: center;
}

.queue-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 5px 10px;
    background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
    border: 1px solid rgba(212, 168, 67, 0.3);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    position: relative;
}

.queue-item:hover {
    border-color: var(--red);
    box-shadow: 0 0 10px rgba(192, 57, 43, 0.3);
}

.queue-item .queue-number {
    font-family: 'Cinzel', serif;
    font-size: 0.55em;
    color: var(--gold);
    position: absolute;
    top: -7px;
    left: -7px;
    background: var(--bg-dark);
    border: 1px solid var(--gold);
    border-radius: 50%;
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
}

.queue-item .queue-icon { font-size: 1.2em; }
.queue-item .queue-name {
    font-size: 0.55em;
    color: var(--text-dim);
    max-width: 65px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.queue-info {
    font-size: 0.78em;
    color: var(--text-dim);
    font-style: italic;
}

.queue-mana-preview {
    font-size: 0.8em;
    color: var(--text-dim);
    margin-top: 4px;
    line-height: 1.6;
}

.queue-mana-preview .mana-ok { color: var(--blue); }
.queue-mana-preview .mana-bad { color: var(--red); }

.planning-buttons {
    display: flex;
    gap: 14px;
    margin-top: 12px;
}

.clear-queue-btn {
    padding: 10px 22px;
    background: transparent;
    border: 2px solid var(--red);
    border-radius: 8px;
    color: var(--red);
    font-family: 'Cinzel', serif;
    font-size: 0.9em;
    cursor: pointer;
    transition: all 0.3s ease;
}

.clear-queue-btn:hover {
    background: var(--red);
    color: white;
}

/* ========== BATTLE SCREEN ========== */
#battle-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    z-index: 10;
    background: radial-gradient(ellipse at center top, #1a1a3f 0%, #0a0a1a 70%);
}

/* Top bar: opponent info */
.opponent-panel {
    display: flex;
    align-items: center;
    padding: 12px 24px;
    background: linear-gradient(180deg, rgba(20,20,46,0.95), rgba(20,20,46,0.6));
}

.opponent-avatar {
    font-size: 2.4em;
    margin-right: 14px;
}

.opponent-info {
    flex: 1;
}

.opponent-name {
    font-family: 'Cinzel', serif;
    font-size: 1.15em;
    color: var(--red);
    margin-bottom: 4px;
}

.bar-container {
    width: 100%;
    max-width: 350px;
    height: 16px;
    background: rgba(0,0,0,0.5);
    border-radius: 8px;
    overflow: hidden;
    margin-bottom: 4px;
    position: relative;
}

.bar-fill {
    height: 100%;
    border-radius: 8px;
    transition: width 0.5s ease;
}

.hp-bar { background: linear-gradient(90deg, var(--red), #e74c3c); }
.hp-bar-safe { background: linear-gradient(90deg, var(--green), #2ecc71); }
.hp-bar-warn { background: linear-gradient(90deg, #e67e22, #f39c12); }
.mana-bar { background: linear-gradient(90deg, var(--blue), #3498db); }

.bar-text {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 0.7em;
    font-weight: 600;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}

.mana-container {
    height: 10px;
}

.status-badges {
    display: flex;
    gap: 6px;
    margin-top: 4px;
    flex-wrap: wrap;
}

.status-badge {
    font-size: 0.7em;
    padding: 2px 8px;
    border-radius: 10px;
    background: rgba(100, 100, 200, 0.3);
    border: 1px solid rgba(100, 100, 200, 0.5);
    color: var(--text);
}

.status-badge.debuff {
    background: rgba(200, 50, 50, 0.3);
    border-color: rgba(200, 50, 50, 0.5);
    color: #ff8888;
}

.status-badge.buff {
    background: rgba(50, 200, 100, 0.3);
    border-color: rgba(50, 200, 100, 0.5);
    color: #88ff88;
}

.turn-indicator {
    font-family: 'Cinzel', serif;
    font-size: 0.85em;
    color: var(--gold);
    margin-left: auto;
    text-align: right;
}

.turn-number {
    font-size: 1.8em;
    font-weight: 700;
}

/* Battle arena */
.battle-arena {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.arena-floor {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 40%;
    background: linear-gradient(180deg, transparent, rgba(30, 30, 63, 0.5));
}

.duelist {
    font-size: 5em;
    position: absolute;
    transition: transform 0.1s;
    z-index: 2;
}

.duelist.player-sprite {
    left: 20%;
    bottom: 30%;
}

.duelist.opponent-sprite {
    right: 20%;
    bottom: 30%;
    transform: scaleX(-1);
}

.duelist.shake {
    animation: shake 0.5s ease-in-out;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10% { transform: translateX(-10px) rotate(-2deg); }
    30% { transform: translateX(10px) rotate(2deg); }
    50% { transform: translateX(-8px) rotate(-1deg); }
    70% { transform: translateX(8px) rotate(1deg); }
    90% { transform: translateX(-4px); }
}

.opponent-sprite.shake {
    animation: shake-flip 0.5s ease-in-out;
}

@keyframes shake-flip {
    0%, 100% { transform: scaleX(-1) translateX(0); }
    10% { transform: scaleX(-1) translateX(-10px) rotate(-2deg); }
    30% { transform: scaleX(-1) translateX(10px) rotate(2deg); }
    50% { transform: scaleX(-1) translateX(-8px) rotate(-1deg); }
    70% { transform: scaleX(-1) translateX(8px) rotate(1deg); }
    90% { transform: scaleX(-1) translateX(-4px); }
}

/* Spell effects canvas overlay */
#spell-canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 5;
    pointer-events: none;
}

.screen-flash {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 4;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.06s ease-out;
}

/* Floating damage numbers */
.damage-number {
    position: absolute;
    font-family: 'Cinzel', serif;
    font-size: 1.8em;
    font-weight: 900;
    z-index: 10;
    pointer-events: none;
    animation: float-up 1.2s ease-out forwards;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

.damage-number.damage { color: #ff4444; }
.damage-number.heal { color: #44ff44; }
.damage-number.mana-drain { color: #4488ff; }
.damage-number.blocked { color: #8888aa; font-size: 1.2em; }
.damage-number.stun { color: #ffaa00; }

@keyframes float-up {
    0% { transform: translateY(0) scale(0.5); opacity: 0; }
    15% { transform: translateY(-10px) scale(1.2); opacity: 1; }
    30% { transform: translateY(-25px) scale(1); opacity: 1; }
    100% { transform: translateY(-80px) scale(0.8); opacity: 0; }
}

/* Battle log */
.battle-log-container {
    position: absolute;
    right: 14px;
    top: 50%;
    transform: translateY(-50%);
    width: 240px;
    max-height: 260px;
    overflow-y: auto;
    background: rgba(10, 10, 26, 0.85);
    border: 1px solid rgba(212, 168, 67, 0.2);
    border-radius: 8px;
    padding: 10px;
    z-index: 8;
}

.battle-log-container::-webkit-scrollbar { width: 4px; }
.battle-log-container::-webkit-scrollbar-track { background: transparent; }
.battle-log-container::-webkit-scrollbar-thumb { background: var(--gold); border-radius: 2px; }

.log-title {
    font-family: 'Cinzel', serif;
    font-size: 0.8em;
    color: var(--gold);
    margin-bottom: 6px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.log-entry {
    font-size: 0.78em;
    padding: 3px 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    color: var(--text-dim);
    line-height: 1.3;
}

.log-entry.player-action { color: #88bbff; }
.log-entry.enemy-action { color: #ff8888; }
.log-entry.system { color: var(--gold); font-style: italic; }

/* Bottom panel: player info + spell queue */
.bottom-panel {
    padding: 10px 20px 14px;
    background: linear-gradient(0deg, rgba(20,20,46,0.98), rgba(20,20,46,0.7));
}

.player-panel {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

.player-avatar {
    font-size: 2em;
    margin-right: 12px;
}

.player-info {
    flex: 1;
}

.player-name {
    font-family: 'Cinzel', serif;
    font-size: 1em;
    color: var(--gold-light);
    margin-bottom: 3px;
}

/* Speed controls */
.speed-controls {
    display: flex;
    gap: 6px;
    align-items: center;
    margin-left: auto;
}

.speed-btn {
    padding: 3px 10px;
    background: transparent;
    border: 1px solid rgba(212, 168, 67, 0.3);
    border-radius: 4px;
    color: var(--text-dim);
    font-family: 'Cinzel', serif;
    font-size: 0.7em;
    cursor: pointer;
    transition: all 0.2s ease;
}

.speed-btn.active {
    border-color: var(--gold);
    color: var(--gold);
    background: rgba(212, 168, 67, 0.1);
}

.speed-btn:hover { border-color: var(--gold); }

/* Battle queue display */
.spell-hand {
    display: flex;
    gap: 4px;
    justify-content: center;
    flex-wrap: wrap;
    align-items: center;
}

.queue-label {
    font-family: 'Cinzel', serif;
    font-size: 0.75em;
    color: var(--text-dim);
    margin-bottom: 4px;
    text-align: center;
    width: 100%;
}

.battle-queue {
    display: flex;
    gap: 4px;
    align-items: center;
    justify-content: center;
    flex-wrap: wrap;
}

.battle-queue-item {
    font-size: 1.2em;
    padding: 2px 4px;
    border-radius: 4px;
    opacity: 0.35;
    transition: all 0.3s ease;
}

.battle-queue-item.current {
    opacity: 1;
    transform: scale(1.3);
    filter: drop-shadow(0 0 6px var(--gold));
}

.battle-queue-item.used {
    opacity: 0.15;
}

/* Spell cards (used in planning reference) */
.spell-card {
    width: 105px;
    padding: 8px 6px;
    background: linear-gradient(135deg, var(--bg-light), var(--bg-medium));
    border: 2px solid rgba(212, 168, 67, 0.15);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s ease;
    text-align: center;
    position: relative;
    overflow: hidden;
}

.spell-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 3px;
}

.spell-card.attack::before { background: linear-gradient(90deg, #c0392b, #e74c3c); }
.spell-card.defense::before { background: linear-gradient(90deg, #2a6fdb, #3498db); }
.spell-card.utility::before { background: linear-gradient(90deg, #27ae60, #2ecc71); }

.spell-card:hover:not(.disabled) {
    border-color: var(--gold);
    transform: translateY(-6px);
    box-shadow: 0 8px 20px rgba(212, 168, 67, 0.25);
}

.spell-card.disabled {
    opacity: 0.35;
    cursor: not-allowed;
    filter: grayscale(0.5);
}

.spell-card.casting {
    border-color: var(--gold);
    box-shadow: 0 0 20px rgba(212, 168, 67, 0.5);
    animation: card-glow 0.5s ease;
}

@keyframes card-glow {
    0% { box-shadow: 0 0 0 rgba(212, 168, 67, 0); }
    50% { box-shadow: 0 0 30px rgba(212, 168, 67, 0.6); }
    100% { box-shadow: 0 0 20px rgba(212, 168, 67, 0.3); }
}

.spell-icon {
    font-size: 1.5em;
    margin-bottom: 3px;
}

.spell-name {
    font-family: 'Cinzel', serif;
    font-size: 0.68em;
    color: var(--gold-light);
    margin-bottom: 3px;
    line-height: 1.2;
}

.spell-cost {
    font-size: 0.65em;
    color: var(--blue);
}

.spell-desc {
    font-size: 0.6em;
    color: var(--text-dim);
    margin-top: 2px;
    line-height: 1.2;
}

.spell-card-enter {
    animation: card-enter 0.4s ease-out backwards;
}

@keyframes card-enter {
    0% { transform: translateY(40px); opacity: 0; }
    100% { transform: translateY(0); opacity: 1; }
}

/* ========== RESULT SCREEN ========== */
#result-screen {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 10;
    background: radial-gradient(ellipse at center, #1a1a3f 0%, #0a0a1a 70%);
}

.result-title {
    font-family: 'Cinzel', serif;
    font-size: 3em;
    font-weight: 900;
    margin-bottom: 10px;
    text-shadow: 0 0 30px currentColor;
}

.result-title.victory { color: var(--gold); }
.result-title.defeat { color: var(--red); }

.result-subtitle {
    font-family: 'Cinzel', serif;
    font-size: 1.2em;
    color: var(--text-dim);
    margin-bottom: 30px;
}

.result-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px 30px;
    margin-bottom: 30px;
    padding: 20px 30px;
    background: rgba(30, 30, 63, 0.5);
    border: 1px solid rgba(212, 168, 67, 0.2);
    border-radius: 12px;
}

.stat-item {
    text-align: center;
}

.stat-label {
    font-size: 0.8em;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.stat-value {
    font-family: 'Cinzel', serif;
    font-size: 1.5em;
    color: var(--gold);
}

.result-buttons {
    display: flex;
    gap: 16px;
}

.result-btn {
    padding: 12px 30px;
    border: 2px solid var(--gold);
    border-radius: 8px;
    background: transparent;
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 1em;
    cursor: pointer;
    transition: all 0.3s ease;
    letter-spacing: 1px;
}

.result-btn:hover {
    background: var(--gold);
    color: var(--bg-dark);
    box-shadow: 0 4px 20px rgba(212, 168, 67, 0.4);
}

.result-btn.primary {
    background: var(--gold);
    color: var(--bg-dark);
    font-weight: 700;
}

.result-btn.primary:hover {
    background: var(--gold-light);
}

/* ========== STUN OVERLAY ========== */
.stun-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(255, 170, 0, 0.08);
    z-index: 7;
    display: none;
    align-items: center;
    justify-content: center;
    pointer-events: none;
}

.stun-text {
    font-family: 'Cinzel', serif;
    font-size: 2.5em;
    font-weight: 900;
    color: #ffaa00;
    text-shadow: 0 0 30px rgba(255, 170, 0, 0.6);
    animation: stun-pulse 0.8s ease-in-out;
}

@keyframes stun-pulse {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.2); opacity: 1; }
    100% { transform: scale(1); opacity: 0.9; }
}

/* Responsive */
@media (max-width: 768px) {
    .title-main { font-size: 2.2em; }
    .title-sub { font-size: 1em; }
    .char-card { width: 120px; padding: 10px 8px; }
    .spell-card { width: 90px; }
    .battle-log-container { width: 180px; max-height: 180px; }
    .duelist { font-size: 3.5em; }
    .plan-spell-card { width: 95px; padding: 8px 5px; }
}
</style>
</head>
<body>

<canvas id="particles-canvas"></canvas>

<!-- ========== TITLE SCREEN ========== -->
<div id="title-screen">
    <div class="title-container">
        <div class="title-main">Harry Potter</div>
        <div class="title-sub">Wizard's Duel</div>
    </div>

    <div class="selection-section">
        <div class="section-label">Choose Your Wizard</div>
        <div class="character-grid">
            <div class="char-card selected" data-char="harry" onclick="selectCharacter('harry')">
                <div class="char-avatar">&#9889;</div>
                <div class="char-name">Harry Potter</div>
                <div class="char-trait">The Chosen One</div>
                <div class="char-stats">
                    HP: <span>100</span> | Mana: <span>50</span><br>
                    Regen: <span>8</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="hermione" onclick="selectCharacter('hermione')">
                <div class="char-avatar">&#128218;</div>
                <div class="char-name">Hermione Granger</div>
                <div class="char-trait">Brightest Witch</div>
                <div class="char-stats">
                    HP: <span>85</span> | Mana: <span>65</span><br>
                    Regen: <span>10</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="ron" onclick="selectCharacter('ron')">
                <div class="char-avatar">&#9876;&#65039;</div>
                <div class="char-name">Ron Weasley</div>
                <div class="char-trait">Loyal Defender</div>
                <div class="char-stats">
                    HP: <span>110</span> | Mana: <span>45</span><br>
                    Regen: <span>7</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="neville" onclick="selectCharacter('neville')">
                <div class="char-avatar">&#127807;</div>
                <div class="char-name">Neville Longbottom</div>
                <div class="char-trait">Resilient</div>
                <div class="char-stats">
                    HP: <span>120</span> | Mana: <span>40</span><br>
                    Regen: <span>6</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="luna" onclick="selectCharacter('luna')">
                <div class="char-avatar">&#127769;</div>
                <div class="char-name">Luna Lovegood</div>
                <div class="char-trait">Mystical</div>
                <div class="char-stats">
                    HP: <span>80</span> | Mana: <span>70</span><br>
                    Regen: <span>11</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="ginny" onclick="selectCharacter('ginny')">
                <div class="char-avatar">&#128293;</div>
                <div class="char-name">Ginny Weasley</div>
                <div class="char-trait">Fierce</div>
                <div class="char-stats">
                    HP: <span>90</span> | Mana: <span>55</span><br>
                    Regen: <span>9</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="dumbledore" onclick="selectCharacter('dumbledore')">
                <div class="char-avatar">&#11088;</div>
                <div class="char-name">Albus Dumbledore</div>
                <div class="char-trait">Archmage</div>
                <div class="char-stats">
                    HP: <span>95</span> | Mana: <span>80</span><br>
                    Regen: <span>12</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="snape" onclick="selectCharacter('snape')">
                <div class="char-avatar">&#129514;</div>
                <div class="char-name">Severus Snape</div>
                <div class="char-trait">Dark Arts Expert</div>
                <div class="char-stats">
                    HP: <span>95</span> | Mana: <span>60</span><br>
                    Regen: <span>9</span>/turn
                </div>
            </div>
            <div class="char-card" data-char="mcgonagall" onclick="selectCharacter('mcgonagall')">
                <div class="char-avatar">&#128049;</div>
                <div class="char-name">McGonagall</div>
                <div class="char-trait">Transfiguration Master</div>
                <div class="char-stats">
                    HP: <span>100</span> | Mana: <span>58</span><br>
                    Regen: <span>9</span>/turn
                </div>
            </div>
        </div>
    </div>

    <div class="selection-section">
        <div class="section-label">Game Mode</div>
        <div class="mode-toggle">
            <div class="mode-btn selected" data-mode="solo" onclick="selectMode('solo')">Solo Duel</div>
            <div class="mode-btn" data-mode="2player" onclick="selectMode('2player')">2 Player Duel</div>
        </div>
    </div>

    <div class="selection-section" id="difficulty-section">
        <div class="section-label">Difficulty</div>
        <div class="difficulty-grid">
            <div class="diff-btn selected" data-diff="apprentice" onclick="selectDifficulty('apprentice')">
                Apprentice
                <div class="diff-desc">Face Draco Malfoy</div>
            </div>
            <div class="diff-btn" data-diff="auror" onclick="selectDifficulty('auror')">
                Auror
                <div class="diff-desc">Face Bellatrix Lestrange</div>
            </div>
            <div class="diff-btn" data-diff="darklord" onclick="selectDifficulty('darklord')">
                Dark Lord
                <div class="diff-desc">Face Lord Voldemort</div>
            </div>
            <div class="diff-btn" data-diff="deatheater" onclick="selectDifficulty('deatheater')">
                Death Eater
                <div class="diff-desc">Face Fenrir Greyback</div>
            </div>
            <div class="diff-btn" data-diff="legend" onclick="selectDifficulty('legend')">
                Legend
                <div class="diff-desc">Face Grindelwald</div>
            </div>
        </div>
    </div>

    <div class="selection-section p2-section hidden" id="p2-section">
        <div class="section-label" style="color: var(--red);">Player 2 - Choose Your Wizard</div>
        <div class="character-grid" id="p2-char-grid"></div>
    </div>

    <button class="start-btn" onclick="startGame()">Begin Duel</button>
</div>

<!-- ========== PLANNING SCREEN ========== -->
<div id="planning-screen">
    <div class="planning-header">
        <div class="title-sub">Plan Your Spells</div>
        <div class="mana-info" id="planning-mana-info"></div>
    </div>

    <div class="section-label" style="margin-bottom: 8px;">Click a Spell to Add</div>
    <div class="spell-reference" id="spell-reference"></div>

    <div class="queue-section">
        <div class="section-label">Spell Queue</div>
        <div class="spell-queue" id="spell-queue"></div>
        <div class="queue-mana-preview" id="queue-mana-preview"></div>
        <div class="queue-info">Click spells above to add. Click queued spells to remove.</div>
    </div>

    <div class="planning-buttons">
        <button class="clear-queue-btn" onclick="clearQueue()">Clear All</button>
        <button class="start-btn" onclick="startBattle()" id="start-battle-btn" style="opacity: 0.5;">Begin Duel</button>
    </div>
</div>

<!-- ========== BATTLE SCREEN ========== -->
<div id="battle-screen">
    <div class="opponent-panel">
        <div class="opponent-avatar" id="opponent-avatar"></div>
        <div class="opponent-info">
            <div class="opponent-name" id="opponent-name"></div>
            <div class="bar-container">
                <div class="bar-fill hp-bar-safe" id="opponent-hp-bar" style="width:100%"></div>
                <div class="bar-text" id="opponent-hp-text">100/100</div>
            </div>
            <div class="bar-container mana-container">
                <div class="bar-fill mana-bar" id="opponent-mana-bar" style="width:100%"></div>
            </div>
            <div class="status-badges" id="opponent-statuses"></div>
        </div>
        <div class="turn-indicator">
            <div>Turn</div>
            <div class="turn-number" id="turn-number">1</div>
        </div>
    </div>

    <div class="battle-arena" id="battle-arena">
        <div class="arena-floor"></div>
        <canvas id="spell-canvas"></canvas>
        <div class="screen-flash" id="screen-flash"></div>
        <div class="duelist player-sprite" id="player-sprite"></div>
        <div class="duelist opponent-sprite" id="opponent-sprite"></div>

        <div class="battle-log-container" id="battle-log">
            <div class="log-title">Battle Log</div>
        </div>

        <div class="stun-overlay" id="stun-overlay">
            <div class="stun-text">STUNNED!</div>
        </div>
    </div>

    <div class="bottom-panel">
        <div class="player-panel">
            <div class="player-avatar" id="player-avatar"></div>
            <div class="player-info">
                <div class="player-name" id="player-name"></div>
                <div class="bar-container">
                    <div class="bar-fill hp-bar-safe" id="player-hp-bar" style="width:100%"></div>
                    <div class="bar-text" id="player-hp-text">100/100</div>
                </div>
                <div class="bar-container mana-container">
                    <div class="bar-fill mana-bar" id="player-mana-bar" style="width:100%"></div>
                    <div class="bar-text" id="player-mana-text" style="font-size:0.6em">50/50</div>
                </div>
                <div class="status-badges" id="player-statuses"></div>
            </div>
            <div class="speed-controls">
                <span style="font-size: 0.75em; color: var(--text-dim);">Speed:</span>
                <button class="speed-btn" data-speed="1" onclick="setSpeed(1)">1x</button>
                <button class="speed-btn" data-speed="5" onclick="setSpeed(5)">5x</button>
                <button class="speed-btn active" data-speed="10" onclick="setSpeed(10)">10x</button>
                <button class="speed-btn" data-speed="20" onclick="setSpeed(20)">20x</button>
            </div>
        </div>
        <div class="spell-hand" id="spell-hand"></div>
    </div>
</div>

<!-- ========== RESULT SCREEN ========== -->
<div id="result-screen">
    <div class="result-title" id="result-title"></div>
    <div class="result-subtitle" id="result-subtitle"></div>
    <div class="result-stats" id="result-stats"></div>
    <div class="result-buttons">
        <button class="result-btn primary" onclick="duelAgain()">Duel Again</button>
        <button class="result-btn" onclick="backToMenu()">Back to Menu</button>
    </div>
</div>

<script>
// ========== GAME DATA ==========

const CHARACTERS = {
    harry: {
        name: 'Harry Potter',
        avatar: '\u26A1',
        maxHp: 100,
        maxMana: 50,
        manaRegen: 8,
        trait: 'Balanced'
    },
    hermione: {
        name: 'Hermione Granger',
        avatar: '\uD83D\uDCDA',
        maxHp: 85,
        maxMana: 65,
        manaRegen: 10,
        trait: 'Mana-focused'
    },
    ron: {
        name: 'Ron Weasley',
        avatar: '\u2694\uFE0F',
        maxHp: 110,
        maxMana: 45,
        manaRegen: 7,
        trait: 'Tanky'
    },
    neville: {
        name: 'Neville Longbottom',
        avatar: '\uD83C\uDF3F',
        maxHp: 120,
        maxMana: 40,
        manaRegen: 6,
        trait: 'Resilient'
    },
    luna: {
        name: 'Luna Lovegood',
        avatar: '\uD83C\uDF19',
        maxHp: 80,
        maxMana: 70,
        manaRegen: 11,
        trait: 'Mystical'
    },
    ginny: {
        name: 'Ginny Weasley',
        avatar: '\uD83D\uDD25',
        maxHp: 90,
        maxMana: 55,
        manaRegen: 9,
        trait: 'Fierce'
    },
    dumbledore: {
        name: 'Albus Dumbledore',
        avatar: '\u2B50',
        maxHp: 95,
        maxMana: 80,
        manaRegen: 12,
        trait: 'Archmage'
    },
    snape: {
        name: 'Severus Snape',
        avatar: '\uD83E\uDDEA',
        maxHp: 95,
        maxMana: 60,
        manaRegen: 9,
        trait: 'Dark Arts Expert'
    },
    mcgonagall: {
        name: 'Minerva McGonagall',
        avatar: '\uD83D\uDC31',
        maxHp: 100,
        maxMana: 58,
        manaRegen: 9,
        trait: 'Transfiguration Master'
    }
};

const OPPONENTS = {
    apprentice: {
        name: 'Draco Malfoy',
        avatar: '\uD83D\uDC0D',
        maxHp: 90,
        maxMana: 45,
        manaRegen: 7,
        profile: 'balanced',
        smartness: 0.4
    },
    auror: {
        name: 'Bellatrix Lestrange',
        avatar: '\uD83D\uDDA4',
        maxHp: 105,
        maxMana: 55,
        manaRegen: 8,
        profile: 'aggressive',
        smartness: 0.65
    },
    darklord: {
        name: 'Lord Voldemort',
        avatar: '\uD83D\uDC80',
        maxHp: 130,
        maxMana: 70,
        manaRegen: 10,
        profile: 'strategic',
        smartness: 0.85
    },
    deatheater: {
        name: 'Fenrir Greyback',
        avatar: '\uD83D\uDC3A',
        maxHp: 140,
        maxMana: 50,
        manaRegen: 8,
        profile: 'aggressive',
        smartness: 0.7
    },
    legend: {
        name: 'Gellert Grindelwald',
        avatar: '\uD83D\uDD2E',
        maxHp: 150,
        maxMana: 80,
        manaRegen: 12,
        profile: 'strategic',
        smartness: 0.95
    }
};

const SPELLS = [
    {
        id: 'stupefy',
        name: 'Stupefy',
        icon: '\uD83D\uDD34',
        category: 'attack',
        manaCost: 8,
        description: '15 damage',
        effect: (caster, target) => {
            const dmg = calcDamage(15, target);
            applyDamage(target, dmg);
            return { damage: dmg, message: `${caster.name} casts Stupefy for ${dmg} damage!` };
        },
        color: '#e74c3c',
        animType: 'beam'
    },
    {
        id: 'expelliarmus',
        name: 'Expelliarmus',
        icon: '\uD83C\uDF1F',
        category: 'attack',
        manaCost: 10,
        description: '12 dmg + drain 5 mana',
        effect: (caster, target) => {
            const dmg = calcDamage(12, target);
            applyDamage(target, dmg);
            const drained = Math.min(target.mana, 5);
            target.mana -= drained;
            return { damage: dmg, manaDrain: drained, message: `${caster.name} casts Expelliarmus for ${dmg} damage and drains ${drained} mana!` };
        },
        color: '#f39c12',
        animType: 'beam'
    },
    {
        id: 'confringo',
        name: 'Confringo',
        icon: '\uD83D\uDD25',
        category: 'attack',
        manaCost: 18,
        description: '28 dmg, ignores 50% shield',
        effect: (caster, target) => {
            const dmg = calcDamage(28, target, 0.5);
            applyDamage(target, dmg);
            return { damage: dmg, message: `${caster.name} casts Confringo for ${dmg} damage! The blast penetrates shields!` };
        },
        color: '#e67e22',
        animType: 'explosion'
    },
    {
        id: 'sectumsempra',
        name: 'Sectumsempra',
        icon: '\uD83D\uDDE1\uFE0F',
        category: 'attack',
        manaCost: 22,
        description: '20 dmg + 5 bleed/turn x3',
        effect: (caster, target) => {
            const dmg = calcDamage(20, target);
            applyDamage(target, dmg);
            addStatus(target, 'bleed', 3, 5);
            return { damage: dmg, message: `${caster.name} casts Sectumsempra for ${dmg} damage! The target bleeds!` };
        },
        color: '#8b0000',
        animType: 'beam'
    },
    {
        id: 'petrificus',
        name: 'Petrificus Totalus',
        icon: '\u2744\uFE0F',
        category: 'attack',
        manaCost: 14,
        description: '10 dmg + 40% stun',
        effect: (caster, target) => {
            const dmg = calcDamage(10, target);
            applyDamage(target, dmg);
            const stunned = Math.random() < 0.4;
            if (stunned) {
                addStatus(target, 'stun', 1, 0);
            }
            return { damage: dmg, stunned, message: `${caster.name} casts Petrificus Totalus for ${dmg} damage!${stunned ? ' The target is stunned!' : ''}` };
        },
        color: '#9b59b6',
        animType: 'beam'
    },
    {
        id: 'protego',
        name: 'Protego',
        icon: '\uD83D\uDEE1\uFE0F',
        category: 'defense',
        manaCost: 10,
        description: '-70% dmg for 2 turns',
        effect: (caster, target) => {
            addStatus(caster, 'shield', 2, 70);
            return { message: `${caster.name} casts Protego! A magical shield forms!` };
        },
        color: '#3498db',
        animType: 'shield'
    },
    {
        id: 'patronum',
        name: 'Expecto Patronum',
        icon: '\uD83E\uDD8C',
        category: 'defense',
        manaCost: 20,
        description: 'Full block 1 turn + cleanse',
        effect: (caster, target) => {
            addStatus(caster, 'fullblock', 1, 100);
            clearDebuffs(caster);
            return { message: `${caster.name} summons a Patronus! All debuffs are cleansed!` };
        },
        color: '#85c1e9',
        animType: 'patronus'
    },
    {
        id: 'episkey',
        name: 'Episkey',
        icon: '\uD83D\uDC9A',
        category: 'utility',
        manaCost: 12,
        description: 'Heal 20 HP',
        effect: (caster, target) => {
            const healed = Math.min(20, caster.maxHp - caster.hp);
            caster.hp += healed;
            return { healed, message: `${caster.name} casts Episkey and heals ${healed} HP!` };
        },
        color: '#2ecc71',
        animType: 'heal'
    },
    {
        id: 'impedimenta',
        name: 'Impedimenta',
        icon: '\uD83C\uDF00',
        category: 'utility',
        manaCost: 10,
        description: '-50% mana regen 3 turns',
        effect: (caster, target) => {
            addStatus(target, 'manaslow', 3, 50);
            return { message: `${caster.name} casts Impedimenta! Target's mana regeneration is halved!` };
        },
        color: '#8e44ad',
        animType: 'beam'
    },
    {
        id: 'aguamenti',
        name: 'Aguamenti',
        icon: '\uD83D\uDCA7',
        category: 'utility',
        manaCost: 6,
        description: '8 dmg + restore 4 mana',
        effect: (caster, target) => {
            const dmg = calcDamage(8, target);
            applyDamage(target, dmg);
            const restored = Math.min(4, caster.maxMana - caster.mana);
            caster.mana += restored;
            return { damage: dmg, manaRestored: restored, message: `${caster.name} casts Aguamenti for ${dmg} damage and restores ${restored} mana!` };
        },
        color: '#2980b9',
        animType: 'beam'
    },
    { id: 'flipendo', name: 'Flipendo', icon: '\uD83D\uDCA8', category: 'attack', manaCost: 6, description: '10 damage', effect: (caster, target) => { const dmg = calcDamage(10, target); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Flipendo for ${dmg} damage!` }; }, color: '#5dade2', animType: 'beam' },
    { id: 'tarantallegra', name: 'Tarantallegra', icon: '\uD83D\uDC83', category: 'attack', manaCost: 7, description: '6 dmg + 30% stun', effect: (caster, target) => { const dmg = calcDamage(6, target); applyDamage(target, dmg); const stunned = Math.random() < 0.3; if (stunned) addStatus(target, 'stun', 1, 0); return { damage: dmg, stunned, message: `${caster.name} casts Tarantallegra for ${dmg} damage!${stunned ? ' The target dances uncontrollably!' : ''}` }; }, color: '#e91e63', animType: 'beam' },
    { id: 'locomotormortis', name: 'Locomotor Mortis', icon: '\uD83E\uDDBF', category: 'attack', manaCost: 8, description: '8 dmg + slow mana 2 turns', effect: (caster, target) => { const dmg = calcDamage(8, target); applyDamage(target, dmg); addStatus(target, 'manaslow', 2, 40); return { damage: dmg, message: `${caster.name} casts Locomotor Mortis for ${dmg} damage! Target's legs lock together!` }; }, color: '#6c3483', animType: 'beam' },
    { id: 'furnunculus', name: 'Furnunculus', icon: '\uD83E\uDD22', category: 'attack', manaCost: 7, description: '8 dmg + 3 poison/turn x2', effect: (caster, target) => { const dmg = calcDamage(8, target); applyDamage(target, dmg); addStatus(target, 'poison', 2, 3); return { damage: dmg, message: `${caster.name} casts Furnunculus for ${dmg} damage! Boils spread!` }; }, color: '#27ae60', animType: 'beam' },
    { id: 'densaugeo', name: 'Densaugeo', icon: '\uD83E\uDDB7', category: 'attack', manaCost: 6, description: '12 damage', effect: (caster, target) => { const dmg = calcDamage(12, target); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Densaugeo for ${dmg} damage!` }; }, color: '#f1c40f', animType: 'beam' },
    { id: 'rictumsempra', name: 'Rictusempra', icon: '\uD83E\uDD23', category: 'attack', manaCost: 8, description: '7 dmg + drain 4 mana', effect: (caster, target) => { const dmg = calcDamage(7, target); applyDamage(target, dmg); const drained = Math.min(target.mana, 4); target.mana -= drained; return { damage: dmg, manaDrain: drained, message: `${caster.name} casts Rictusempra for ${dmg} damage and drains ${drained} mana!` }; }, color: '#f39c12', animType: 'beam' },
    { id: 'diffindo', name: 'Diffindo', icon: '\u2702\uFE0F', category: 'attack', manaCost: 10, description: '14 dmg + 3 bleed/turn x2', effect: (caster, target) => { const dmg = calcDamage(14, target); applyDamage(target, dmg); addStatus(target, 'bleed', 2, 3); return { damage: dmg, message: `${caster.name} casts Diffindo for ${dmg} damage! A slashing wound opens!` }; }, color: '#c0392b', animType: 'beam' },
    { id: 'incendio', name: 'Incendio', icon: '\uD83D\uDD25', category: 'attack', manaCost: 12, description: '12 dmg + 4 burn/turn x3', effect: (caster, target) => { const dmg = calcDamage(12, target); applyDamage(target, dmg); addStatus(target, 'burn', 3, 4); return { damage: dmg, message: `${caster.name} casts Incendio for ${dmg} damage! The target catches fire!` }; }, color: '#e67e22', animType: 'explosion' },
    { id: 'depulso', name: 'Depulso', icon: '\uD83D\uDCA5', category: 'attack', manaCost: 11, description: '18 damage', effect: (caster, target) => { const dmg = calcDamage(18, target); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Depulso for ${dmg} damage! A powerful banishing force!` }; }, color: '#3498db', animType: 'beam' },
    { id: 'levicorpus', name: 'Levicorpus', icon: '\uD83E\uDD38', category: 'attack', manaCost: 10, description: '10 dmg + 50% stun', effect: (caster, target) => { const dmg = calcDamage(10, target); applyDamage(target, dmg); const stunned = Math.random() < 0.5; if (stunned) addStatus(target, 'stun', 1, 0); return { damage: dmg, stunned, message: `${caster.name} casts Levicorpus for ${dmg} damage!${stunned ? ' The target is hoisted upside-down!' : ''}` }; }, color: '#9b59b6', animType: 'beam' },
    { id: 'glacius', name: 'Glacius', icon: '\u2744\uFE0F', category: 'attack', manaCost: 13, description: '16 dmg + slow mana 2 turns', effect: (caster, target) => { const dmg = calcDamage(16, target); applyDamage(target, dmg); addStatus(target, 'manaslow', 2, 50); return { damage: dmg, message: `${caster.name} casts Glacius for ${dmg} damage! Ice freezes the target's magic!` }; }, color: '#85c1e9', animType: 'beam' },
    { id: 'oppugno', name: 'Oppugno', icon: '\uD83D\uDC26', category: 'attack', manaCost: 11, description: '20 damage', effect: (caster, target) => { const dmg = calcDamage(20, target); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Oppugno for ${dmg} damage! Conjured creatures attack!` }; }, color: '#e74c3c', animType: 'explosion' },
    { id: 'langlock', name: 'Langlock', icon: '\uD83E\uDD10', category: 'attack', manaCost: 10, description: '8 dmg + drain 8 mana', effect: (caster, target) => { const dmg = calcDamage(8, target); applyDamage(target, dmg); const drained = Math.min(target.mana, 8); target.mana -= drained; return { damage: dmg, manaDrain: drained, message: `${caster.name} casts Langlock for ${dmg} damage and drains ${drained} mana!` }; }, color: '#8e44ad', animType: 'beam' },
    { id: 'obscuro', name: 'Obscuro', icon: '\uD83C\uDF11', category: 'attack', manaCost: 12, description: '10 dmg + 45% stun', effect: (caster, target) => { const dmg = calcDamage(10, target); applyDamage(target, dmg); const stunned = Math.random() < 0.45; if (stunned) addStatus(target, 'stun', 1, 0); return { damage: dmg, stunned, message: `${caster.name} casts Obscuro for ${dmg} damage!${stunned ? ' A blindfold covers the target!' : ''}` }; }, color: '#2c3e50', animType: 'beam' },
    { id: 'confundo', name: 'Confundo', icon: '\uD83D\uDE35', category: 'attack', manaCost: 14, description: '6 dmg + stun + slow 2 turns', effect: (caster, target) => { const dmg = calcDamage(6, target); applyDamage(target, dmg); addStatus(target, 'stun', 1, 0); addStatus(target, 'manaslow', 2, 40); return { damage: dmg, stunned: true, message: `${caster.name} casts Confundo for ${dmg} damage! The target is utterly confused!` }; }, color: '#f1c40f', animType: 'beam' },
    { id: 'reducto', name: 'Reducto', icon: '\uD83D\uDCA3', category: 'attack', manaCost: 15, description: '25 damage', effect: (caster, target) => { const dmg = calcDamage(25, target); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Reducto for ${dmg} damage! Objects explode violently!` }; }, color: '#e74c3c', animType: 'explosion' },
    { id: 'relashio', name: 'Relashio', icon: '\u2728', category: 'attack', manaCost: 12, description: '14 dmg + 3 burn/turn x2', effect: (caster, target) => { const dmg = calcDamage(14, target); applyDamage(target, dmg); addStatus(target, 'burn', 2, 3); return { damage: dmg, message: `${caster.name} casts Relashio for ${dmg} damage! Burning sparks fly!` }; }, color: '#e67e22', animType: 'beam' },
    { id: 'expulso', name: 'Expulso', icon: '\uD83D\uDCA5', category: 'attack', manaCost: 18, description: '30 damage', effect: (caster, target) => { const dmg = calcDamage(30, target); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Expulso for ${dmg} damage! A massive explosion!` }; }, color: '#c0392b', animType: 'explosion' },
    { id: 'bombarda', name: 'Bombarda', icon: '\uD83D\uDCA3', category: 'attack', manaCost: 16, description: '22 dmg, ignores 40% shield', effect: (caster, target) => { const dmg = calcDamage(22, target, 0.4); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Bombarda for ${dmg} damage! The blast shatters defenses!` }; }, color: '#d35400', animType: 'explosion' },
    { id: 'serpensortia', name: 'Serpensortia', icon: '\uD83D\uDC0D', category: 'attack', manaCost: 16, description: '18 dmg + 4 poison/turn x3', effect: (caster, target) => { const dmg = calcDamage(18, target); applyDamage(target, dmg); addStatus(target, 'poison', 3, 4); return { damage: dmg, message: `${caster.name} casts Serpensortia for ${dmg} damage! A venomous serpent attacks!` }; }, color: '#27ae60', animType: 'beam' },
    { id: 'morsmordre', name: 'Morsmordre', icon: '\uD83D\uDC80', category: 'attack', manaCost: 20, description: '22 dmg + 5 burn/turn x3', effect: (caster, target) => { const dmg = calcDamage(22, target); applyDamage(target, dmg); addStatus(target, 'burn', 3, 5); return { damage: dmg, message: `${caster.name} casts Morsmordre for ${dmg} damage! The Dark Mark sears the target!` }; }, color: '#1a5276', animType: 'explosion' },
    { id: 'incarcerous', name: 'Incarcerous', icon: '\u26D3\uFE0F', category: 'attack', manaCost: 17, description: '12 dmg + stun + bleed 3/turn x2', effect: (caster, target) => { const dmg = calcDamage(12, target); applyDamage(target, dmg); addStatus(target, 'stun', 1, 0); addStatus(target, 'bleed', 2, 3); return { damage: dmg, stunned: true, message: `${caster.name} casts Incarcerous for ${dmg} damage! Ropes bind and cut the target!` }; }, color: '#7d6608', animType: 'beam' },
    { id: 'bombardamaxima', name: 'Bombarda Maxima', icon: '\uD83C\uDF86', category: 'attack', manaCost: 24, description: '35 dmg, ignores 60% shield', effect: (caster, target) => { const dmg = calcDamage(35, target, 0.6); applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Bombarda Maxima for ${dmg} damage! A devastating explosion!` }; }, color: '#e74c3c', animType: 'explosion' },
    { id: 'crucio', name: 'Crucio', icon: '\u26A0\uFE0F', category: 'attack', manaCost: 28, description: '25 dmg + stun + 6 burn/turn x2', effect: (caster, target) => { const dmg = calcDamage(25, target); applyDamage(target, dmg); addStatus(target, 'stun', 1, 0); addStatus(target, 'burn', 2, 6); return { damage: dmg, stunned: true, message: `${caster.name} casts Crucio for ${dmg} damage! An Unforgivable Curse!` }; }, color: '#8b0000', animType: 'beam' },
    { id: 'fiendfyre', name: 'Fiendfyre', icon: '\uD83D\uDD25', category: 'attack', manaCost: 35, description: '45 dmg + 8 burn/turn x3. Self: 10 dmg', effect: (caster, target) => { const dmg = calcDamage(45, target); applyDamage(target, dmg); addStatus(target, 'burn', 3, 8); caster.hp = Math.max(1, caster.hp - 10); return { damage: dmg, message: `${caster.name} unleashes Fiendfyre for ${dmg} damage! Cursed flames engulf everything! (10 self-damage)` }; }, color: '#c0392b', animType: 'explosion' },
    { id: 'avadakedavra', name: 'Avada Kedavra', icon: '\uD83D\uDC80', category: 'attack', manaCost: 45, description: '60 dmg, ignores ALL shields', effect: (caster, target) => { const dmg = 60; applyDamage(target, dmg); return { damage: dmg, message: `${caster.name} casts Avada Kedavra for ${dmg} damage! The Killing Curse!` }; }, color: '#2ecc71', animType: 'beam' },
    { id: 'salviohexia', name: 'Salvio Hexia', icon: '\uD83D\uDD36', category: 'defense', manaCost: 14, description: '-50% dmg for 3 turns', effect: (caster, target) => { addStatus(caster, 'shield', 3, 50); return { message: `${caster.name} casts Salvio Hexia! A protective ward shimmers!` }; }, color: '#2980b9', animType: 'shield' },
    { id: 'caveinimicum', name: 'Cave Inimicum', icon: '\uD83C\uDFF0', category: 'defense', manaCost: 16, description: '-80% dmg for 1 turn', effect: (caster, target) => { addStatus(caster, 'shield', 1, 80); return { message: `${caster.name} casts Cave Inimicum! A powerful barrier!` }; }, color: '#1abc9c', animType: 'shield' },
    { id: 'finiteincantatem', name: 'Finite Incantatem', icon: '\u274C', category: 'defense', manaCost: 15, description: 'Remove debuffs + strip enemy buffs', effect: (caster, target) => { clearDebuffs(caster); target.statuses = target.statuses.filter(s => s.type !== 'shield' && s.type !== 'fullblock'); return { message: `${caster.name} casts Finite Incantatem! All enchantments dispelled!` }; }, color: '#ecf0f1', animType: 'explosion' },
    { id: 'riddikulus', name: 'Riddikulus', icon: '\uD83E\uDD21', category: 'defense', manaCost: 12, description: '10 dmg + shield -40% for 2 turns', effect: (caster, target) => { const dmg = calcDamage(10, target); applyDamage(target, dmg); addStatus(caster, 'shield', 2, 40); return { damage: dmg, message: `${caster.name} casts Riddikulus for ${dmg} damage! Laughter is the best defense!` }; }, color: '#f39c12', animType: 'shield' },
    { id: 'lumosmaxima', name: 'Lumos Maxima', icon: '\uD83D\uDCA1', category: 'utility', manaCost: 4, description: '5 dmg + restore 3 mana', effect: (caster, target) => { const dmg = calcDamage(5, target); applyDamage(target, dmg); const restored = Math.min(3, caster.maxMana - caster.mana); caster.mana += restored; return { damage: dmg, manaRestored: restored, message: `${caster.name} casts Lumos Maxima for ${dmg} damage!` }; }, color: '#f9e79f', animType: 'beam' },
    { id: 'rennervate', name: 'Rennervate', icon: '\u2764\uFE0F', category: 'utility', manaCost: 8, description: 'Heal 15 HP + cleanse debuffs', effect: (caster, target) => { const healed = Math.min(15, caster.maxHp - caster.hp); caster.hp += healed; clearDebuffs(caster); return { healed, message: `${caster.name} casts Rennervate! Heals ${healed} HP and cleanses debuffs!` }; }, color: '#e74c3c', animType: 'heal' },
    { id: 'ferula', name: 'Ferula', icon: '\uD83E\uDE79', category: 'utility', manaCost: 14, description: 'Heal 18 HP + shield -30% for 2 turns', effect: (caster, target) => { const healed = Math.min(18, caster.maxHp - caster.hp); caster.hp += healed; addStatus(caster, 'shield', 2, 30); return { healed, message: `${caster.name} casts Ferula! Heals ${healed} HP with protection!` }; }, color: '#f5cba7', animType: 'heal' },
    { id: 'vulnerasanentur', name: 'Vulnera Sanentur', icon: '\uD83C\uDF1F', category: 'utility', manaCost: 20, description: 'Heal 35 HP', effect: (caster, target) => { const healed = Math.min(35, caster.maxHp - caster.hp); caster.hp += healed; return { healed, message: `${caster.name} casts Vulnera Sanentur! Heals ${healed} HP!` }; }, color: '#2ecc71', animType: 'heal' },
    { id: 'wiggenweld', name: 'Wiggenweld', icon: '\uD83E\uDDEA', category: 'utility', manaCost: 5, description: 'Heal 10 HP', effect: (caster, target) => { const healed = Math.min(10, caster.maxHp - caster.hp); caster.hp += healed; return { healed, message: `${caster.name} drinks Wiggenweld Potion! Heals ${healed} HP!` }; }, color: '#58d68d', animType: 'heal' },
    { id: 'accio', name: 'Accio', icon: '\uD83E\uDDF2', category: 'utility', manaCost: 8, description: 'Drain 10 mana from target', effect: (caster, target) => { const drained = Math.min(target.mana, 10); target.mana -= drained; const restored = Math.min(drained, caster.maxMana - caster.mana); caster.mana += restored; return { manaDrain: drained, manaRestored: restored, message: `${caster.name} casts Accio! Steals ${drained} mana!` }; }, color: '#3498db', animType: 'beam' },
    { id: 'reparo', name: 'Reparo', icon: '\uD83D\uDD27', category: 'utility', manaCost: 10, description: 'Heal 12 HP + restore 5 mana', effect: (caster, target) => { const healed = Math.min(12, caster.maxHp - caster.hp); caster.hp += healed; const restored = Math.min(5, caster.maxMana - caster.mana); caster.mana += restored; return { healed, manaRestored: restored, message: `${caster.name} casts Reparo! Heals ${healed} HP and restores ${restored} mana!` }; }, color: '#5dade2', animType: 'heal' }
];

// ========== GAME STATE ==========

let gameState = {
    selectedChar: 'harry',
    selectedChar2: 'hermione',
    selectedDiff: 'apprentice',
    gameMode: 'solo',
    planningFor: 1,
    player: null,
    opponent: null,
    turn: 1,
    isPlayerTurn: true,
    isAnimating: false,
    gameOver: false,
    spellQueue: [],
    spellQueue2: [],
    queueIndex: 0,
    queueIndex2: 0,
    battleSpeed: 10,
    stats: {
        damageDealt: 0,
        damageTaken: 0,
        spellsCast: 0,
        healingDone: 0,
        turnsPlayed: 0
    }
};

// ========== HELPER FUNCTIONS ==========

function calcDamage(baseDamage, target, shieldPenPercent) {
    let reduction = 0;
    const shieldStatus = getStatus(target, 'shield');
    const fullBlock = getStatus(target, 'fullblock');

    if (fullBlock) {
        return 0;
    }

    if (shieldStatus) {
        const shieldPercent = shieldStatus.value;
        const pen = shieldPenPercent || 0;
        reduction = shieldPercent * (1 - pen);
    }

    const finalDamage = Math.max(1, Math.round(baseDamage * (1 - reduction / 100)));
    return finalDamage;
}

function applyDamage(target, dmg) {
    target.hp = Math.max(0, target.hp - dmg);
}

function addStatus(entity, type, duration, value) {
    const existing = entity.statuses.find(s => s.type === type);
    if (existing) {
        existing.duration = Math.max(existing.duration, duration);
        existing.value = value;
    } else {
        entity.statuses.push({ type, duration, value });
    }
}

function getStatus(entity, type) {
    return entity.statuses.find(s => s.type === type);
}

function clearDebuffs(entity) {
    entity.statuses = entity.statuses.filter(s =>
        s.type === 'shield' || s.type === 'fullblock'
    );
}

function tickStatuses(entity) {
    const messages = [];

    entity.statuses.forEach(status => {
        if (status.type === 'bleed' && status.duration > 0) {
            const bleedDmg = status.value;
            entity.hp = Math.max(0, entity.hp - bleedDmg);
            messages.push({ text: `${entity.name} takes ${bleedDmg} bleed damage!`, type: 'system' });
        }
        if (status.type === 'burn' && status.duration > 0) {
            const burnDmg = status.value;
            entity.hp = Math.max(0, entity.hp - burnDmg);
            messages.push({ text: `${entity.name} takes ${burnDmg} burn damage!`, type: 'system' });
        }
        if (status.type === 'poison' && status.duration > 0) {
            const poisonDmg = status.value;
            entity.hp = Math.max(0, entity.hp - poisonDmg);
            messages.push({ text: `${entity.name} takes ${poisonDmg} poison damage!`, type: 'system' });
        }
    });

    entity.statuses = entity.statuses.filter(s => {
        s.duration--;
        return s.duration > 0;
    });

    return messages;
}

function regenMana(entity) {
    let regen = entity.manaRegen;
    const manaslow = getStatus(entity, 'manaslow');
    if (manaslow) {
        regen = Math.floor(regen * (1 - manaslow.value / 100));
    }
    entity.mana = Math.min(entity.maxMana, entity.mana + regen);
    return regen;
}

function isStunned(entity) {
    return !!getStatus(entity, 'stun');
}

function createEntity(template) {
    return {
        name: template.name,
        avatar: template.avatar,
        hp: template.maxHp,
        maxHp: template.maxHp,
        mana: template.maxMana,
        maxMana: template.maxMana,
        manaRegen: template.manaRegen,
        statuses: [],
        profile: template.profile || 'balanced',
        smartness: template.smartness || 0
    };
}

// ========== SPEED CONTROL ==========

function getDelay(base) {
    return Math.round(base / gameState.battleSpeed);
}

function setSpeed(speed) {
    gameState.battleSpeed = speed;
    document.querySelectorAll('.speed-btn').forEach(btn => {
        btn.classList.toggle('active', parseFloat(btn.dataset.speed) === speed);
    });
}

// ========== FUZZY SPELL MATCHING ==========

function levenshtein(a, b) {
    const m = a.length, n = b.length;
    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
    for (let i = 0; i <= m; i++) dp[i][0] = i;
    for (let j = 0; j <= n; j++) dp[0][j] = j;
    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            dp[i][j] = Math.min(
                dp[i-1][j] + 1,
                dp[i][j-1] + 1,
                dp[i-1][j-1] + (a[i-1] !== b[j-1] ? 1 : 0)
            );
        }
    }
    return dp[m][n];
}

function matchSpell(input) {
    input = input.trim().toLowerCase();
    if (!input) return null;

    // Check "wait"
    if (input === 'wait') return { id: 'wait', corrected: false };

    // Exact match on spell id
    const exactId = SPELLS.find(s => s.id === input);
    if (exactId) return { id: exactId.id, corrected: false };

    // Exact match on full spell name
    const exactName = SPELLS.find(s => s.name.toLowerCase() === input);
    if (exactName) return { id: exactName.id, corrected: false };

    // Partial match: input is contained in name or name contains input
    const partial = SPELLS.find(s =>
        s.name.toLowerCase().includes(input) && input.length >= 3
    );
    if (partial) return { id: partial.id, corrected: false };

    // Build candidate list for fuzzy matching
    const candidates = [];
    SPELLS.forEach(s => {
        candidates.push({ key: s.id, spell: s });
        candidates.push({ key: s.name.toLowerCase(), spell: s });
    });
    // Common aliases
    candidates.push({ key: 'patronus', spell: SPELLS.find(s => s.id === 'patronum') });
    candidates.push({ key: 'expecto', spell: SPELLS.find(s => s.id === 'patronum') });
    candidates.push({ key: 'sectum', spell: SPELLS.find(s => s.id === 'sectumsempra') });
    candidates.push({ key: 'petrificus totalus', spell: SPELLS.find(s => s.id === 'petrificus') });
    candidates.push({ key: 'expecto patronum', spell: SPELLS.find(s => s.id === 'patronum') });
    candidates.push({ key: 'heal', spell: SPELLS.find(s => s.id === 'episkey') });
    candidates.push({ key: 'shield', spell: SPELLS.find(s => s.id === 'protego') });
    candidates.push({ key: 'block', spell: SPELLS.find(s => s.id === 'protego') });
    // New spell aliases
    candidates.push({ key: 'locomotor', spell: SPELLS.find(s => s.id === 'locomotormortis') });
    candidates.push({ key: 'bombarda max', spell: SPELLS.find(s => s.id === 'bombardamaxima') });
    candidates.push({ key: 'avada', spell: SPELLS.find(s => s.id === 'avadakedavra') });
    candidates.push({ key: 'killing curse', spell: SPELLS.find(s => s.id === 'avadakedavra') });
    candidates.push({ key: 'avada kedavra', spell: SPELLS.find(s => s.id === 'avadakedavra') });
    candidates.push({ key: 'lumos', spell: SPELLS.find(s => s.id === 'lumosmaxima') });
    candidates.push({ key: 'salvio', spell: SPELLS.find(s => s.id === 'salviohexia') });
    candidates.push({ key: 'cave', spell: SPELLS.find(s => s.id === 'caveinimicum') });
    candidates.push({ key: 'finite', spell: SPELLS.find(s => s.id === 'finiteincantatem') });
    candidates.push({ key: 'vulnera', spell: SPELLS.find(s => s.id === 'vulnerasanentur') });
    candidates.push({ key: 'potion', spell: SPELLS.find(s => s.id === 'wiggenweld') });
    candidates.push({ key: 'fire', spell: SPELLS.find(s => s.id === 'incendio') });
    candidates.push({ key: 'ice', spell: SPELLS.find(s => s.id === 'glacius') });
    candidates.push({ key: 'freeze', spell: SPELLS.find(s => s.id === 'glacius') });
    candidates.push({ key: 'snake', spell: SPELLS.find(s => s.id === 'serpensortia') });
    candidates.push({ key: 'dark mark', spell: SPELLS.find(s => s.id === 'morsmordre') });
    candidates.push({ key: 'torture', spell: SPELLS.find(s => s.id === 'crucio') });
    candidates.push({ key: 'cursed fire', spell: SPELLS.find(s => s.id === 'fiendfyre') });
    candidates.push({ key: 'mana steal', spell: SPELLS.find(s => s.id === 'accio') });
    candidates.push({ key: 'cleanse', spell: SPELLS.find(s => s.id === 'rennervate') });
    candidates.push({ key: 'dispel', spell: SPELLS.find(s => s.id === 'finiteincantatem') });
    candidates.push({ key: 'bandage', spell: SPELLS.find(s => s.id === 'ferula') });
    candidates.push({ key: 'bigheal', spell: SPELLS.find(s => s.id === 'vulnerasanentur') });

    let bestMatch = null;
    let bestDist = Infinity;

    for (const c of candidates) {
        if (!c.spell) continue;
        const dist = levenshtein(input, c.key);
        // Allow up to 40% of the key length as errors, minimum 2
        const threshold = Math.max(2, Math.floor(c.key.length * 0.4));
        if (dist < bestDist && dist <= threshold) {
            bestDist = dist;
            bestMatch = c.spell;
        }
    }

    if (bestMatch) return { id: bestMatch.id, corrected: true, correctedName: bestMatch.name };

    return null;
}

// ========== UI FUNCTIONS ==========

function selectCharacter(charId) {
    gameState.selectedChar = charId;
    document.querySelectorAll('.char-card').forEach(card => {
        card.classList.toggle('selected', card.dataset.char === charId);
    });
}

function selectDifficulty(diff) {
    gameState.selectedDiff = diff;
    document.querySelectorAll('.diff-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.diff === diff);
    });
}

function selectMode(mode) {
    gameState.gameMode = mode;
    document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.classList.toggle('selected', btn.dataset.mode === mode);
    });
    const diffSection = document.getElementById('difficulty-section');
    const p2Section = document.getElementById('p2-section');
    if (mode === '2player') {
        diffSection.style.display = 'none';
        p2Section.classList.remove('hidden');
        renderP2CharGrid();
    } else {
        diffSection.style.display = '';
        p2Section.classList.add('hidden');
    }
}

function selectCharP2(charId) {
    gameState.selectedChar2 = charId;
    document.querySelectorAll('.p2-char-card').forEach(card => {
        card.classList.toggle('selected', card.dataset.char === charId);
    });
}

function renderP2CharGrid() {
    const grid = document.getElementById('p2-char-grid');
    grid.innerHTML = '';
    Object.entries(CHARACTERS).forEach(([id, ch]) => {
        const card = document.createElement('div');
        card.className = 'p2-char-card' + (id === gameState.selectedChar2 ? ' selected' : '');
        card.dataset.char = id;
        card.onclick = () => selectCharP2(id);
        card.innerHTML = '<div class="char-avatar">' + ch.avatar + '</div>'
            + '<div class="char-name">' + ch.name + '</div>'
            + '<div class="char-trait">' + ch.trait + '</div>'
            + '<div class="char-stats">HP: <span>' + ch.maxHp + '</span> | Mana: <span>' + ch.maxMana + '</span><br>Regen: <span>' + ch.manaRegen + '</span>/turn</div>';
        grid.appendChild(card);
    });
}

function showScreen(screenId) {
    ['title-screen', 'planning-screen', 'battle-screen', 'result-screen'].forEach(id => {
        const el = document.getElementById(id);
        el.style.display = id === screenId ? 'flex' : 'none';
    });
}

function updateBars() {
    const p = gameState.player;
    const o = gameState.opponent;

    // Player bars
    const pHpPct = (p.hp / p.maxHp) * 100;
    const pHpBar = document.getElementById('player-hp-bar');
    pHpBar.style.width = pHpPct + '%';
    pHpBar.className = 'bar-fill ' + (pHpPct > 50 ? 'hp-bar-safe' : pHpPct > 25 ? 'hp-bar-warn' : 'hp-bar');
    document.getElementById('player-hp-text').textContent = `${p.hp}/${p.maxHp}`;

    const pManaPct = (p.mana / p.maxMana) * 100;
    document.getElementById('player-mana-bar').style.width = pManaPct + '%';
    document.getElementById('player-mana-text').textContent = `${p.mana}/${p.maxMana}`;

    // Opponent bars
    const oHpPct = (o.hp / o.maxHp) * 100;
    const oHpBar = document.getElementById('opponent-hp-bar');
    oHpBar.style.width = oHpPct + '%';
    oHpBar.className = 'bar-fill ' + (oHpPct > 50 ? 'hp-bar-safe' : oHpPct > 25 ? 'hp-bar-warn' : 'hp-bar');
    document.getElementById('opponent-hp-text').textContent = `${o.hp}/${o.maxHp}`;

    const oManaPct = (o.mana / o.maxMana) * 100;
    document.getElementById('opponent-mana-bar').style.width = oManaPct + '%';

    // Turn
    document.getElementById('turn-number').textContent = gameState.turn;

    // Statuses
    updateStatusBadges('player-statuses', p.statuses);
    updateStatusBadges('opponent-statuses', o.statuses);
}

function updateStatusBadges(containerId, statuses) {
    const container = document.getElementById(containerId);
    container.innerHTML = '';
    statuses.forEach(s => {
        const badge = document.createElement('div');
        const isDebuff = ['bleed', 'burn', 'poison', 'manaslow', 'stun'].includes(s.type);
        const isBuff = ['shield', 'fullblock'].includes(s.type);
        badge.className = 'status-badge ' + (isDebuff ? 'debuff' : isBuff ? 'buff' : '');

        const labels = {
            shield: '\uD83D\uDEE1\uFE0F Protego',
            fullblock: '\uD83E\uDD8C Patronus',
            bleed: '\uD83E\uDE78 Bleed',
            burn: '\uD83D\uDD25 Burn',
            poison: '\uD83D\uDC0D Poison',
            manaslow: '\uD83C\uDF00 Impeded',
            stun: '\u26A1 Stunned'
        };

        badge.textContent = `${labels[s.type] || s.type} (${s.duration})`;
        container.appendChild(badge);
    });
}

function addLogEntry(text, type) {
    const log = document.getElementById('battle-log');
    const entry = document.createElement('div');
    entry.className = 'log-entry ' + (type || '');
    entry.textContent = text;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

// ========== QUEUE HELPERS ==========

function getCurrentQueue() {
    if (gameState.gameMode === '2player' && gameState.planningFor === 2) {
        return gameState.spellQueue2;
    }
    return gameState.spellQueue;
}

// ========== PLANNING SCREEN ==========

function renderPlanningScreen() {
    const is2p = gameState.gameMode === '2player';
    const planFor = gameState.planningFor;
    const charId = planFor === 1 ? gameState.selectedChar : gameState.selectedChar2;
    const charData = CHARACTERS[charId];

    const headerEl = document.querySelector('.planning-header .title-sub');
    if (is2p) {
        headerEl.textContent = planFor === 1 ? 'Player 1 - Plan Your Spells' : 'Player 2 - Plan Your Spells';
        headerEl.style.color = planFor === 1 ? 'var(--gold-light)' : '#ff8888';
    } else {
        headerEl.textContent = 'Plan Your Spells';
        headerEl.style.color = '';
    }

    document.getElementById('planning-mana-info').textContent =
        `${charData.name} | Starting Mana: ${charData.maxMana} | Regen: ${charData.manaRegen}/turn`;

    // Render clickable spell cards
    const ref = document.getElementById('spell-reference');
    ref.innerHTML = '';

    // Wait option
    const waitCard = document.createElement('div');
    waitCard.className = 'plan-spell-card wait-card';
    waitCard.innerHTML = `<div class="plan-icon">\u23F3</div><div class="plan-name">Wait</div><div class="plan-cost">0 \uD83D\uDD35</div><div class="plan-desc">Skip turn</div>`;
    waitCard.addEventListener('click', () => {
        getCurrentQueue().push('wait');
        waitCard.classList.remove('just-added');
        void waitCard.offsetWidth;
        waitCard.classList.add('just-added');
        updateQueueDisplay();
    });
    ref.appendChild(waitCard);

    SPELLS.forEach(spell => {
        const card = document.createElement('div');
        card.className = `plan-spell-card ${spell.category}`;
        card.dataset.spellId = spell.id;
        card.innerHTML = `<div class="plan-icon">${spell.icon}</div><div class="plan-name">${spell.name}</div><div class="plan-cost">${spell.manaCost} \uD83D\uDD35</div><div class="plan-desc">${spell.description}</div><div class="plan-uses">5/5</div>`;
        card.addEventListener('click', () => {
            const count = getCurrentQueue().filter(id => id === spell.id).length;
            if (count >= 5) return;
            getCurrentQueue().push(spell.id);
            card.classList.remove('just-added');
            void card.offsetWidth;
            card.classList.add('just-added');
            updateQueueDisplay();
        });
        ref.appendChild(card);
    });

    updateQueueDisplay();

    // Update battle button text for 2p mode
    const startBtn = document.getElementById('start-battle-btn');
    if (is2p && planFor === 1) {
        startBtn.textContent = 'Player 2\'s Turn';
    } else {
        startBtn.textContent = 'Begin Duel';
    }
}

function removeFromQueue(index) {
    getCurrentQueue().splice(index, 1);
    updateQueueDisplay();
}

function clearQueue() {
    if (gameState.gameMode === '2player' && gameState.planningFor === 2) {
        gameState.spellQueue2 = [];
    } else {
        gameState.spellQueue = [];
    }
    updateQueueDisplay();
}

function updateQueueDisplay() {
    const container = document.getElementById('spell-queue');
    container.innerHTML = '';

    const queue = getCurrentQueue();
    if (queue.length === 0) {
        container.innerHTML = '<div style="color: var(--text-dim); font-style: italic; padding: 10px;">No spells queued yet</div>';
    } else {
        queue.forEach((spellId, i) => {
            const item = document.createElement('div');
            item.className = 'queue-item';

            if (spellId === 'wait') {
                item.innerHTML = `<div class="queue-number">${i + 1}</div><div class="queue-icon">\u23F3</div><div class="queue-name">Wait</div>`;
            } else {
                const spell = SPELLS.find(s => s.id === spellId);
                item.innerHTML = `<div class="queue-number">${i + 1}</div><div class="queue-icon">${spell.icon}</div><div class="queue-name">${spell.name}</div>`;
            }

            item.addEventListener('click', () => removeFromQueue(i));
            container.appendChild(item);
        });
    }

    updateManaPreview();
    updateSpellCardUsages();

    const startBtn = document.getElementById('start-battle-btn');
    startBtn.style.opacity = getCurrentQueue().length > 0 ? '1' : '0.5';
    const is2p = gameState.gameMode === '2player';
    if (is2p && gameState.planningFor === 1) {
        startBtn.textContent = 'Player 2\'s Turn';
    } else {
        startBtn.textContent = 'Begin Duel';
    }
}

function updateSpellCardUsages() {
    const cards = document.querySelectorAll('.plan-spell-card[data-spell-id]');
    cards.forEach(card => {
        const spellId = card.dataset.spellId;
        const used = getCurrentQueue().filter(id => id === spellId).length;
        const remaining = 5 - used;
        const usesEl = card.querySelector('.plan-uses');
        if (usesEl) usesEl.textContent = `${remaining}/5`;
        card.classList.toggle('maxed', used >= 5);
    });
}

function updateManaPreview() {
    const charId = (gameState.gameMode === '2player' && gameState.planningFor === 2)
        ? gameState.selectedChar2 : gameState.selectedChar;
    const charData = CHARACTERS[charId];
    const preview = document.getElementById('queue-mana-preview');
    const queue = getCurrentQueue();

    if (queue.length === 0) {
        preview.innerHTML = '';
        return;
    }

    let mana = charData.maxMana;
    let html = 'Mana: ';

    queue.forEach((spellId, i) => {
        if (i > 0) {
            mana = Math.min(charData.maxMana, mana + charData.manaRegen);
        }

        if (spellId === 'wait') {
            html += `<span class="mana-ok">[${i+1}:\u23F3 ${mana}]</span> `;
        } else {
            const spell = SPELLS.find(s => s.id === spellId);
            const afterCast = mana - spell.manaCost;
            const cls = afterCast >= 0 ? 'mana-ok' : 'mana-bad';
            html += `<span class="${cls}">[${i+1}:${spell.icon} ${mana}\u2192${afterCast}]</span> `;
            if (afterCast >= 0) mana = afterCast;
        }
    });

    preview.innerHTML = html;
}


// ========== BATTLE QUEUE DISPLAY ==========

function renderBattleQueue() {
    const hand = document.getElementById('spell-hand');
    hand.innerHTML = '<div class="queue-label">Spell Queue</div><div class="battle-queue" id="battle-queue-display"></div>';
    updateBattleQueue();
}

function updateBattleQueue() {
    const container = document.getElementById('battle-queue-display');
    if (!container) return;
    container.innerHTML = '';

    gameState.spellQueue.forEach((spellId, i) => {
        const item = document.createElement('span');
        item.className = 'battle-queue-item';

        if (i < gameState.queueIndex - 1) {
            item.classList.add('used');
        } else if (i === gameState.queueIndex - 1) {
            item.classList.add('current');
        }

        if (spellId === 'wait') {
            item.textContent = '\u23F3';
        } else {
            const spell = SPELLS.find(s => s.id === spellId);
            item.textContent = spell.icon;
        }

        container.appendChild(item);
    });
}

// ========== ANIMATION FUNCTIONS ==========

function getArenaRect() {
    return document.getElementById('battle-arena').getBoundingClientRect();
}

function getPlayerPos() {
    const sprite = document.getElementById('player-sprite');
    const rect = sprite.getBoundingClientRect();
    return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
}

function getOpponentPos() {
    const sprite = document.getElementById('opponent-sprite');
    const rect = sprite.getBoundingClientRect();
    return { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
}

// ========== CANVAS PARTICLE SPELL SYSTEM ==========

function hexToRgb(hex) {
    const r = parseInt(hex.slice(1,3), 16);
    const g = parseInt(hex.slice(3,5), 16);
    const b = parseInt(hex.slice(5,7), 16);
    return { r, g, b };
}

function initSpellCanvas() {
    const canvas = document.getElementById('spell-canvas');
    if (!canvas) return;
    const arena = document.getElementById('battle-arena');
    canvas.width = arena.offsetWidth;
    canvas.height = arena.offsetHeight;
}

function screenFlash(color, duration) {
    const flash = document.getElementById('screen-flash');
    if (!flash) return;
    flash.style.background = color;
    flash.style.opacity = '0.35';
    setTimeout(() => { flash.style.opacity = '0'; }, duration || 80);
}

function playSpellAnimation(spell, fromPlayer) {
    return new Promise(resolve => {
        const canvas = document.getElementById('spell-canvas');
        const arena = document.getElementById('battle-arena');
        if (!canvas || !arena) { resolve(); return; }

        canvas.width = arena.offsetWidth;
        canvas.height = arena.offsetHeight;
        const ctx = canvas.getContext('2d');
        const arenaRect = arena.getBoundingClientRect();

        const fromPos = fromPlayer ? getPlayerPos() : getOpponentPos();
        const toPos = fromPlayer ? getOpponentPos() : getPlayerPos();
        const fx = fromPos.x - arenaRect.left;
        const fy = fromPos.y - arenaRect.top;
        const tx = toPos.x - arenaRect.left;
        const ty = toPos.y - arenaRect.top;

        const rgb = hexToRgb(spell.color);
        const particles = [];
        let startTime = performance.now();
        let animId = null;

        switch (spell.animType) {
            case 'beam': {
                // Glowing bolt projectile with trail particles and impact sparks
                const duration = 700;
                const boltSpeed = 0.65; // fraction of duration for bolt travel
                const dx = tx - fx, dy = ty - fy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const angle = Math.atan2(dy, dx);

                // Trail particles spawned along path
                for (let i = 0; i < 40; i++) {
                    particles.push({
                        born: Math.random() * duration * boltSpeed,
                        life: 200 + Math.random() * 300,
                        x: 0, y: 0, // set at spawn
                        vx: (Math.random() - 0.5) * 1.5,
                        vy: (Math.random() - 0.5) * 1.5,
                        size: 1.5 + Math.random() * 3,
                        alpha: 0.6 + Math.random() * 0.4,
                        r: rgb.r, g: rgb.g, b: rgb.b,
                        spawned: false,
                        type: 'trail'
                    });
                }
                // Impact sparks
                for (let i = 0; i < 25; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const sp = 1 + Math.random() * 4;
                    particles.push({
                        born: duration * boltSpeed,
                        life: 150 + Math.random() * 250,
                        x: tx, y: ty,
                        vx: Math.cos(a) * sp,
                        vy: Math.sin(a) * sp,
                        size: 1 + Math.random() * 2.5,
                        alpha: 0.8,
                        r: Math.min(255, rgb.r + 80), g: Math.min(255, rgb.g + 80), b: Math.min(255, rgb.b + 80),
                        spawned: false,
                        type: 'spark'
                    });
                }

                function drawBeam(now) {
                    const elapsed = now - startTime;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Bolt position
                    const t = Math.min(1, elapsed / (duration * boltSpeed));
                    const bx = fx + dx * t;
                    const by = fy + dy * t;

                    if (t < 1) {
                        // Core bolt: bright white center with colored glow
                        ctx.save();
                        // Outer glow
                        const grad = ctx.createRadialGradient(bx, by, 0, bx, by, 28);
                        grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.6)`);
                        grad.addColorStop(0.4, `rgba(${rgb.r},${rgb.g},${rgb.b},0.2)`);
                        grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(bx, by, 28, 0, Math.PI*2);
                        ctx.fill();

                        // Inner glow line (the beam itself trailing behind bolt)
                        const trailLen = Math.min(dist * t, 80);
                        const trailX = bx - Math.cos(angle) * trailLen;
                        const trailY = by - Math.sin(angle) * trailLen;
                        const lineGrad = ctx.createLinearGradient(trailX, trailY, bx, by);
                        lineGrad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        lineGrad.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},0.7)`);
                        lineGrad.addColorStop(1, `rgba(255,255,255,0.9)`);
                        ctx.strokeStyle = lineGrad;
                        ctx.lineWidth = 5;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(trailX, trailY);
                        ctx.lineTo(bx, by);
                        ctx.stroke();

                        // Core white dot
                        ctx.fillStyle = 'rgba(255,255,255,0.95)';
                        ctx.beginPath();
                        ctx.arc(bx, by, 4, 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }

                    // Spawn trail particles at bolt position
                    particles.forEach(p => {
                        if (!p.spawned && elapsed >= p.born) {
                            p.spawned = true;
                            if (p.type === 'trail') {
                                const pt = Math.min(1, p.born / (duration * boltSpeed));
                                p.x = fx + dx * pt + (Math.random() - 0.5) * 8;
                                p.y = fy + dy * pt + (Math.random() - 0.5) * 8;
                            }
                        }
                    });

                    // Draw particles
                    particles.forEach(p => {
                        if (!p.spawned) return;
                        const age = elapsed - p.born;
                        if (age < 0 || age > p.life) return;
                        const frac = age / p.life;
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vx *= 0.97;
                        p.vy *= 0.97;
                        const a = p.alpha * (1 - frac);
                        const s = p.size * (1 - frac * 0.5);
                        ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${a})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, s, 0, Math.PI*2);
                        ctx.fill();
                    });

                    // Flash on impact
                    if (t >= 1 && elapsed < duration * boltSpeed + 50) {
                        screenFlash(spell.color, 60);
                    }

                    if (elapsed < duration) {
                        animId = requestAnimationFrame(drawBeam);
                    } else {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        resolve();
                    }
                }
                animId = requestAnimationFrame(drawBeam);
                break;
            }

            case 'explosion': {
                // Bolt travels then detonates into expanding fireball with debris
                const duration = 1000;
                const boltTime = 350;
                const dx = tx - fx, dy = ty - fy;
                const angle = Math.atan2(dy, dx);

                // Fireball particles
                for (let i = 0; i < 60; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const sp = 0.5 + Math.random() * 5;
                    const hueShift = (Math.random() - 0.5) * 60;
                    particles.push({
                        born: boltTime + Math.random() * 80,
                        life: 200 + Math.random() * 500,
                        x: tx, y: ty,
                        vx: Math.cos(a) * sp,
                        vy: Math.sin(a) * sp - Math.random() * 1.5,
                        size: 3 + Math.random() * 8,
                        alpha: 0.7 + Math.random() * 0.3,
                        r: Math.min(255, rgb.r + hueShift),
                        g: Math.max(0, rgb.g + hueShift * 0.5),
                        b: Math.max(0, rgb.b - 20),
                        spawned: false,
                        type: 'fire'
                    });
                }
                // Smoke particles
                for (let i = 0; i < 20; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const sp = 0.3 + Math.random() * 2;
                    particles.push({
                        born: boltTime + 100 + Math.random() * 200,
                        life: 400 + Math.random() * 400,
                        x: tx + (Math.random()-0.5)*20, y: ty + (Math.random()-0.5)*20,
                        vx: Math.cos(a) * sp,
                        vy: -0.5 - Math.random() * 1.5,
                        size: 6 + Math.random() * 12,
                        alpha: 0.3,
                        r: 80, g: 70, b: 60,
                        spawned: false,
                        type: 'smoke'
                    });
                }
                // Embers
                for (let i = 0; i < 15; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const sp = 2 + Math.random() * 4;
                    particles.push({
                        born: boltTime + Math.random() * 100,
                        life: 300 + Math.random() * 600,
                        x: tx, y: ty,
                        vx: Math.cos(a) * sp,
                        vy: Math.sin(a) * sp - 2,
                        size: 1 + Math.random() * 2,
                        alpha: 1,
                        r: 255, g: 200 + Math.floor(Math.random()*55), b: 50,
                        spawned: false,
                        type: 'ember',
                        gravity: 0.08
                    });
                }

                function drawExplosion(now) {
                    const elapsed = now - startTime;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Bolt phase
                    const bt = Math.min(1, elapsed / boltTime);
                    if (bt < 1) {
                        const bx = fx + dx * bt;
                        const by = fy + dy * bt;
                        const grad = ctx.createRadialGradient(bx, by, 0, bx, by, 20);
                        grad.addColorStop(0, `rgba(255,255,255,0.9)`);
                        grad.addColorStop(0.3, `rgba(${rgb.r},${rgb.g},${rgb.b},0.7)`);
                        grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(bx, by, 20, 0, Math.PI*2);
                        ctx.fill();
                        // Bright core
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.beginPath();
                        ctx.arc(bx, by, 4, 0, Math.PI*2);
                        ctx.fill();
                    }

                    // Explosion flash
                    if (elapsed >= boltTime && elapsed < boltTime + 100) {
                        const flashT = (elapsed - boltTime) / 100;
                        const flashR = 60 + flashT * 80;
                        const flashA = 0.7 * (1 - flashT);
                        const grad = ctx.createRadialGradient(tx, ty, 0, tx, ty, flashR);
                        grad.addColorStop(0, `rgba(255,255,255,${flashA})`);
                        grad.addColorStop(0.3, `rgba(${rgb.r},${rgb.g},${rgb.b},${flashA * 0.7})`);
                        grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(tx, ty, flashR, 0, Math.PI*2);
                        ctx.fill();
                        if (flashT < 0.2) screenFlash(spell.color, 100);
                    }

                    // Shockwave ring
                    if (elapsed >= boltTime && elapsed < boltTime + 400) {
                        const st = (elapsed - boltTime) / 400;
                        const ringR = st * 120;
                        ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${0.5 * (1-st)})`;
                        ctx.lineWidth = 3 * (1 - st);
                        ctx.beginPath();
                        ctx.arc(tx, ty, ringR, 0, Math.PI*2);
                        ctx.stroke();
                    }

                    // Spawn + draw particles
                    particles.forEach(p => {
                        if (!p.spawned && elapsed >= p.born) p.spawned = true;
                        if (!p.spawned) return;
                        const age = elapsed - p.born;
                        if (age < 0 || age > p.life) return;
                        const frac = age / p.life;
                        p.x += p.vx;
                        p.y += p.vy;
                        if (p.gravity) p.vy += p.gravity;
                        p.vx *= 0.98;
                        p.vy *= 0.98;
                        const a = p.alpha * (1 - frac);
                        const s = p.type === 'smoke' ? p.size * (1 + frac) : p.size * (1 - frac * 0.4);
                        ctx.globalAlpha = a;
                        ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, Math.max(0.5, s), 0, Math.PI*2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    });

                    if (elapsed < duration) {
                        animId = requestAnimationFrame(drawExplosion);
                    } else {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        resolve();
                    }
                }
                animId = requestAnimationFrame(drawExplosion);
                break;
            }

            case 'shield': {
                // Multi-layered hexagonal shield with energy ripples
                const duration = 1100;
                const cx = fromPlayer ? fx : tx;
                const cy = fromPlayer ? fy : ty;

                // Orbiting motes
                for (let i = 0; i < 20; i++) {
                    particles.push({
                        angle: (Math.PI * 2 / 20) * i,
                        radius: 50 + Math.random() * 20,
                        speed: 0.02 + Math.random() * 0.03,
                        size: 1.5 + Math.random() * 2,
                        alpha: 0.4 + Math.random() * 0.4,
                        r: Math.min(255, rgb.r + 60), g: Math.min(255, rgb.g + 60), b: Math.min(255, rgb.b + 60)
                    });
                }

                function drawShield(now) {
                    const elapsed = now - startTime;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const t = elapsed / duration;
                    const fadeIn = Math.min(1, elapsed / 200);
                    const fadeOut = elapsed > duration - 300 ? 1 - (elapsed - (duration - 300)) / 300 : 1;
                    const alpha = fadeIn * fadeOut;

                    // Outer dome glow
                    const r1 = 65 + Math.sin(elapsed * 0.005) * 5;
                    const grad1 = ctx.createRadialGradient(cx, cy, r1 * 0.3, cx, cy, r1);
                    grad1.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.05 * alpha})`);
                    grad1.addColorStop(0.7, `rgba(${rgb.r},${rgb.g},${rgb.b},${0.15 * alpha})`);
                    grad1.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
                    ctx.fillStyle = grad1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r1, 0, Math.PI * 2);
                    ctx.fill();

                    // Hexagonal outline
                    ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${0.6 * alpha})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI / 3) * i - Math.PI / 6 + elapsed * 0.001;
                        const hx = cx + Math.cos(a) * 55;
                        const hy = cy + Math.sin(a) * 55;
                        i === 0 ? ctx.moveTo(hx, hy) : ctx.lineTo(hx, hy);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Inner hexagonal outline (counter-rotating)
                    ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${0.3 * alpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (Math.PI / 3) * i - elapsed * 0.0015;
                        const hx = cx + Math.cos(a) * 35;
                        const hy = cy + Math.sin(a) * 35;
                        i === 0 ? ctx.moveTo(hx, hy) : ctx.lineTo(hx, hy);
                    }
                    ctx.closePath();
                    ctx.stroke();

                    // Energy ripple rings
                    const rippleT = (elapsed % 600) / 600;
                    ctx.strokeStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},${0.4 * (1 - rippleT) * alpha})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 20 + rippleT * 50, 0, Math.PI * 2);
                    ctx.stroke();

                    // Orbiting motes
                    particles.forEach(p => {
                        p.angle += p.speed;
                        const px = cx + Math.cos(p.angle) * p.radius;
                        const py = cy + Math.sin(p.angle) * p.radius;
                        ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${p.alpha * alpha})`;
                        ctx.beginPath();
                        ctx.arc(px, py, p.size, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    if (elapsed < 150) screenFlash(`rgba(${rgb.r},${rgb.g},${rgb.b},0.15)`, 40);

                    if (elapsed < duration) {
                        animId = requestAnimationFrame(drawShield);
                    } else {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        resolve();
                    }
                }
                animId = requestAnimationFrame(drawShield);
                break;
            }

            case 'patronus': {
                // Silvery-blue wisp that coalesces into a glowing stag silhouette
                const duration = 1400;
                const cx = fromPlayer ? fx : tx;
                const cy = fromPlayer ? fy - 30 : ty - 30;

                // Swirling silver wisps
                for (let i = 0; i < 50; i++) {
                    const a = Math.random() * Math.PI * 2;
                    const r = 20 + Math.random() * 80;
                    particles.push({
                        born: Math.random() * 400,
                        life: 400 + Math.random() * 800,
                        startX: cx + Math.cos(a) * r,
                        startY: cy + Math.sin(a) * r,
                        targetX: cx + (Math.random() - 0.5) * 30,
                        targetY: cy + (Math.random() - 0.5) * 30,
                        size: 2 + Math.random() * 4,
                        alpha: 0.3 + Math.random() * 0.5,
                        spawned: false
                    });
                }

                function drawPatronus(now) {
                    const elapsed = now - startTime;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    const t = elapsed / duration;

                    // Central glow that builds
                    const glowPhase = Math.min(1, elapsed / 600);
                    const fadeOut = elapsed > duration - 400 ? 1 - (elapsed - (duration - 400)) / 400 : 1;
                    const gr = ctx.createRadialGradient(cx, cy, 0, cx, cy, 70 * glowPhase);
                    gr.addColorStop(0, `rgba(200,220,255,${0.4 * glowPhase * fadeOut})`);
                    gr.addColorStop(0.4, `rgba(150,200,255,${0.2 * glowPhase * fadeOut})`);
                    gr.addColorStop(1, 'rgba(150,200,255,0)');
                    ctx.fillStyle = gr;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 70, 0, Math.PI*2);
                    ctx.fill();

                    // Wisps converging
                    particles.forEach(p => {
                        if (!p.spawned && elapsed >= p.born) p.spawned = true;
                        if (!p.spawned) return;
                        const age = elapsed - p.born;
                        if (age > p.life) return;
                        const frac = age / p.life;
                        const px = p.startX + (p.targetX - p.startX) * Math.min(1, frac * 2);
                        const py = p.startY + (p.targetY - p.startY) * Math.min(1, frac * 2);
                        const a = p.alpha * (frac < 0.5 ? frac * 2 : 2 * (1 - frac)) * fadeOut;
                        const s = p.size * (1 - frac * 0.3);
                        ctx.fillStyle = `rgba(200,220,255,${a})`;
                        ctx.beginPath();
                        ctx.arc(px, py, s, 0, Math.PI*2);
                        ctx.fill();
                    });

                    // Stag silhouette (drawn with arcs/lines when fully formed)
                    if (elapsed > 400) {
                        const stT = Math.min(1, (elapsed - 400) / 400);
                        const stFade = fadeOut * stT;
                        ctx.save();
                        ctx.globalAlpha = stFade * 0.8;
                        ctx.fillStyle = 'rgba(220,235,255,0.9)';
                        ctx.shadowColor = 'rgba(150,200,255,0.8)';
                        ctx.shadowBlur = 25;
                        // Stag body (simplified)
                        ctx.beginPath();
                        ctx.ellipse(cx, cy + 5, 22 * stT, 14 * stT, 0, 0, Math.PI*2);
                        ctx.fill();
                        // Head
                        ctx.beginPath();
                        ctx.ellipse(cx + 20 * stT, cy - 10 * stT, 8 * stT, 7 * stT, -0.3, 0, Math.PI*2);
                        ctx.fill();
                        // Neck
                        ctx.strokeStyle = 'rgba(220,235,255,0.9)';
                        ctx.lineWidth = 5 * stT;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(cx + 15 * stT, cy);
                        ctx.lineTo(cx + 20 * stT, cy - 8 * stT);
                        ctx.stroke();
                        // Legs
                        ctx.lineWidth = 3 * stT;
                        const legs = [[-12, 12, -14, 28], [-4, 12, -2, 28], [8, 12, 10, 28], [16, 12, 18, 28]];
                        legs.forEach(l => {
                            ctx.beginPath();
                            ctx.moveTo(cx + l[0] * stT, cy + l[1] * stT);
                            ctx.lineTo(cx + l[2] * stT, cy + l[3] * stT);
                            ctx.stroke();
                        });
                        // Antlers
                        ctx.lineWidth = 2 * stT;
                        ctx.beginPath();
                        ctx.moveTo(cx + 18 * stT, cy - 14 * stT);
                        ctx.lineTo(cx + 14 * stT, cy - 28 * stT);
                        ctx.lineTo(cx + 10 * stT, cy - 32 * stT);
                        ctx.moveTo(cx + 14 * stT, cy - 28 * stT);
                        ctx.lineTo(cx + 18 * stT, cy - 34 * stT);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx + 22 * stT, cy - 14 * stT);
                        ctx.lineTo(cx + 26 * stT, cy - 28 * stT);
                        ctx.lineTo(cx + 30 * stT, cy - 32 * stT);
                        ctx.moveTo(cx + 26 * stT, cy - 28 * stT);
                        ctx.lineTo(cx + 22 * stT, cy - 34 * stT);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    }

                    if (elapsed < 200) screenFlash('rgba(200,220,255,0.15)', 50);

                    if (elapsed < duration) {
                        animId = requestAnimationFrame(drawPatronus);
                    } else {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        resolve();
                    }
                }
                animId = requestAnimationFrame(drawPatronus);
                break;
            }

            case 'heal': {
                // Spiraling green/gold particles rising with cross symbols
                const duration = 1100;
                const cx = fromPlayer ? fx : tx;
                const cy = fromPlayer ? fy : ty;

                for (let i = 0; i < 35; i++) {
                    const a = (Math.PI * 2 / 35) * i;
                    const r = 5 + Math.random() * 30;
                    particles.push({
                        born: Math.random() * 300,
                        life: 500 + Math.random() * 500,
                        x: cx + Math.cos(a) * r,
                        y: cy + Math.random() * 20,
                        vx: Math.cos(a) * 0.3,
                        vy: -1 - Math.random() * 2,
                        size: 2 + Math.random() * 3,
                        alpha: 0.5 + Math.random() * 0.4,
                        spawned: false,
                        r: 40 + Math.floor(Math.random() * 40),
                        g: 200 + Math.floor(Math.random() * 55),
                        b: 80 + Math.floor(Math.random() * 50),
                        spin: Math.random() * 0.1,
                        type: Math.random() > 0.7 ? 'cross' : 'dot'
                    });
                }

                function drawHeal(now) {
                    const elapsed = now - startTime;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // Central column glow
                    const fadeIn = Math.min(1, elapsed / 200);
                    const fadeOut = elapsed > duration - 300 ? 1 - (elapsed - (duration - 300)) / 300 : 1;
                    const alpha = fadeIn * fadeOut;
                    const grad = ctx.createLinearGradient(cx, cy + 30, cx, cy - 60);
                    grad.addColorStop(0, `rgba(46,204,113,0)`);
                    grad.addColorStop(0.3, `rgba(46,204,113,${0.15 * alpha})`);
                    grad.addColorStop(0.7, `rgba(46,204,113,${0.1 * alpha})`);
                    grad.addColorStop(1, `rgba(46,204,113,0)`);
                    ctx.fillStyle = grad;
                    ctx.fillRect(cx - 25, cy - 60, 50, 90);

                    particles.forEach(p => {
                        if (!p.spawned && elapsed >= p.born) p.spawned = true;
                        if (!p.spawned) return;
                        const age = elapsed - p.born;
                        if (age > p.life) return;
                        const frac = age / p.life;
                        p.x += p.vx + Math.sin(age * p.spin) * 0.5;
                        p.y += p.vy;
                        p.vy *= 0.99;
                        const a = p.alpha * (1 - frac) * alpha;
                        const s = p.size * (1 - frac * 0.3);

                        if (p.type === 'cross') {
                            ctx.strokeStyle = `rgba(${p.r},${p.g},${p.b},${a})`;
                            ctx.lineWidth = 1.5;
                            ctx.beginPath();
                            ctx.moveTo(p.x - s, p.y);
                            ctx.lineTo(p.x + s, p.y);
                            ctx.moveTo(p.x, p.y - s);
                            ctx.lineTo(p.x, p.y + s);
                            ctx.stroke();
                        } else {
                            ctx.fillStyle = `rgba(${p.r},${p.g},${p.b},${a})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, s, 0, Math.PI*2);
                            ctx.fill();
                        }
                    });

                    if (elapsed < 150) screenFlash('rgba(46,204,113,0.1)', 40);

                    if (elapsed < duration) {
                        animId = requestAnimationFrame(drawHeal);
                    } else {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        resolve();
                    }
                }
                animId = requestAnimationFrame(drawHeal);
                break;
            }

            default:
                resolve();
        }
    });
}

function showDamageNumber(value, type, onPlayer) {
    const arena = document.getElementById('battle-arena');
    const arenaRect = arena.getBoundingClientRect();
    const pos = onPlayer ? getPlayerPos() : getOpponentPos();

    const num = document.createElement('div');
    num.className = 'damage-number ' + type;

    if (type === 'damage') {
        num.textContent = '-' + value;
    } else if (type === 'heal') {
        num.textContent = '+' + value;
    } else if (type === 'mana-drain') {
        num.textContent = '-' + value + ' MP';
    } else if (type === 'blocked') {
        num.textContent = 'BLOCKED!';
    } else if (type === 'stun') {
        num.textContent = 'STUNNED!';
    }

    num.style.left = (pos.x - arenaRect.left + (Math.random() * 40 - 20)) + 'px';
    num.style.top = (pos.y - arenaRect.top - 30) + 'px';
    arena.appendChild(num);
    setTimeout(() => num.remove(), 1200);
}

function shakeSprite(isPlayer) {
    const sprite = document.getElementById(isPlayer ? 'player-sprite' : 'opponent-sprite');
    sprite.classList.remove('shake');
    void sprite.offsetWidth; // force reflow
    sprite.classList.add('shake');
    setTimeout(() => sprite.classList.remove('shake'), 500);
}

// ========== GAME FLOW ==========

function startGame() {
    gameState.spellQueue = [];
    gameState.spellQueue2 = [];
    gameState.queueIndex = 0;
    gameState.queueIndex2 = 0;
    gameState.planningFor = 1;
    renderPlanningScreen();
    showScreen('planning-screen');
}

function startBattle() {
    const is2p = gameState.gameMode === '2player';

    // In 2p mode, handle sequential planning
    if (is2p && gameState.planningFor === 1) {
        if (gameState.spellQueue.length === 0) return;
        gameState.planningFor = 2;
        renderPlanningScreen();
        return;
    }

    const currentQueue = is2p ? gameState.spellQueue2 : gameState.spellQueue;
    if (currentQueue.length === 0) return;

    const charData = CHARACTERS[gameState.selectedChar];
    const oppData = is2p ? CHARACTERS[gameState.selectedChar2] : OPPONENTS[gameState.selectedDiff];

    gameState.player = createEntity(charData);
    gameState.opponent = createEntity(oppData);
    gameState.turn = 1;
    gameState.isPlayerTurn = true;
    gameState.isAnimating = false;
    gameState.gameOver = false;
    gameState.queueIndex = 0;
    gameState.queueIndex2 = 0;
    gameState.battleSpeed = 10;
    gameState.stats = { damageDealt: 0, damageTaken: 0, spellsCast: 0, healingDone: 0, turnsPlayed: 0 };

    // Reset speed buttons
    document.querySelectorAll('.speed-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.speed === '10');
    });

    // Set up UI
    document.getElementById('player-avatar').textContent = charData.avatar;
    document.getElementById('player-name').textContent = charData.name;
    document.getElementById('player-sprite').textContent = charData.avatar;

    document.getElementById('opponent-avatar').textContent = oppData.avatar;
    document.getElementById('opponent-name').textContent = oppData.name;
    document.getElementById('opponent-sprite').textContent = oppData.avatar;

    // Clear battle log
    const log = document.getElementById('battle-log');
    log.innerHTML = '<div class="log-title">Battle Log</div>';
    addLogEntry(`${charData.name} faces ${oppData.name}!`, 'system');

    renderBattleQueue();
    updateBars();
    showScreen('battle-screen');

    // Start auto-play
    setTimeout(() => autoPlayNext(), getDelay(150));
}

// ========== AUTO-PLAY SYSTEM ==========

async function autoPlayNext() {
    if (gameState.gameOver) return;

    if (gameState.queueIndex < gameState.spellQueue.length) {
        const spellId = gameState.spellQueue[gameState.queueIndex];
        gameState.queueIndex++;
        updateBattleQueue();

        if (spellId === 'wait') {
            addLogEntry(`${gameState.player.name} waits and gathers energy...`, 'player-action');
            gameState.stats.spellsCast++;
            updateBars();
            setTimeout(() => aiTurn(), getDelay(100));
        } else {
            const spell = SPELLS.find(s => s.id === spellId);
            if (gameState.player.mana >= spell.manaCost) {
                await castAutoSpell(spell);
            } else {
                addLogEntry(`${gameState.player.name} lacks mana for ${spell.name}! (Need ${spell.manaCost}, have ${gameState.player.mana})`, 'system');
                updateBars();
                setTimeout(() => aiTurn(), getDelay(100));
            }
        }
    } else {
        addLogEntry(`${gameState.player.name} has no more planned spells...`, 'system');
        updateBars();
        setTimeout(() => aiTurn(), getDelay(100));
    }
}

async function castAutoSpell(spell) {
    gameState.isAnimating = true;

    // Deduct mana
    gameState.player.mana -= spell.manaCost;
    gameState.stats.spellsCast++;

    // Play animation
    await playSpellAnimation(spell, true);

    // Execute spell effect
    const result = spell.effect(gameState.player, gameState.opponent);
    addLogEntry(result.message, 'player-action');

    // Show damage numbers
    if (result.damage > 0) {
        showDamageNumber(result.damage, 'damage', false);
        shakeSprite(false);
        gameState.stats.damageDealt += result.damage;
    } else if (result.damage === 0 && spell.category === 'attack') {
        showDamageNumber(0, 'blocked', false);
    }
    if (result.manaDrain) {
        showDamageNumber(result.manaDrain, 'mana-drain', false);
    }
    if (result.healed) {
        showDamageNumber(result.healed, 'heal', true);
        gameState.stats.healingDone += result.healed;
    }
    if (result.stunned) {
        showDamageNumber(0, 'stun', false);
    }

    updateBars();

    // Check win
    if (gameState.opponent.hp <= 0) {
        setTimeout(() => endGame(true), getDelay(80));
        return;
    }

    // AI turn
    setTimeout(() => aiTurn(), getDelay(100));
}

async function aiTurn() {
    if (gameState.gameOver) return;

    const o = gameState.opponent;
    const p = gameState.player;
    const is2p = gameState.gameMode === '2player';

    // Tick opponent statuses first
    const regenAmt = regenMana(o);
    const statusMsgs = tickStatuses(o);
    statusMsgs.forEach(m => addLogEntry(m.text, m.type));
    updateBars();

    // Check if opponent died from bleed
    if (o.hp <= 0) {
        setTimeout(() => endGame(true), getDelay(80));
        return;
    }

    // Check stun
    if (isStunned(o)) {
        addLogEntry(`${o.name} is stunned and cannot act!`, 'system');
        updateBars();
        setTimeout(() => startPlayerTurn(), getDelay(100));
        return;
    }

    // Pick spell: from P2 queue or AI
    let spell = null;
    if (is2p) {
        if (gameState.queueIndex2 < gameState.spellQueue2.length) {
            const spellId = gameState.spellQueue2[gameState.queueIndex2];
            gameState.queueIndex2++;
            if (spellId === 'wait') {
                addLogEntry(`${o.name} waits and gathers energy...`, 'enemy-action');
                updateBars();
                setTimeout(() => startPlayerTurn(), getDelay(100));
                return;
            }
            spell = SPELLS.find(s => s.id === spellId);
            if (spell && o.mana < spell.manaCost) {
                addLogEntry(`${o.name} lacks mana for ${spell.name}!`, 'system');
                spell = null;
            }
        }
        if (!spell) {
            addLogEntry(`${o.name} has no more planned spells...`, 'system');
            updateBars();
            setTimeout(() => startPlayerTurn(), getDelay(80));
            return;
        }
    } else {
        spell = aiSelectSpell();
    }

    if (!spell) {
        addLogEntry(`${o.name} has no mana to cast!`, 'system');
        updateBars();
        setTimeout(() => startPlayerTurn(), getDelay(80));
        return;
    }

    // Deduct mana
    o.mana -= spell.manaCost;

    // Play animation
    await playSpellAnimation(spell, false);

    // Execute
    const result = spell.effect(o, p);
    addLogEntry(result.message, 'enemy-action');

    // Show damage numbers on player
    if (result.damage > 0) {
        showDamageNumber(result.damage, 'damage', true);
        shakeSprite(true);
        gameState.stats.damageTaken += result.damage;
    } else if (result.damage === 0 && spell.category === 'attack') {
        showDamageNumber(0, 'blocked', true);
    }
    if (result.manaDrain) {
        showDamageNumber(result.manaDrain, 'mana-drain', true);
    }
    if (result.healed) {
        showDamageNumber(result.healed, 'heal', false);
    }
    if (result.stunned) {
        showDamageNumber(0, 'stun', true);
    }

    updateBars();

    // Check lose
    if (p.hp <= 0) {
        setTimeout(() => endGame(false), getDelay(80));
        return;
    }

    setTimeout(() => startPlayerTurn(), getDelay(80));
}

function startPlayerTurn() {
    if (gameState.gameOver) return;

    gameState.turn++;
    gameState.stats.turnsPlayed++;

    const p = gameState.player;

    // Regen mana
    const regenAmt = regenMana(p);

    // Tick statuses
    const statusMsgs = tickStatuses(p);
    statusMsgs.forEach(m => addLogEntry(m.text, m.type));

    // Check if player died from bleed
    if (p.hp <= 0) {
        updateBars();
        setTimeout(() => endGame(false), getDelay(80));
        return;
    }

    // Check stun
    if (isStunned(p)) {
        updateBars();
        const overlay = document.getElementById('stun-overlay');
        overlay.style.display = 'flex';
        addLogEntry(`${p.name} is stunned and cannot act!`, 'system');

        setTimeout(() => {
            overlay.style.display = 'none';
            setTimeout(() => aiTurn(), getDelay(50));
        }, getDelay(100));
        return;
    }

    gameState.isPlayerTurn = true;
    gameState.isAnimating = false;
    updateBars();

    // Auto-play next spell from queue
    setTimeout(() => autoPlayNext(), getDelay(80));
}

// ========== AI SYSTEM ==========

function aiSelectSpell() {
    const o = gameState.opponent;
    const p = gameState.player;

    // Get affordable spells
    const available = SPELLS.filter(s => s.manaCost <= o.mana);
    if (available.length === 0) return null;

    const smartness = o.smartness;
    const profile = o.profile;

    // Score each spell
    const scored = available.map(spell => {
        let score = 10; // base

        // Profile-based weights
        if (profile === 'aggressive') {
            if (spell.category === 'attack') score += 15;
            if (spell.id === 'confringo') score += 10;
            if (spell.id === 'sectumsempra') score += 8;
            if (spell.category === 'defense') score -= 5;
        } else if (profile === 'strategic') {
            // Value debuffs and shields more
            if (spell.id === 'impedimenta' && !getStatus(p, 'manaslow')) score += 12;
            if (spell.id === 'sectumsempra' && !getStatus(p, 'bleed')) score += 10;
            if (spell.id === 'petrificus') score += 8;
        }

        // Smart decisions (weighted by smartness)
        if (Math.random() < smartness) {
            // Low HP: prefer heals and defense
            const oHpPct = o.hp / o.maxHp;
            if (oHpPct < 0.35) {
                if (spell.id === 'episkey') score += 20;
                if (spell.id === 'protego') score += 12;
                if (spell.id === 'patronum') score += 15;
            }

            // Player has low HP: go for kill
            const pHpPct = p.hp / p.maxHp;
            if (pHpPct < 0.25) {
                if (spell.category === 'attack') score += 15;
                if (spell.id === 'confringo') score += 10;
            }

            // Player has shield: use confringo or wait
            if (getStatus(p, 'shield') || getStatus(p, 'fullblock')) {
                if (spell.id === 'confringo') score += 15;
                if (spell.category === 'attack' && spell.id !== 'confringo') score -= 8;
                if (spell.id === 'impedimenta') score += 8;
            }

            // Already have shield: don't stack
            if (getStatus(o, 'shield') && spell.id === 'protego') score -= 15;
            if (getStatus(o, 'fullblock') && spell.id === 'patronum') score -= 20;

            // Don't heal at full HP
            if (o.hp >= o.maxHp * 0.85 && ['episkey', 'rennervate', 'ferula', 'vulnerasanentur', 'wiggenweld', 'reparo'].includes(spell.id)) score -= 15;

            // Player already has debuffs: don't duplicate
            if (getStatus(p, 'bleed') && ['sectumsempra', 'diffindo', 'incarcerous'].includes(spell.id)) score -= 8;
            if (getStatus(p, 'burn') && ['incendio', 'relashio', 'morsmordre', 'fiendfyre'].includes(spell.id)) score -= 8;
            if (getStatus(p, 'poison') && ['furnunculus', 'serpensortia'].includes(spell.id)) score -= 8;
            if (getStatus(p, 'manaslow') && ['impedimenta', 'locomotormortis', 'glacius', 'confundo'].includes(spell.id)) score -= 10;

            // Value powerful spells when player is low
            if (pHpPct < 0.25) {
                if (['bombardamaxima', 'expulso', 'crucio', 'avadakedavra'].includes(spell.id)) score += 12;
            }

            // Low mana: prefer cheap spells
            if (o.mana < 20) {
                if (spell.manaCost <= 10) score += 5;
                if (['aguamenti', 'lumosmaxima', 'flipendo', 'accio'].includes(spell.id)) score += 8;
            }

            // Have debuffs: cleanse with patronum or rennervate
            const hasDebuffs = o.statuses.some(s => ['bleed', 'burn', 'poison', 'manaslow'].includes(s.type));
            if (hasDebuffs && spell.id === 'patronum') score += 12;
            if (hasDebuffs && spell.id === 'rennervate') score += 10;
            if (hasDebuffs && spell.id === 'finiteincantatem') score += 8;
        }

        // Add some randomness
        score += Math.random() * 10;

        return { spell, score };
    });

    // Sort by score and pick the best
    scored.sort((a, b) => b.score - a.score);
    return scored[0].spell;
}

// ========== END GAME ==========

function endGame(playerWon) {
    gameState.gameOver = true;
    gameState.isAnimating = false;

    setTimeout(() => {
        const titleEl = document.getElementById('result-title');
        const subtitleEl = document.getElementById('result-subtitle');
        const statsEl = document.getElementById('result-stats');

        const is2p = gameState.gameMode === '2player';
        if (playerWon) {
            titleEl.textContent = is2p ? 'PLAYER 1 WINS!' : 'VICTORY!';
            titleEl.className = 'result-title victory';
            subtitleEl.textContent = `${gameState.player.name} has defeated ${gameState.opponent.name}!`;
        } else {
            titleEl.textContent = is2p ? 'PLAYER 2 WINS!' : 'DEFEAT';
            titleEl.className = 'result-title ' + (is2p ? 'victory' : 'defeat');
            subtitleEl.textContent = is2p
                ? `${gameState.opponent.name} has defeated ${gameState.player.name}!`
                : `${gameState.opponent.name} has prevailed...`;
        }

        const s = gameState.stats;
        statsEl.innerHTML = `
            <div class="stat-item"><div class="stat-label">Turns</div><div class="stat-value">${s.turnsPlayed}</div></div>
            <div class="stat-item"><div class="stat-label">Spells Cast</div><div class="stat-value">${s.spellsCast}</div></div>
            <div class="stat-item"><div class="stat-label">Damage Dealt</div><div class="stat-value">${s.damageDealt}</div></div>
            <div class="stat-item"><div class="stat-label">Damage Taken</div><div class="stat-value">${s.damageTaken}</div></div>
            <div class="stat-item"><div class="stat-label">Healing Done</div><div class="stat-value">${s.healingDone}</div></div>
            <div class="stat-item"><div class="stat-label">HP Remaining</div><div class="stat-value">${Math.max(0, playerWon ? gameState.player.hp : gameState.opponent.hp)}</div></div>
        `;

        showScreen('result-screen');
    }, getDelay(80));
}

function duelAgain() {
    gameState.queueIndex = 0;
    gameState.queueIndex2 = 0;
    gameState.planningFor = 1;
    renderPlanningScreen();
    showScreen('planning-screen');
}

function backToMenu() {
    gameState.spellQueue = [];
    gameState.spellQueue2 = [];
    gameState.planningFor = 1;
    showScreen('title-screen');
}

// ========== PARTICLE BACKGROUND ==========

function initParticles() {
    const canvas = document.getElementById('particles-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particles = [];
    const particleCount = 50;

    for (let i = 0; i < particleCount; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            size: Math.random() * 2 + 0.5,
            alpha: Math.random() * 0.4 + 0.1,
            color: Math.random() > 0.5 ? '#d4a843' : '#7b2fbe'
        });
    }

    function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;

            if (p.x < 0) p.x = canvas.width;
            if (p.x > canvas.width) p.x = 0;
            if (p.y < 0) p.y = canvas.height;
            if (p.y > canvas.height) p.y = 0;

            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.alpha;
            ctx.fill();
            ctx.globalAlpha = 1;
        });

        requestAnimationFrame(animate);
    }

    animate();

    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    });
}

// ========== INIT ==========
initParticles();
</script>
</body>
</html>

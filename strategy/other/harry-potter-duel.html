<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Harry Potter: Wizard's Duel</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --bg-dark: #0a0a1a;
    --bg-medium: #14142e;
    --bg-light: #1e1e3f;
    --gold: #d4a843;
    --gold-light: #f0d078;
    --purple: #7b2fbe;
    --purple-dark: #4a1a6b;
    --blue: #2a6fdb;
    --blue-dark: #1a3a7a;
    --red: #c0392b;
    --red-dark: #8b1a1a;
    --green: #27ae60;
    --green-dark: #1a6b3a;
    --text: #e8e8f0;
    --text-dim: #8888aa;
    --text-bright: #ffffff;
}

body {
    background: var(--bg-dark);
    color: var(--text);
    font-family: Georgia, 'Times New Roman', serif;
    min-height: 100vh;
    overflow: hidden;
    user-select: none;
}

/* ===== TITLE SCREEN ===== */
#titleScreen {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: radial-gradient(ellipse at 50% 30%, #1a1a4a 0%, #0a0a1a 70%);
    z-index: 100;
}

.title-stars {
    position: absolute;
    inset: 0;
    overflow: hidden;
    pointer-events: none;
}

.star {
    position: absolute;
    width: 2px;
    height: 2px;
    background: #fff;
    border-radius: 50%;
    animation: twinkle 3s infinite alternate;
}

@keyframes twinkle {
    0% { opacity: 0.2; }
    100% { opacity: 1; }
}

.game-title {
    font-size: 52px;
    font-weight: bold;
    color: var(--gold);
    text-shadow: 0 0 30px rgba(212,168,67,0.4), 0 4px 8px rgba(0,0,0,0.6);
    text-align: center;
    margin-bottom: 6px;
    letter-spacing: 3px;
    z-index: 1;
}

.game-subtitle {
    font-size: 20px;
    color: var(--text-dim);
    margin-bottom: 40px;
    letter-spacing: 6px;
    text-transform: uppercase;
    z-index: 1;
}

.selection-section {
    z-index: 1;
    text-align: center;
    margin-bottom: 24px;
}

.selection-label {
    font-size: 16px;
    color: var(--gold-light);
    margin-bottom: 12px;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.character-grid {
    display: flex;
    gap: 16px;
    justify-content: center;
}

.char-card {
    width: 160px;
    padding: 18px 12px;
    background: var(--bg-medium);
    border: 2px solid #333;
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.3s;
    text-align: center;
}

.char-card:hover {
    border-color: var(--gold);
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(212,168,67,0.2);
}

.char-card.selected {
    border-color: var(--gold);
    background: rgba(212,168,67,0.12);
    box-shadow: 0 0 20px rgba(212,168,67,0.3);
}

.char-icon {
    font-size: 42px;
    margin-bottom: 8px;
}

.char-name {
    font-size: 15px;
    font-weight: bold;
    color: var(--text-bright);
    margin-bottom: 4px;
}

.char-trait {
    font-size: 11px;
    color: var(--text-dim);
    margin-bottom: 8px;
}

.char-stats {
    font-size: 11px;
    color: var(--text-dim);
    line-height: 1.5;
}

.difficulty-grid {
    display: flex;
    gap: 12px;
    justify-content: center;
}

.diff-btn {
    padding: 10px 22px;
    background: var(--bg-medium);
    border: 2px solid #333;
    border-radius: 8px;
    color: var(--text);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.3s;
}

.diff-btn:hover {
    border-color: var(--purple);
    transform: translateY(-2px);
}

.diff-btn.selected {
    border-color: var(--purple);
    background: rgba(123,47,190,0.2);
    color: var(--gold-light);
}

.start-btn {
    z-index: 1;
    margin-top: 30px;
    padding: 16px 60px;
    background: linear-gradient(135deg, var(--gold) 0%, #b8902a 100%);
    border: none;
    border-radius: 10px;
    font-family: inherit;
    font-size: 20px;
    font-weight: bold;
    color: #1a1a2e;
    cursor: pointer;
    letter-spacing: 2px;
    transition: all 0.3s;
}

.start-btn:hover {
    transform: scale(1.06);
    box-shadow: 0 0 30px rgba(212,168,67,0.4);
}

/* ===== BATTLE SCREEN ===== */
#battleScreen {
    position: absolute;
    inset: 0;
    display: none;
    flex-direction: column;
    background: radial-gradient(ellipse at 50% 20%, #1a1a3e 0%, #0a0a1a 70%);
}

.battle-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 16px 24px 8px;
}

.fighter-info {
    width: 280px;
}

.fighter-name {
    font-size: 18px;
    font-weight: bold;
    margin-bottom: 6px;
}

.player-name { color: var(--gold-light); }
.enemy-name { color: var(--red); text-align: right; }

.bar-container {
    height: 18px;
    background: #1a1a2e;
    border-radius: 9px;
    overflow: hidden;
    margin-bottom: 4px;
    border: 1px solid #333;
    position: relative;
}

.bar-fill {
    height: 100%;
    border-radius: 9px;
    transition: width 0.6s ease;
}

.hp-fill { background: linear-gradient(90deg, var(--green) 0%, #2ecc71 100%); }
.hp-fill.medium { background: linear-gradient(90deg, #f39c12 0%, #e67e22 100%); }
.hp-fill.low { background: linear-gradient(90deg, var(--red) 0%, #e74c3c 100%); }
.mana-fill { background: linear-gradient(90deg, var(--blue) 0%, #3498db 100%); }

.bar-text {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 1px 2px rgba(0,0,0,0.8);
}

.status-effects {
    display: flex;
    gap: 6px;
    margin-top: 6px;
    min-height: 26px;
    flex-wrap: wrap;
}

.status-effects.right { justify-content: flex-end; }

.status-badge {
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: bold;
    color: #fff;
    animation: badgeIn 0.3s ease;
}

@keyframes badgeIn {
    from { transform: scale(0); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

.badge-shield { background: var(--blue-dark); border: 1px solid var(--blue); }
.badge-bleed { background: var(--red-dark); border: 1px solid var(--red); }
.badge-stun { background: #6b4a1a; border: 1px solid #d4a843; }
.badge-slow { background: var(--purple-dark); border: 1px solid var(--purple); }
.badge-block { background: #1a5a3a; border: 1px solid var(--green); }

.turn-indicator {
    text-align: center;
    font-size: 14px;
    color: var(--text-dim);
    padding: 4px 0;
}

/* ===== ARENA ===== */
.arena {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    min-height: 200px;
}

.wizard {
    width: 100px;
    height: 140px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s;
}

.wizard-sprite {
    font-size: 72px;
    filter: drop-shadow(0 4px 12px rgba(0,0,0,0.5));
}

.wizard-label {
    font-size: 12px;
    color: var(--text-dim);
    margin-top: 4px;
}

.player-wizard { margin-right: 120px; }
.enemy-wizard { margin-left: 120px; transform: scaleX(-1); }

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-8px); }
    40% { transform: translateX(8px); }
    60% { transform: translateX(-6px); }
    80% { transform: translateX(4px); }
}

.shaking { animation: shake 0.4s ease; }
.enemy-wizard.shaking { animation: shake 0.4s ease; transform: scaleX(-1); }

/* Spell effects overlay */
.spell-effect {
    position: absolute;
    pointer-events: none;
    z-index: 10;
}

.spell-beam {
    position: absolute;
    height: 6px;
    border-radius: 3px;
    top: 50%;
    transform: translateY(-50%);
    animation: beamFire 0.5s ease-out forwards;
    box-shadow: 0 0 15px currentColor, 0 0 30px currentColor;
}

@keyframes beamFire {
    0% { width: 0; opacity: 1; }
    70% { width: 200px; opacity: 1; }
    100% { width: 220px; opacity: 0; }
}

.beam-player {
    left: calc(50% - 120px);
    animation: beamRight 0.5s ease-out forwards;
}

.beam-enemy {
    right: calc(50% - 120px);
    animation: beamLeft 0.5s ease-out forwards;
}

@keyframes beamRight {
    0% { width: 0; opacity: 1; left: calc(50% - 100px); }
    60% { width: 180px; opacity: 1; }
    100% { width: 200px; opacity: 0; }
}

@keyframes beamLeft {
    0% { width: 0; opacity: 1; right: calc(50% - 100px); }
    60% { width: 180px; opacity: 1; }
    100% { width: 200px; opacity: 0; }
}

.shield-effect {
    position: absolute;
    width: 80px;
    height: 100px;
    border: 3px solid var(--blue);
    border-radius: 50%;
    top: 50%;
    transform: translateY(-50%);
    animation: shieldPulse 0.8s ease-out forwards;
    box-shadow: 0 0 20px rgba(42,111,219,0.5), inset 0 0 20px rgba(42,111,219,0.2);
}

@keyframes shieldPulse {
    0% { opacity: 0; transform: translateY(-50%) scale(0.5); }
    30% { opacity: 1; transform: translateY(-50%) scale(1.1); }
    70% { opacity: 1; transform: translateY(-50%) scale(1); }
    100% { opacity: 0; transform: translateY(-50%) scale(1.2); }
}

.heal-effect {
    position: absolute;
    width: 60px;
    height: 60px;
    top: 50%;
    transform: translate(-50%, -50%);
    animation: healFloat 1s ease-out forwards;
    font-size: 36px;
    text-align: center;
}

@keyframes healFloat {
    0% { opacity: 0; transform: translate(-50%, -30%); }
    30% { opacity: 1; }
    100% { opacity: 0; transform: translate(-50%, -80%); }
}

.explosion-effect {
    position: absolute;
    width: 60px;
    height: 60px;
    border-radius: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    animation: explode 0.6s ease-out forwards;
}

@keyframes explode {
    0% { opacity: 1; transform: translate(-50%,-50%) scale(0.3); }
    50% { opacity: 1; transform: translate(-50%,-50%) scale(1.2); }
    100% { opacity: 0; transform: translate(-50%,-50%) scale(1.5); }
}

/* Floating damage numbers */
.float-number {
    position: absolute;
    font-size: 22px;
    font-weight: bold;
    pointer-events: none;
    z-index: 20;
    animation: floatUp 1.2s ease-out forwards;
    text-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

@keyframes floatUp {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    20% { transform: translateY(-10px) scale(1.3); }
    100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
}

.float-damage { color: #ff4444; }
.float-heal { color: #44ff66; }
.float-mana { color: #4488ff; }
.float-status { color: #ffaa44; font-size: 16px; }
.float-miss { color: #aaa; font-style: italic; }

/* ===== BATTLE LOG ===== */
.battle-log {
    height: 60px;
    background: rgba(0,0,0,0.4);
    border-top: 1px solid #222;
    overflow-y: auto;
    padding: 8px 16px;
    font-size: 13px;
    line-height: 1.6;
}

.log-entry {
    animation: logFade 0.3s ease;
}

@keyframes logFade {
    from { opacity: 0; transform: translateX(-10px); }
    to { opacity: 1; transform: translateX(0); }
}

.log-player { color: var(--gold-light); }
.log-enemy { color: #ff6666; }
.log-info { color: var(--text-dim); }
.log-effect { color: #aa88ff; }

/* ===== SPELL CARDS ===== */
.spell-panel {
    background: var(--bg-medium);
    border-top: 2px solid #2a2a4a;
    padding: 12px 16px;
}

.spell-cards {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
}

.spell-card {
    width: 110px;
    padding: 10px 8px;
    background: var(--bg-light);
    border: 2px solid #3a3a5a;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.3s;
    text-align: center;
    opacity: 0;
    animation: cardIn 0.3s ease forwards;
}

.spell-card:nth-child(1) { animation-delay: 0.05s; }
.spell-card:nth-child(2) { animation-delay: 0.1s; }
.spell-card:nth-child(3) { animation-delay: 0.15s; }
.spell-card:nth-child(4) { animation-delay: 0.2s; }
.spell-card:nth-child(5) { animation-delay: 0.25s; }
.spell-card:nth-child(6) { animation-delay: 0.3s; }
.spell-card:nth-child(7) { animation-delay: 0.35s; }
.spell-card:nth-child(8) { animation-delay: 0.4s; }
.spell-card:nth-child(9) { animation-delay: 0.45s; }
.spell-card:nth-child(10) { animation-delay: 0.5s; }

@keyframes cardIn {
    from { opacity: 0; transform: translateY(20px); }
    to { opacity: 1; transform: translateY(0); }
}

.spell-card:hover:not(.disabled) {
    border-color: var(--gold);
    transform: translateY(-6px);
    box-shadow: 0 8px 20px rgba(212,168,67,0.2);
}

.spell-card.disabled {
    opacity: 0.35;
    cursor: not-allowed;
    filter: grayscale(0.6);
}

.spell-card.attack-card { border-left: 3px solid var(--red); }
.spell-card.defense-card { border-left: 3px solid var(--blue); }
.spell-card.utility-card { border-left: 3px solid var(--green); }

.spell-icon { font-size: 24px; margin-bottom: 4px; }
.spell-name { font-size: 11px; font-weight: bold; color: var(--text-bright); margin-bottom: 2px; }
.spell-cost { font-size: 10px; color: #6688cc; margin-bottom: 4px; }
.spell-desc { font-size: 9px; color: var(--text-dim); line-height: 1.3; }

/* ===== RESULT SCREEN ===== */
#resultScreen {
    position: absolute;
    inset: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 100;
    background: rgba(0,0,0,0.85);
}

.result-panel {
    background: var(--bg-medium);
    border: 2px solid var(--gold);
    border-radius: 20px;
    padding: 40px 60px;
    text-align: center;
    animation: resultIn 0.6s ease forwards;
    box-shadow: 0 0 60px rgba(212,168,67,0.2);
}

@keyframes resultIn {
    from { opacity: 0; transform: scale(0.8) translateY(30px); }
    to { opacity: 1; transform: scale(1) translateY(0); }
}

.result-title {
    font-size: 42px;
    font-weight: bold;
    margin-bottom: 8px;
}

.result-win { color: var(--gold); }
.result-lose { color: var(--red); }

.result-subtitle {
    font-size: 16px;
    color: var(--text-dim);
    margin-bottom: 24px;
}

.result-stats {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px 30px;
    margin-bottom: 30px;
    text-align: left;
}

.stat-item {
    font-size: 14px;
}

.stat-label { color: var(--text-dim); }
.stat-value { color: var(--text-bright); font-weight: bold; }

.result-buttons {
    display: flex;
    gap: 16px;
    justify-content: center;
}

.result-btn {
    padding: 12px 32px;
    border: 2px solid var(--gold);
    border-radius: 8px;
    background: transparent;
    color: var(--gold);
    font-family: inherit;
    font-size: 16px;
    cursor: pointer;
    transition: all 0.3s;
}

.result-btn:hover {
    background: var(--gold);
    color: var(--bg-dark);
}

.result-btn.primary {
    background: var(--gold);
    color: var(--bg-dark);
    font-weight: bold;
}

.result-btn.primary:hover {
    background: var(--gold-light);
    box-shadow: 0 0 20px rgba(212,168,67,0.4);
}

/* Patronus full-block animation */
.patronus-shield {
    position: absolute;
    width: 120px;
    height: 120px;
    top: 50%;
    transform: translate(-50%, -50%);
    border-radius: 50%;
    background: radial-gradient(circle, rgba(200,220,255,0.5) 0%, rgba(100,150,255,0.1) 70%, transparent 100%);
    border: 2px solid rgba(200,220,255,0.6);
    animation: patronusPulse 1s ease-out forwards;
    box-shadow: 0 0 40px rgba(200,220,255,0.5), 0 0 80px rgba(100,150,255,0.2);
}

@keyframes patronusPulse {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
    40% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
    80% { opacity: 0.8; transform: translate(-50%, -50%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -50%) scale(1.3); }
}
</style>
</head>
<body>

<!-- ===== TITLE SCREEN ===== -->
<div id="titleScreen">
    <div class="title-stars" id="starsContainer"></div>
    <div class="game-title">Wizard's Duel</div>
    <div class="game-subtitle">Harry Potter</div>

    <div class="selection-section">
        <div class="selection-label">Choose Your Wizard</div>
        <div class="character-grid" id="charGrid"></div>
    </div>

    <div class="selection-section">
        <div class="selection-label">Difficulty</div>
        <div class="difficulty-grid" id="diffGrid"></div>
    </div>

    <button class="start-btn" id="startBtn" onclick="startGame()">BEGIN DUEL</button>
</div>

<!-- ===== BATTLE SCREEN ===== -->
<div id="battleScreen">
    <div class="battle-header">
        <div class="fighter-info">
            <div class="fighter-name player-name" id="playerName"></div>
            <div class="bar-container">
                <div class="bar-fill hp-fill" id="playerHpBar"></div>
                <div class="bar-text" id="playerHpText"></div>
            </div>
            <div class="bar-container">
                <div class="bar-fill mana-fill" id="playerManaBar"></div>
                <div class="bar-text" id="playerManaText"></div>
            </div>
            <div class="status-effects" id="playerEffects"></div>
        </div>

        <div class="turn-indicator" id="turnIndicator">Turn 1</div>

        <div class="fighter-info">
            <div class="fighter-name enemy-name" id="enemyName"></div>
            <div class="bar-container">
                <div class="bar-fill hp-fill" id="enemyHpBar"></div>
                <div class="bar-text" id="enemyHpText"></div>
            </div>
            <div class="bar-container">
                <div class="bar-fill mana-fill" id="enemyManaBar"></div>
                <div class="bar-text" id="enemyManaText"></div>
            </div>
            <div class="status-effects right" id="enemyEffects"></div>
        </div>
    </div>

    <div class="arena" id="arena">
        <div class="wizard player-wizard" id="playerWizard">
            <div class="wizard-sprite" id="playerSprite"></div>
        </div>
        <div class="wizard enemy-wizard" id="enemyWizard">
            <div class="wizard-sprite" id="enemySprite"></div>
        </div>
    </div>

    <div class="battle-log" id="battleLog"></div>

    <div class="spell-panel">
        <div class="spell-cards" id="spellCards"></div>
    </div>
</div>

<!-- ===== RESULT SCREEN ===== -->
<div id="resultScreen">
    <div class="result-panel" id="resultPanel"></div>
</div>

<script>
// ===== GAME DATA =====

const SPELLS = [
    { id: 'stupefy', name: 'Stupefy', icon: '\u26A1', category: 'attack', mana: 8,
      desc: '15 damage', damage: 15 },
    { id: 'expelliarmus', name: 'Expelliarmus', icon: '\uD83D\uDD34', category: 'attack', mana: 10,
      desc: '12 dmg + drain 5 mana', damage: 12, manaDrain: 5 },
    { id: 'confringo', name: 'Confringo', icon: '\uD83D\uDD25', category: 'attack', mana: 18,
      desc: '28 dmg, ignores 50% shield', damage: 28, piercing: 0.5 },
    { id: 'sectumsempra', name: 'Sectumsempra', icon: '\uD83D\uDDE1\uFE0F', category: 'attack', mana: 22,
      desc: '20 dmg + 5 bleed/turn x3', damage: 20, bleed: { dmg: 5, turns: 3 } },
    { id: 'petrificus', name: 'Petrificus Totalus', icon: '\u2744\uFE0F', category: 'attack', mana: 14,
      desc: '10 dmg + 40% stun', damage: 10, stunChance: 0.4 },
    { id: 'protego', name: 'Protego', icon: '\uD83D\uDEE1\uFE0F', category: 'defense', mana: 10,
      desc: '-70% damage 2 turns', shieldTurns: 2, shieldReduction: 0.7 },
    { id: 'patronum', name: 'Expecto Patronum', icon: '\uD83E\uDD8C', category: 'defense', mana: 20,
      desc: 'Full block 1 turn + cleanse', fullBlock: 1, cleanse: true },
    { id: 'episkey', name: 'Episkey', icon: '\uD83D\uDC9A', category: 'utility', mana: 12,
      desc: 'Heal 20 HP', heal: 20 },
    { id: 'impedimenta', name: 'Impedimenta', icon: '\uD83C\uDF00', category: 'utility', mana: 10,
      desc: '-50% mana regen 3 turns', slowMana: { factor: 0.5, turns: 3 } },
    { id: 'aguamenti', name: 'Aguamenti', icon: '\uD83D\uDCA7', category: 'utility', mana: 6,
      desc: '8 dmg + restore 4 mana', damage: 8, manaRestore: 4 },
];

const CHARACTERS = [
    { id: 'harry', name: 'Harry Potter', icon: '\uD83E\uDDD9', trait: 'Balanced',
      hp: 100, mana: 50, regen: 8 },
    { id: 'hermione', name: 'Hermione Granger', icon: '\uD83E\uDDD9\u200D\u2640\uFE0F', trait: 'Mana-focused',
      hp: 85, mana: 65, regen: 10 },
    { id: 'ron', name: 'Ron Weasley', icon: '\uD83E\uDDD9\u200D\u2642\uFE0F', trait: 'Tanky',
      hp: 110, mana: 45, regen: 7 },
];

const OPPONENTS = {
    apprentice: { id: 'draco', name: 'Draco Malfoy', icon: '\uD83E\uDDB9', trait: 'Balanced',
      hp: 90, mana: 50, regen: 7, profile: 'balanced' },
    auror: { id: 'bellatrix', name: 'Bellatrix Lestrange', icon: '\uD83E\uDDB9\u200D\u2640\uFE0F', trait: 'Aggressive',
      hp: 100, mana: 55, regen: 8, profile: 'aggressive' },
    darklord: { id: 'voldemort', name: 'Lord Voldemort', icon: '\uD83D\uDC80', trait: 'Strategic',
      hp: 120, mana: 65, regen: 10, profile: 'strategic' },
};

const DIFFICULTIES = [
    { id: 'apprentice', name: 'Apprentice', desc: 'Draco Malfoy' },
    { id: 'auror', name: 'Auror', desc: 'Bellatrix Lestrange' },
    { id: 'darklord', name: 'Dark Lord', desc: 'Lord Voldemort' },
];

// ===== GAME STATE =====
let state = {
    screen: 'title',
    selectedChar: 0,
    selectedDiff: 0,
    player: null,
    enemy: null,
    turn: 1,
    playerTurn: true,
    animating: false,
    stats: { damageDealt: 0, damageTaken: 0, spellsCast: 0, turnsPlayed: 0 },
};

// ===== INITIALIZATION =====

function init() {
    createStars();
    renderCharacterGrid();
    renderDifficultyGrid();
}

function createStars() {
    const container = document.getElementById('starsContainer');
    for (let i = 0; i < 80; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        star.style.animationDuration = (2 + Math.random() * 3) + 's';
        star.style.width = star.style.height = (1 + Math.random() * 2) + 'px';
        container.appendChild(star);
    }
}

function renderCharacterGrid() {
    const grid = document.getElementById('charGrid');
    grid.innerHTML = CHARACTERS.map((c, i) =>
        `<div class="char-card${i === state.selectedChar ? ' selected' : ''}" onclick="selectChar(${i})">
            <div class="char-icon">${c.icon}</div>
            <div class="char-name">${c.name}</div>
            <div class="char-trait">${c.trait}</div>
            <div class="char-stats">HP: ${c.hp} | Mana: ${c.mana}<br>Regen: ${c.regen}/turn</div>
        </div>`
    ).join('');
}

function renderDifficultyGrid() {
    const grid = document.getElementById('diffGrid');
    grid.innerHTML = DIFFICULTIES.map((d, i) =>
        `<div class="diff-btn${i === state.selectedDiff ? ' selected' : ''}" onclick="selectDiff(${i})">
            ${d.name}<br><small style="color:var(--text-dim)">${d.desc}</small>
        </div>`
    ).join('');
}

function selectChar(i) {
    state.selectedChar = i;
    renderCharacterGrid();
}

function selectDiff(i) {
    state.selectedDiff = i;
    renderDifficultyGrid();
}

// ===== FIGHTER FACTORY =====

function createFighter(template) {
    return {
        name: template.name,
        icon: template.icon,
        maxHp: template.hp,
        hp: template.hp,
        maxMana: template.mana,
        mana: template.mana,
        regen: template.regen,
        profile: template.profile || null,
        effects: {
            shield: 0,         // turns remaining
            shieldReduction: 0,
            fullBlock: 0,      // turns of full block
            bleed: 0,          // turns remaining
            bleedDmg: 0,
            stun: 0,           // turns remaining
            slowMana: 0,       // turns remaining
            slowManaFactor: 1,
        },
    };
}

// ===== START GAME =====

function startGame() {
    const charTemplate = CHARACTERS[state.selectedChar];
    const diffId = DIFFICULTIES[state.selectedDiff].id;
    const oppTemplate = OPPONENTS[diffId];

    state.player = createFighter(charTemplate);
    state.enemy = createFighter(oppTemplate);
    state.turn = 1;
    state.playerTurn = true;
    state.animating = false;
    state.stats = { damageDealt: 0, damageTaken: 0, spellsCast: 0, turnsPlayed: 0 };

    document.getElementById('titleScreen').style.display = 'none';
    document.getElementById('battleScreen').style.display = 'flex';
    document.getElementById('resultScreen').style.display = 'none';
    document.getElementById('battleLog').innerHTML = '';

    addLog(`The duel between <span class="log-player">${state.player.name}</span> and <span class="log-enemy">${state.enemy.name}</span> begins!`, 'info');

    updateUI();
    renderSpellCards();
}

// ===== UI UPDATES =====

function updateUI() {
    const p = state.player;
    const e = state.enemy;

    document.getElementById('playerName').textContent = p.name;
    document.getElementById('enemyName').textContent = e.name;
    document.getElementById('playerSprite').textContent = p.icon;
    document.getElementById('enemySprite').textContent = e.icon;

    updateBar('playerHpBar', 'playerHpText', p.hp, p.maxHp, 'HP');
    updateBar('enemyHpBar', 'enemyHpText', e.hp, e.maxHp, 'HP');
    updateBar('playerManaBar', 'playerManaText', p.mana, p.maxMana, 'Mana');
    updateBar('enemyManaBar', 'enemyManaText', e.mana, e.maxMana, 'Mana');

    document.getElementById('turnIndicator').textContent = 'Turn ' + state.turn;

    renderEffects('playerEffects', p.effects);
    renderEffects('enemyEffects', e.effects);
    updateSpellCardStates();
}

function updateBar(barId, textId, current, max, label) {
    const pct = Math.max(0, current / max * 100);
    const bar = document.getElementById(barId);
    bar.style.width = pct + '%';

    if (label === 'HP') {
        bar.className = 'bar-fill hp-fill';
        if (pct <= 25) bar.classList.add('low');
        else if (pct <= 50) bar.classList.add('medium');
    }

    document.getElementById(textId).textContent = `${Math.ceil(current)} / ${max} ${label}`;
}

function renderEffects(containerId, effects) {
    const el = document.getElementById(containerId);
    let html = '';
    if (effects.shield > 0) html += `<span class="status-badge badge-shield">Shield ${effects.shield}t</span>`;
    if (effects.fullBlock > 0) html += `<span class="status-badge badge-block">Block ${effects.fullBlock}t</span>`;
    if (effects.bleed > 0) html += `<span class="status-badge badge-bleed">Bleed ${effects.bleed}t</span>`;
    if (effects.stun > 0) html += `<span class="status-badge badge-stun">Stun ${effects.stun}t</span>`;
    if (effects.slowMana > 0) html += `<span class="status-badge badge-slow">Slow ${effects.slowMana}t</span>`;
    el.innerHTML = html;
}

function renderSpellCards() {
    const container = document.getElementById('spellCards');
    container.innerHTML = SPELLS.map((spell, i) => {
        const affordable = state.player.mana >= spell.mana;
        const stunned = state.player.effects.stun > 0;
        const disabled = !affordable || stunned || state.animating || !state.playerTurn;
        const catClass = spell.category + '-card';
        return `<div class="spell-card ${catClass}${disabled ? ' disabled' : ''}"
                     onclick="${disabled ? '' : `castPlayerSpell(${i})`}">
            <div class="spell-icon">${spell.icon}</div>
            <div class="spell-name">${spell.name}</div>
            <div class="spell-cost">${spell.mana} Mana</div>
            <div class="spell-desc">${spell.desc}</div>
        </div>`;
    }).join('');
}

function updateSpellCardStates() {
    const cards = document.querySelectorAll('.spell-card');
    cards.forEach((card, i) => {
        const spell = SPELLS[i];
        const affordable = state.player.mana >= spell.mana;
        const stunned = state.player.effects.stun > 0;
        const disabled = !affordable || stunned || state.animating || !state.playerTurn;
        card.className = `spell-card ${spell.category}-card${disabled ? ' disabled' : ''}`;
        card.onclick = disabled ? null : () => castPlayerSpell(i);
    });
}

// ===== BATTLE LOG =====

function addLog(message, type) {
    const log = document.getElementById('battleLog');
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.innerHTML = `<span class="log-${type || 'info'}">${message}</span>`;
    log.appendChild(entry);
    log.scrollTop = log.scrollHeight;
}

// ===== FLOATING NUMBERS =====

function spawnFloat(text, type, targetSide) {
    const arena = document.getElementById('arena');
    const rect = arena.getBoundingClientRect();
    const el = document.createElement('div');
    el.className = `float-number float-${type}`;
    el.textContent = text;

    let x;
    if (targetSide === 'player') x = rect.width * 0.3;
    else if (targetSide === 'enemy') x = rect.width * 0.7;
    else x = rect.width * 0.5;

    el.style.left = (x + (Math.random() - 0.5) * 40) + 'px';
    el.style.top = (rect.height * 0.4 + (Math.random() - 0.5) * 20) + 'px';
    arena.appendChild(el);
    setTimeout(() => el.remove(), 1200);
}

// ===== SPELL ANIMATIONS =====

function playSpellAnimation(spell, fromPlayer) {
    return new Promise(resolve => {
        const arena = document.getElementById('arena');
        const arenaRect = arena.getBoundingClientRect();

        if (spell.heal) {
            const heal = document.createElement('div');
            heal.className = 'heal-effect';
            heal.textContent = '\u2728';
            const xPct = fromPlayer ? 0.3 : 0.7;
            heal.style.left = (arenaRect.width * xPct) + 'px';
            arena.appendChild(heal);
            setTimeout(() => heal.remove(), 1000);
            setTimeout(resolve, 600);
            return;
        }

        if (spell.id === 'protego') {
            const shield = document.createElement('div');
            shield.className = 'shield-effect';
            const xPct = fromPlayer ? 0.3 : 0.7;
            shield.style.left = (arenaRect.width * xPct) + 'px';
            arena.appendChild(shield);
            setTimeout(() => shield.remove(), 800);
            setTimeout(resolve, 500);
            return;
        }

        if (spell.id === 'patronum') {
            const patronus = document.createElement('div');
            patronus.className = 'patronus-shield';
            const xPct = fromPlayer ? 0.3 : 0.7;
            patronus.style.left = (arenaRect.width * xPct) + 'px';
            arena.appendChild(patronus);
            setTimeout(() => patronus.remove(), 1000);
            setTimeout(resolve, 600);
            return;
        }

        if (spell.damage) {
            // Beam animation
            const beam = document.createElement('div');
            beam.className = 'spell-beam ' + (fromPlayer ? 'beam-player' : 'beam-enemy');

            const colors = {
                stupefy: '#ff4444',
                expelliarmus: '#ff6644',
                confringo: '#ff8800',
                sectumsempra: '#cc0000',
                petrificus: '#88ccff',
                aguamenti: '#44aaff',
                impedimenta: '#aa66ff',
            };
            const color = colors[spell.id] || '#ffaa00';
            beam.style.background = color;
            beam.style.color = color;
            arena.appendChild(beam);

            // Impact
            setTimeout(() => {
                beam.remove();
                const targetId = fromPlayer ? 'enemyWizard' : 'playerWizard';
                const target = document.getElementById(targetId);
                target.classList.add('shaking');
                setTimeout(() => target.classList.remove('shaking'), 400);

                // Explosion at impact
                if (spell.damage >= 20) {
                    const exp = document.createElement('div');
                    exp.className = 'explosion-effect';
                    const xPct = fromPlayer ? 0.7 : 0.3;
                    exp.style.left = (arenaRect.width * xPct) + 'px';
                    exp.style.background = `radial-gradient(circle, ${color}88 0%, ${color}22 60%, transparent 100%)`;
                    arena.appendChild(exp);
                    setTimeout(() => exp.remove(), 600);
                }
            }, 400);

            setTimeout(resolve, 600);
            return;
        }

        // Utility spell with no damage (impedimenta on its own)
        if (spell.id === 'impedimenta') {
            const beam = document.createElement('div');
            beam.className = 'spell-beam ' + (fromPlayer ? 'beam-player' : 'beam-enemy');
            beam.style.background = '#aa66ff';
            beam.style.color = '#aa66ff';
            arena.appendChild(beam);
            setTimeout(() => {
                beam.remove();
                const targetId = fromPlayer ? 'enemyWizard' : 'playerWizard';
                document.getElementById(targetId).classList.add('shaking');
                setTimeout(() => document.getElementById(targetId).classList.remove('shaking'), 400);
            }, 400);
            setTimeout(resolve, 600);
            return;
        }

        setTimeout(resolve, 300);
    });
}

// ===== COMBAT LOGIC =====

function applyDamage(attacker, defender, baseDamage, spell) {
    let damage = baseDamage;

    // Full block
    if (defender.effects.fullBlock > 0) {
        spawnFloat('BLOCKED!', 'miss', defender === state.player ? 'player' : 'enemy');
        addLog(`The spell is completely blocked!`, 'effect');
        return 0;
    }

    // Shield reduction
    if (defender.effects.shield > 0) {
        let reduction = defender.effects.shieldReduction;
        if (spell && spell.piercing) {
            reduction *= (1 - spell.piercing);
        }
        damage *= (1 - reduction);
    }

    damage = Math.round(damage);
    if (damage < 1) damage = 1;

    defender.hp = Math.max(0, defender.hp - damage);
    spawnFloat('-' + damage, 'damage', defender === state.player ? 'player' : 'enemy');
    return damage;
}

function resolveSpell(spell, caster, target, casterIsPlayer) {
    let logName = casterIsPlayer
        ? `<span class="log-player">${caster.name}</span>`
        : `<span class="log-enemy">${caster.name}</span>`;

    addLog(`${logName} casts <b>${spell.name}</b>!`, casterIsPlayer ? 'player' : 'enemy');

    // Spend mana
    caster.mana -= spell.mana;

    // Mana restore (before using, for aguamenti)
    if (spell.manaRestore) {
        caster.mana = Math.min(caster.maxMana, caster.mana + spell.manaRestore);
        spawnFloat('+' + spell.manaRestore + ' MP', 'mana', casterIsPlayer ? 'player' : 'enemy');
    }

    // Damage
    if (spell.damage) {
        const dealt = applyDamage(caster, target, spell.damage, spell);
        if (casterIsPlayer) state.stats.damageDealt += dealt;
        else state.stats.damageTaken += dealt;
    }

    // Mana drain
    if (spell.manaDrain) {
        target.mana = Math.max(0, target.mana - spell.manaDrain);
        spawnFloat('-' + spell.manaDrain + ' MP', 'mana', casterIsPlayer ? 'enemy' : 'player');
        addLog(`Drained ${spell.manaDrain} mana!`, 'effect');
    }

    // Bleed
    if (spell.bleed && target.effects.fullBlock <= 0) {
        target.effects.bleed = spell.bleed.turns;
        target.effects.bleedDmg = spell.bleed.dmg;
        spawnFloat('BLEED!', 'status', casterIsPlayer ? 'enemy' : 'player');
        addLog(`Applied bleeding for ${spell.bleed.turns} turns!`, 'effect');
    }

    // Stun chance
    if (spell.stunChance && target.effects.fullBlock <= 0) {
        if (Math.random() < spell.stunChance) {
            target.effects.stun = 1;
            spawnFloat('STUNNED!', 'status', casterIsPlayer ? 'enemy' : 'player');
            addLog(`${target.name} is stunned!`, 'effect');
        }
    }

    // Shield
    if (spell.shieldTurns) {
        caster.effects.shield = spell.shieldTurns;
        caster.effects.shieldReduction = spell.shieldReduction;
        addLog(`${caster.name} raises a magical shield!`, 'effect');
    }

    // Full block + cleanse
    if (spell.fullBlock) {
        caster.effects.fullBlock = spell.fullBlock;
        if (spell.cleanse) {
            caster.effects.bleed = 0;
            caster.effects.bleedDmg = 0;
            caster.effects.stun = 0;
            caster.effects.slowMana = 0;
            caster.effects.slowManaFactor = 1;
            addLog(`All negative effects cleansed!`, 'effect');
        }
    }

    // Heal
    if (spell.heal) {
        const healed = Math.min(spell.heal, caster.maxHp - caster.hp);
        caster.hp = Math.min(caster.maxHp, caster.hp + spell.heal);
        spawnFloat('+' + healed + ' HP', 'heal', casterIsPlayer ? 'player' : 'enemy');
        addLog(`Healed for ${healed} HP!`, 'effect');
    }

    // Slow mana
    if (spell.slowMana) {
        target.effects.slowMana = spell.slowMana.turns;
        target.effects.slowManaFactor = spell.slowMana.factor;
        spawnFloat('SLOWED!', 'status', casterIsPlayer ? 'enemy' : 'player');
        addLog(`${target.name}'s mana regeneration slowed!`, 'effect');
    }

    if (casterIsPlayer) state.stats.spellsCast++;
}

function tickEffects(fighter, isPlayer) {
    const eff = fighter.effects;
    const side = isPlayer ? 'player' : 'enemy';

    // Bleed tick
    if (eff.bleed > 0) {
        fighter.hp = Math.max(0, fighter.hp - eff.bleedDmg);
        spawnFloat('-' + eff.bleedDmg, 'damage', side);
        addLog(`${fighter.name} takes ${eff.bleedDmg} bleed damage!`, 'effect');
        eff.bleed--;
        if (eff.bleed <= 0) eff.bleedDmg = 0;
    }

    // Decrement shields
    if (eff.shield > 0) {
        eff.shield--;
        if (eff.shield <= 0) eff.shieldReduction = 0;
    }

    // Decrement full block
    if (eff.fullBlock > 0) {
        eff.fullBlock--;
    }

    // Decrement stun
    if (eff.stun > 0) {
        eff.stun--;
    }

    // Decrement slow mana
    if (eff.slowMana > 0) {
        eff.slowMana--;
        if (eff.slowMana <= 0) eff.slowManaFactor = 1;
    }

    // Mana regen
    let regen = fighter.regen;
    if (eff.slowManaFactor < 1) {
        regen = Math.round(regen * eff.slowManaFactor);
    }
    fighter.mana = Math.min(fighter.maxMana, fighter.mana + regen);
}

// ===== PLAYER TURN =====

async function castPlayerSpell(spellIndex) {
    if (state.animating || !state.playerTurn) return;
    const spell = SPELLS[spellIndex];
    if (state.player.mana < spell.mana) return;
    if (state.player.effects.stun > 0) return;

    state.animating = true;
    state.playerTurn = false;
    updateSpellCardStates();

    // Player's turn: tick effects then cast
    tickEffects(state.player, true);
    updateUI();

    if (state.player.hp <= 0) {
        endGame(false);
        return;
    }

    // Check if stunned after tick
    if (state.player.effects.stun > 0) {
        addLog(`<span class="log-player">${state.player.name}</span> is stunned and cannot act!`, 'info');
        await delay(800);
        await doEnemyTurn();
        return;
    }

    await playSpellAnimation(spell, true);
    resolveSpell(spell, state.player, state.enemy, true);
    updateUI();

    if (state.enemy.hp <= 0) {
        await delay(500);
        endGame(true);
        return;
    }

    await delay(600);
    await doEnemyTurn();
}

// ===== ENEMY TURN =====

async function doEnemyTurn() {
    tickEffects(state.enemy, false);
    updateUI();

    if (state.enemy.hp <= 0) {
        endGame(true);
        return;
    }

    // Check stun
    if (state.enemy.effects.stun > 0) {
        addLog(`<span class="log-enemy">${state.enemy.name}</span> is stunned and cannot act!`, 'info');
        await delay(800);
        finishTurn();
        return;
    }

    const spell = chooseAISpell();
    if (!spell) {
        addLog(`<span class="log-enemy">${state.enemy.name}</span> has no mana to cast!`, 'info');
        await delay(600);
        finishTurn();
        return;
    }

    await delay(400);
    await playSpellAnimation(spell, false);
    resolveSpell(spell, state.enemy, state.player, false);
    updateUI();

    if (state.player.hp <= 0) {
        await delay(500);
        endGame(false);
        return;
    }

    await delay(400);
    finishTurn();
}

function finishTurn() {
    state.turn++;
    state.playerTurn = true;
    state.animating = false;
    state.stats.turnsPlayed++;
    updateUI();
    renderSpellCards();
}

// ===== AI SPELL SELECTION =====

function chooseAISpell() {
    const e = state.enemy;
    const p = state.player;
    const profile = e.profile || 'balanced';

    const available = SPELLS.filter(s => e.mana >= s.mana);
    if (available.length === 0) return null;

    // Score each spell
    const scored = available.map(spell => {
        let score = 0;

        // Base damage value
        if (spell.damage) {
            let dmg = spell.damage;
            if (p.effects.fullBlock > 0) dmg = 0;
            else if (p.effects.shield > 0) {
                let red = p.effects.shieldReduction;
                if (spell.piercing) red *= (1 - spell.piercing);
                dmg *= (1 - red);
            }
            score += dmg * 2;

            // Bonus for killing blow
            if (dmg >= p.hp) score += 50;
        }

        // Bleed value
        if (spell.bleed) score += spell.bleed.dmg * spell.bleed.turns * 1.5;

        // Stun value
        if (spell.stunChance) score += spell.stunChance * 15;

        // Shield value
        if (spell.shieldTurns) {
            const hpPct = e.hp / e.maxHp;
            score += (1 - hpPct) * 20 + 8;
        }

        // Full block
        if (spell.fullBlock) {
            const hpPct = e.hp / e.maxHp;
            score += (1 - hpPct) * 30;
            if (e.effects.bleed > 0 || e.effects.slowMana > 0) score += 15;
        }

        // Heal value
        if (spell.heal) {
            const missing = e.maxHp - e.hp;
            score += Math.min(spell.heal, missing) * 1.5;
            if (e.hp < e.maxHp * 0.3) score += 20;
        }

        // Mana drain
        if (spell.manaDrain) score += 5;

        // Slow mana
        if (spell.slowMana) {
            if (p.effects.slowMana <= 0) score += 10;
            else score -= 10;
        }

        // Mana restore
        if (spell.manaRestore) {
            if (e.mana < e.maxMana * 0.3) score += 8;
        }

        // Efficiency: penalize expensive spells slightly
        score -= spell.mana * 0.3;

        // Profile adjustments
        if (profile === 'aggressive') {
            if (spell.category === 'attack') score *= 1.4;
            if (spell.category === 'defense') score *= 0.6;
        } else if (profile === 'strategic') {
            // Strategic: value efficiency and debuffs
            if (spell.bleed) score *= 1.3;
            if (spell.slowMana) score *= 1.3;
            if (spell.stunChance) score *= 1.2;
            // Better at using shields at right time
            if (spell.shieldTurns && e.hp < e.maxHp * 0.5) score *= 1.5;
        }

        // Add small random factor
        score += Math.random() * 6;

        return { spell, score };
    });

    scored.sort((a, b) => b.score - a.score);
    return scored[0].spell;
}

// ===== END GAME =====

function endGame(playerWon) {
    state.animating = true;

    setTimeout(() => {
        document.getElementById('resultScreen').style.display = 'flex';

        const panel = document.getElementById('resultPanel');
        panel.innerHTML = `
            <div class="result-title ${playerWon ? 'result-win' : 'result-lose'}">
                ${playerWon ? 'VICTORY!' : 'DEFEAT'}
            </div>
            <div class="result-subtitle">
                ${playerWon
                    ? `${state.player.name} has defeated ${state.enemy.name}!`
                    : `${state.enemy.name} has triumphed over ${state.player.name}...`}
            </div>
            <div class="result-stats">
                <div class="stat-item"><span class="stat-label">Turns: </span><span class="stat-value">${state.stats.turnsPlayed}</span></div>
                <div class="stat-item"><span class="stat-label">Spells Cast: </span><span class="stat-value">${state.stats.spellsCast}</span></div>
                <div class="stat-item"><span class="stat-label">Damage Dealt: </span><span class="stat-value">${state.stats.damageDealt}</span></div>
                <div class="stat-item"><span class="stat-label">Damage Taken: </span><span class="stat-value">${state.stats.damageTaken}</span></div>
                <div class="stat-item"><span class="stat-label">HP Remaining: </span><span class="stat-value">${Math.ceil(state.player.hp)} / ${state.player.maxHp}</span></div>
                <div class="stat-item"><span class="stat-label">Opponent HP: </span><span class="stat-value">${Math.ceil(state.enemy.hp)} / ${state.enemy.maxHp}</span></div>
            </div>
            <div class="result-buttons">
                <button class="result-btn" onclick="backToMenu()">Back to Menu</button>
                <button class="result-btn primary" onclick="duelAgain()">Duel Again</button>
            </div>
        `;
    }, 600);
}

function duelAgain() {
    document.getElementById('resultScreen').style.display = 'none';
    document.getElementById('battleScreen').style.display = 'none';
    startGame();
    document.getElementById('battleScreen').style.display = 'flex';
}

function backToMenu() {
    document.getElementById('resultScreen').style.display = 'none';
    document.getElementById('battleScreen').style.display = 'none';
    document.getElementById('titleScreen').style.display = 'flex';
    state.animating = false;
}

// ===== UTILITY =====

function delay(ms) {
    return new Promise(r => setTimeout(r, ms));
}

// ===== BOOT =====
init();
</script>
</body>
</html>

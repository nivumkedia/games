<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Top-Down Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
        }
        #gameCanvas {
            background: #16213e;
            border: 3px solid #0f3460;
            border-radius: 8px;
            cursor: crosshair;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #fff;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        #ui div {
            margin-bottom: 5px;
        }
        #healthBar {
            width: 200px;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #555;
        }
        #healthFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #e74c3c, #c0392b);
            transition: width 0.3s;
        }
        #coins {
            color: #f1c40f;
            font-weight: bold;
        }
        #shopHint {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #f1c40f;
            font-size: 16px;
            background: rgba(0,0,0,0.5);
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #f1c40f;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            display: none;
            border: 3px solid #e74c3c;
            z-index: 100;
        }
        #gameOver h1 {
            color: #e74c3c;
            font-size: 48px;
            margin-bottom: 20px;
        }
        #gameOver p {
            color: #fff;
            font-size: 24px;
            margin-bottom: 30px;
        }
        #restartBtn {
            padding: 15px 40px;
            font-size: 20px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        #restartBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(52, 152, 219, 0.5);
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #888;
            font-size: 14px;
        }

        /* Shop styles */
        #shop {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 30px;
            border-radius: 15px;
            display: none;
            border: 3px solid #f1c40f;
            z-index: 50;
            min-width: 500px;
        }
        #shop h2 {
            color: #f1c40f;
            font-size: 32px;
            margin-bottom: 10px;
            text-align: center;
        }
        #shopCoins {
            color: #f1c40f;
            font-size: 20px;
            text-align: center;
            margin-bottom: 20px;
        }
        .shop-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        .upgrade-item {
            background: #1a1a2e;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .upgrade-item:hover {
            border-color: #3498db;
            transform: scale(1.02);
        }
        .upgrade-item.maxed {
            border-color: #2ecc71;
            opacity: 0.7;
            cursor: default;
        }
        .upgrade-item.maxed:hover {
            transform: none;
        }
        .upgrade-item.cant-afford {
            opacity: 0.5;
        }
        .upgrade-name {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .upgrade-desc {
            color: #888;
            font-size: 12px;
            margin-bottom: 8px;
        }
        .upgrade-level {
            color: #3498db;
            font-size: 12px;
            margin-bottom: 5px;
        }
        .upgrade-cost {
            color: #f1c40f;
            font-size: 14px;
            font-weight: bold;
        }
        .upgrade-maxed {
            color: #2ecc71;
            font-size: 14px;
            font-weight: bold;
        }
        #closeShop {
            display: block;
            margin: 20px auto 0;
            padding: 10px 30px;
            font-size: 16px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #closeShop:hover {
            background: #c0392b;
        }
        .active-upgrades {
            position: absolute;
            top: 10px;
            left: 220px;
            display: flex;
            gap: 5px;
        }
        .upgrade-icon {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #fff;
            border: 2px solid #fff;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="900" height="600"></canvas>
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="wave">Wave: 1</div>
            <div id="coins">Coins: 0</div>
            <div id="healthBar"><div id="healthFill"></div></div>
        </div>
        <div class="active-upgrades" id="activeUpgrades"></div>
        <div id="shopHint">Press [E] for Shop</div>
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="restartBtn">Play Again</button>
        </div>
        <div id="shop">
            <h2>UPGRADE SHOP</h2>
            <div id="shopCoins">Coins: 0 | Points: 0</div>
            <div style="color: #888; font-size: 12px; text-align: center; margin-bottom: 10px;">Click to buy with coins, right-click to buy with points</div>
            <div class="shop-grid" id="shopGrid"></div>
            <button id="closeShop">Close [E]</button>
        </div>
        <div id="instructions">WASD to move | Mouse to aim | Click/Space to shoot | E for shop</div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const waveEl = document.getElementById('wave');
        const coinsEl = document.getElementById('coins');
        const healthFill = document.getElementById('healthFill');
        const gameOverEl = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const restartBtn = document.getElementById('restartBtn');
        const shopEl = document.getElementById('shop');
        const shopCoinsEl = document.getElementById('shopCoins');
        const shopGrid = document.getElementById('shopGrid');
        const closeShopBtn = document.getElementById('closeShop');
        const activeUpgradesEl = document.getElementById('activeUpgrades');

        // Game state
        let gameRunning = true;
        let shopOpen = false;
        let score = 0;
        let wave = 1;
        let coins = 0;
        let spawnTimer = 0;
        let spawnInterval = 120;

        // Camera
        const camera = {
            x: 0,
            y: 0
        };

        // Upgrades
        const upgrades = {
            autoShoot: { level: 0, maxLevel: 5, baseCost: 50, name: 'Auto Fire', desc: 'Automatically shoots at enemies', icon: 'A', color: '#e74c3c' },
            maxHealth: { level: 0, maxLevel: 10, baseCost: 30, name: 'Max Health', desc: '+25 maximum health per level', icon: 'H', color: '#2ecc71' },
            damage: { level: 0, maxLevel: 10, baseCost: 40, name: 'Damage', desc: '+1 damage per bullet', icon: 'D', color: '#e67e22' },
            fireRate: { level: 0, maxLevel: 8, baseCost: 35, name: 'Fire Rate', desc: 'Shoot faster', icon: 'F', color: '#9b59b6' },
            speed: { level: 0, maxLevel: 5, baseCost: 25, name: 'Move Speed', desc: 'Move faster', icon: 'S', color: '#3498db' },
            multiShot: { level: 0, maxLevel: 5, baseCost: 75, name: 'Multi Shot', desc: '+1 bullet per shot', icon: 'M', color: '#f1c40f' },
            bulletSpeed: { level: 0, maxLevel: 5, baseCost: 20, name: 'Bullet Speed', desc: 'Bullets travel faster', icon: 'B', color: '#1abc9c' },
            regen: { level: 0, maxLevel: 5, baseCost: 60, name: 'Regeneration', desc: 'Slowly regenerate health', icon: 'R', color: '#e91e63' },
            piercing: { level: 0, maxLevel: 3, baseCost: 100, name: 'Piercing', desc: 'Bullets pass through enemies', icon: 'P', color: '#00bcd4' },
            magnetRange: { level: 0, maxLevel: 5, baseCost: 40, name: 'Coin Magnet', desc: 'Collect coins from farther away', icon: 'C', color: '#ffc107' },
            armor: { level: 0, maxLevel: 5, baseCost: 50, name: 'Armor', desc: 'Reduce damage taken by 10%', icon: 'W', color: '#607d8b' },
            critChance: { level: 0, maxLevel: 5, baseCost: 60, name: 'Critical Hit', desc: '+10% chance for 3x damage', icon: 'X', color: '#ff5722' },
            explosiveBullets: { level: 0, maxLevel: 3, baseCost: 120, name: 'Explosive', desc: 'Bullets explode on hit', icon: 'E', color: '#ff9800' },
            vampirism: { level: 0, maxLevel: 3, baseCost: 80, name: 'Vampirism', desc: 'Heal 1 HP per kill', icon: 'V', color: '#9c27b0' },
            shield: { level: 0, maxLevel: 3, baseCost: 150, name: 'Shield', desc: 'Absorbs 1 hit every 10 seconds', icon: 'O', color: '#2196f3' },
            bulletSize: { level: 0, maxLevel: 5, baseCost: 30, name: 'Bullet Size', desc: 'Bigger bullets, easier hits', icon: 'Z', color: '#795548' },
            knockback: { level: 0, maxLevel: 3, baseCost: 45, name: 'Knockback', desc: 'Push enemies back on hit', icon: 'K', color: '#4caf50' },
            slowField: { level: 0, maxLevel: 3, baseCost: 90, name: 'Slow Aura', desc: 'Nearby enemies move slower', icon: 'L', color: '#00bcd4' },
            coinBonus: { level: 0, maxLevel: 5, baseCost: 55, name: 'Greed', desc: '+20% coins per kill', icon: 'G', color: '#ffd700' },
            xpBonus: { level: 0, maxLevel: 5, baseCost: 55, name: 'Hunter', desc: '+20% points per kill', icon: 'T', color: '#8bc34a' },
            dashCooldown: { level: 0, maxLevel: 3, baseCost: 70, name: 'Dash', desc: 'Press SHIFT to dash (shorter cooldown)', icon: 'Q', color: '#03a9f4' },
            homingBullets: { level: 0, maxLevel: 3, baseCost: 200, name: 'Homing', desc: 'Bullets track enemies slightly', icon: 'J', color: '#e040fb' },
            backShot: { level: 0, maxLevel: 2, baseCost: 80, name: 'Back Shot', desc: 'Also shoot behind you', icon: 'Y', color: '#ff4081' },
            orbitalShield: { level: 0, maxLevel: 3, baseCost: 100, name: 'Orbitals', desc: 'Spinning projectiles damage enemies', icon: 'U', color: '#7c4dff' }
        };

        function getUpgradeCost(key) {
            const u = upgrades[key];
            return Math.floor(u.baseCost * Math.pow(1.5, u.level));
        }

        // Player
        const player = {
            x: 0,
            y: 0,
            radius: 20,
            baseSpeed: 4,
            angle: 0,
            health: 100,
            maxHealth: 100,
            baseMaxHealth: 100,
            color: '#3498db',
            gunLength: 30,
            gunWidth: 8
        };

        // Input
        const keys = {};
        let mouseX = 0;
        let mouseY = 0;

        // Bullets
        const bullets = [];
        let baseBulletSpeed = 12;
        const bulletRadius = 5;
        let canShoot = true;
        let baseShootCooldown = 15;
        let shootTimer = 0;

        // Enemies
        const enemies = [];
        const enemyTypes = [
            { radius: 15, speed: 1.5, health: 1, color: '#e74c3c', points: 10, coins: 2 },
            { radius: 20, speed: 1, health: 2, color: '#e67e22', points: 20, coins: 4 },
            { radius: 25, speed: 0.7, health: 3, color: '#9b59b6', points: 30, coins: 6 },
            { radius: 30, speed: 0.5, health: 5, color: '#c0392b', points: 50, coins: 10 }
        ];

        // Particles
        const particles = [];

        // Coin pickups
        const coinPickups = [];

        // Powerups
        const powerups = [];
        const powerupTypes = [
            { type: 'invincibility', name: 'Invincibility', color: '#ffd700', duration: 300, icon: 'I' },
            { type: 'slowmo', name: 'Slow Motion', color: '#00bcd4', duration: 360, icon: 'S' },
            { type: 'rapidfire', name: 'Rapid Fire', color: '#ff5722', duration: 300, icon: 'R' },
            { type: 'megadamage', name: 'Mega Damage', color: '#9c27b0', duration: 240, icon: 'M' },
            { type: 'heal', name: 'Full Heal', color: '#4caf50', duration: 0, icon: '+' },
            { type: 'nuke', name: 'Nuke', color: '#f44336', duration: 0, icon: 'N' },
            { type: 'coinmagnet', name: 'Coin Magnet', color: '#ffeb3b', duration: 480, icon: 'C' },
            { type: 'ghost', name: 'Ghost', color: '#e0e0e0', duration: 300, icon: 'G' }
        ];

        // Active powerup effects
        const activePowerups = {
            invincibility: 0,
            slowmo: 0,
            rapidfire: 0,
            megadamage: 0,
            coinmagnet: 0,
            ghost: 0
        };

        let powerupSpawnTimer = 0;

        // Regen timer
        let regenTimer = 0;

        // Shield timer
        let shieldActive = true;
        let shieldTimer = 0;

        // Dash
        let canDash = true;
        let dashTimer = 0;
        let isDashing = false;
        let dashDuration = 0;
        let dashVx = 0;
        let dashVy = 0;

        // Orbitals
        let orbitalAngle = 0;

        function spawnPowerup() {
            const angle = Math.random() * Math.PI * 2;
            const dist = 200 + Math.random() * 300;
            const x = player.x + Math.cos(angle) * dist;
            const y = player.y + Math.sin(angle) * dist;
            const type = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];

            powerups.push({
                x: x,
                y: y,
                type: type.type,
                name: type.name,
                color: type.color,
                duration: type.duration,
                icon: type.icon,
                radius: 15,
                bobOffset: Math.random() * Math.PI * 2
            });
        }

        function activatePowerup(p) {
            switch (p.type) {
                case 'invincibility':
                case 'slowmo':
                case 'rapidfire':
                case 'megadamage':
                case 'coinmagnet':
                case 'ghost':
                    activePowerups[p.type] = p.duration;
                    break;
                case 'heal':
                    player.health = player.maxHealth;
                    updateUI();
                    createExplosion(player.x, player.y, '#4caf50', 20);
                    break;
                case 'nuke':
                    // Kill all enemies on screen
                    for (let i = enemies.length - 1; i >= 0; i--) {
                        const e = enemies[i];
                        createExplosion(e.x, e.y, e.color, 10);
                        const pointReward = Math.floor(e.points * getPointMultiplier());
                        score += pointReward;
                        const coinReward = Math.floor((e.coins + Math.floor(e.maxHealth / 2) + Math.floor(wave / 2)) * getCoinMultiplier());
                        spawnCoin(e.x, e.y, coinReward);
                    }
                    enemies.length = 0;
                    scoreEl.textContent = `Score: ${score}`;
                    createExplosion(player.x, player.y, '#f44336', 30);
                    break;
            }
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (['w', 'a', 's', 'd', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' ', 'shift'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
            if (e.key === ' ' && gameRunning && !shopOpen && canShoot) {
                shoot();
                canShoot = false;
                shootTimer = getShootCooldown();
            }
            if (e.key.toLowerCase() === 'e' && gameRunning) {
                toggleShop();
            }
            if (e.key === 'Shift' && gameRunning && !shopOpen && canDash && upgrades.dashCooldown.level > 0) {
                performDash();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left + camera.x;
            mouseY = e.clientY - rect.top + camera.y;
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameRunning && !shopOpen && canShoot) {
                shoot();
                canShoot = false;
                shootTimer = getShootCooldown();
            }
        });

        restartBtn.addEventListener('click', restartGame);
        closeShopBtn.addEventListener('click', toggleShop);

        function toggleShop() {
            shopOpen = !shopOpen;
            shopEl.style.display = shopOpen ? 'block' : 'none';
            if (shopOpen) {
                renderShop();
            }
        }

        function getPointCost(key) {
            return getUpgradeCost(key) * 5; // Points cost 5x more than coins
        }

        function renderShop() {
            shopCoinsEl.textContent = `Coins: ${coins} | Points: ${score}`;
            shopGrid.innerHTML = '';

            for (const [key, u] of Object.entries(upgrades)) {
                const coinCost = getUpgradeCost(key);
                const pointCost = getPointCost(key);
                const isMaxed = u.level >= u.maxLevel;
                const canAffordCoins = coins >= coinCost;
                const canAffordPoints = score >= pointCost;

                const item = document.createElement('div');
                item.className = 'upgrade-item';
                if (isMaxed) item.classList.add('maxed');
                else if (!canAffordCoins && !canAffordPoints) item.classList.add('cant-afford');

                item.innerHTML = `
                    <div class="upgrade-name">${u.icon} ${u.name}</div>
                    <div class="upgrade-desc">${u.desc}</div>
                    <div class="upgrade-level">Level: ${u.level} / ${u.maxLevel}</div>
                    ${isMaxed ? '<div class="upgrade-maxed">MAXED</div>' : `
                        <div class="upgrade-cost" style="color: ${canAffordCoins ? '#f1c40f' : '#666'}">${coinCost} coins (click)</div>
                        <div class="upgrade-cost" style="color: ${canAffordPoints ? '#3498db' : '#666'}">${pointCost} points (right-click)</div>
                    `}
                `;

                if (!isMaxed) {
                    item.addEventListener('click', () => buyUpgrade(key, 'coins'));
                    item.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        buyUpgrade(key, 'points');
                    });
                }

                shopGrid.appendChild(item);
            }
        }

        function buyUpgrade(key, currency) {
            if (upgrades[key].level >= upgrades[key].maxLevel) return;

            if (currency === 'coins') {
                const cost = getUpgradeCost(key);
                if (coins >= cost) {
                    coins -= cost;
                    upgrades[key].level++;
                }
            } else if (currency === 'points') {
                const cost = getPointCost(key);
                if (score >= cost) {
                    score -= cost;
                    scoreEl.textContent = `Score: ${score}`;
                    upgrades[key].level++;
                }
            }

            applyUpgrades();
            updateUI();
            renderShop();
            updateActiveUpgrades();
        }

        function applyUpgrades() {
            // Max Health
            const oldMaxHealth = player.maxHealth;
            player.maxHealth = player.baseMaxHealth + (upgrades.maxHealth.level * 25);
            if (player.maxHealth > oldMaxHealth) {
                player.health += (player.maxHealth - oldMaxHealth);
            }
            player.health = Math.min(player.health, player.maxHealth);
        }

        function getShootCooldown() {
            return Math.max(5, baseShootCooldown - (upgrades.fireRate.level * 1.5));
        }

        function getPlayerSpeed() {
            return player.baseSpeed + (upgrades.speed.level * 0.5);
        }

        function getBulletSpeed() {
            return baseBulletSpeed + (upgrades.bulletSpeed.level * 2);
        }

        function getBulletDamage() {
            return 1 + upgrades.damage.level;
        }

        function getBulletCount() {
            return 1 + upgrades.multiShot.level;
        }

        function getBulletRadius() {
            return bulletRadius + (upgrades.bulletSize.level * 2);
        }

        function getMagnetRange() {
            return 100 + (upgrades.magnetRange.level * 50);
        }

        function getArmorReduction() {
            return 1 - (upgrades.armor.level * 0.1);
        }

        function getCritChance() {
            return upgrades.critChance.level * 0.1;
        }

        function getCoinMultiplier() {
            return 1 + (upgrades.coinBonus.level * 0.2);
        }

        function getPointMultiplier() {
            return 1 + (upgrades.xpBonus.level * 0.2);
        }

        function getDashCooldown() {
            return 300 - (upgrades.dashCooldown.level * 80); // 5 sec base, -1.3 sec per level
        }

        function performDash() {
            if (!canDash || upgrades.dashCooldown.level === 0) return;

            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;

            if (dx === 0 && dy === 0) {
                dx = Math.cos(player.angle);
                dy = Math.sin(player.angle);
            } else {
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
            }

            isDashing = true;
            dashDuration = 10;
            dashVx = dx * 15;
            dashVy = dy * 15;
            canDash = false;
            dashTimer = getDashCooldown();

            // Dash particles
            for (let i = 0; i < 10; i++) {
                particles.push({
                    x: player.x,
                    y: player.y,
                    vx: -dx * 2 + (Math.random() - 0.5) * 2,
                    vy: -dy * 2 + (Math.random() - 0.5) * 2,
                    radius: 5,
                    life: 20,
                    color: '#03a9f4'
                });
            }
        }

        function updateActiveUpgrades() {
            activeUpgradesEl.innerHTML = '';
            for (const [key, u] of Object.entries(upgrades)) {
                if (u.level > 0) {
                    const icon = document.createElement('div');
                    icon.className = 'upgrade-icon';
                    icon.style.background = u.color;
                    icon.textContent = u.level;
                    icon.title = `${u.name} Lv.${u.level}`;
                    activeUpgradesEl.appendChild(icon);
                }
            }
        }

        function shoot() {
            const angle = player.angle;
            const gunTipX = player.x + Math.cos(angle) * player.gunLength;
            const gunTipY = player.y + Math.sin(angle) * player.gunLength;
            const bulletCount = getBulletCount();
            const spread = 0.15; // radians between bullets

            // Calculate crit for this shot
            const isCrit = Math.random() < getCritChance();
            const damage = isCrit ? getBulletDamage() * 3 : getBulletDamage();

            for (let i = 0; i < bulletCount; i++) {
                let bulletAngle = angle;
                if (bulletCount > 1) {
                    bulletAngle = angle + (i - (bulletCount - 1) / 2) * spread;
                }

                bullets.push({
                    x: gunTipX,
                    y: gunTipY,
                    vx: Math.cos(bulletAngle) * getBulletSpeed(),
                    vy: Math.sin(bulletAngle) * getBulletSpeed(),
                    radius: getBulletRadius(),
                    damage: damage,
                    piercing: upgrades.piercing.level,
                    homing: upgrades.homingBullets.level > 0,
                    isCrit: isCrit
                });
            }

            // Back shot
            if (upgrades.backShot.level > 0) {
                const backAngle = angle + Math.PI;
                const backCount = upgrades.backShot.level;
                for (let i = 0; i < backCount; i++) {
                    let bulletAngle = backAngle;
                    if (backCount > 1) {
                        bulletAngle = backAngle + (i - (backCount - 1) / 2) * spread;
                    }
                    bullets.push({
                        x: player.x + Math.cos(backAngle) * player.gunLength,
                        y: player.y + Math.sin(backAngle) * player.gunLength,
                        vx: Math.cos(bulletAngle) * getBulletSpeed(),
                        vy: Math.sin(bulletAngle) * getBulletSpeed(),
                        radius: getBulletRadius(),
                        damage: damage,
                        piercing: upgrades.piercing.level,
                        homing: upgrades.homingBullets.level > 0,
                        isCrit: isCrit
                    });
                }
            }

            // Muzzle flash particles
            for (let i = 0; i < 5; i++) {
                particles.push({
                    x: gunTipX,
                    y: gunTipY,
                    vx: Math.cos(angle + (Math.random() - 0.5)) * (3 + Math.random() * 3),
                    vy: Math.sin(angle + (Math.random() - 0.5)) * (3 + Math.random() * 3),
                    radius: 3 + Math.random() * 3,
                    life: 15,
                    color: isCrit ? '#ff5722' : '#f39c12'
                });
            }
        }

        function spawnEnemy() {
            // Spawn enemies around the player, just outside the visible area
            const spawnDist = 400; // Distance from player to spawn
            const angle = Math.random() * Math.PI * 2;
            let x = player.x + Math.cos(angle) * spawnDist;
            let y = player.y + Math.sin(angle) * spawnDist;

            // Select enemy type based on wave
            const maxType = Math.min(Math.floor(wave / 2), enemyTypes.length - 1);
            const typeIndex = Math.floor(Math.random() * (maxType + 1));
            const type = enemyTypes[typeIndex];

            enemies.push({
                x: x,
                y: y,
                radius: type.radius,
                speed: type.speed + (wave * 0.05),
                health: type.health + Math.floor(wave / 3),
                maxHealth: type.health + Math.floor(wave / 3),
                color: type.color,
                points: type.points,
                coins: type.coins
            });
        }

        function createExplosion(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 / count) * i;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (2 + Math.random() * 3),
                    vy: Math.sin(angle) * (2 + Math.random() * 3),
                    radius: 3 + Math.random() * 4,
                    life: 30 + Math.random() * 20,
                    color: color
                });
            }
        }

        function spawnCoin(x, y, amount) {
            coinPickups.push({
                x: x,
                y: y,
                amount: amount,
                radius: 10,
                life: 300, // 5 seconds at 60fps
                bobOffset: Math.random() * Math.PI * 2
            });
        }

        function updateUI() {
            coinsEl.textContent = `Coins: ${coins}`;
            healthFill.style.width = `${(player.health / player.maxHealth) * 100}%`;
        }

        function update() {
            if (!gameRunning || shopOpen) return;

            // Auto-shoot
            if (upgrades.autoShoot.level > 0 && canShoot && enemies.length > 0) {
                // Find nearest enemy
                let nearest = null;
                let nearestDist = Infinity;
                for (const e of enemies) {
                    const dist = Math.hypot(e.x - player.x, e.y - player.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = e;
                    }
                }
                if (nearest) {
                    player.angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
                    shoot();
                    canShoot = false;
                    // Auto-shoot is faster based on level
                    shootTimer = getShootCooldown() / (1 + upgrades.autoShoot.level * 0.3);
                }
            }

            // Regeneration
            if (upgrades.regen.level > 0) {
                regenTimer++;
                if (regenTimer >= 60) { // Every second
                    regenTimer = 0;
                    player.health = Math.min(player.maxHealth, player.health + upgrades.regen.level);
                    updateUI();
                }
            }

            // Shield recharge
            if (upgrades.shield.level > 0 && !shieldActive) {
                shieldTimer--;
                if (shieldTimer <= 0) {
                    shieldActive = true;
                }
            }

            // Dash cooldown
            if (!canDash) {
                dashTimer--;
                if (dashTimer <= 0) {
                    canDash = true;
                }
            }

            // Dash movement
            if (isDashing) {
                player.x += dashVx;
                player.y += dashVy;
                dashDuration--;
                if (dashDuration <= 0) {
                    isDashing = false;
                }
            }

            // Player movement
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;

            if (!isDashing && (dx !== 0 || dy !== 0)) {
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
                player.x += dx * getPlayerSpeed();
                player.y += dy * getPlayerSpeed();
            }

            // Update camera to follow player
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            // Player angle towards mouse (only if not auto-shooting or no enemies)
            if (upgrades.autoShoot.level === 0 || enemies.length === 0) {
                player.angle = Math.atan2(mouseY - player.y, mouseX - player.x);
            }

            // Shoot cooldown
            if (!canShoot) {
                shootTimer--;
                if (shootTimer <= 0) canShoot = true;
            }

            // Update orbitals
            if (upgrades.orbitalShield.level > 0) {
                orbitalAngle += 0.05;
                const orbitalCount = upgrades.orbitalShield.level + 1;
                const orbitalDist = 50;

                for (let i = 0; i < orbitalCount; i++) {
                    const angle = orbitalAngle + (Math.PI * 2 / orbitalCount) * i;
                    const ox = player.x + Math.cos(angle) * orbitalDist;
                    const oy = player.y + Math.sin(angle) * orbitalDist;

                    // Check orbital collision with enemies
                    for (let j = enemies.length - 1; j >= 0; j--) {
                        const e = enemies[j];
                        const dist = Math.hypot(ox - e.x, oy - e.y);
                        if (dist < 15 + e.radius) {
                            e.health -= 1;
                            createExplosion(ox, oy, '#7c4dff', 3);
                            if (e.health <= 0) {
                                createExplosion(e.x, e.y, e.color, 15);
                                const pointReward = Math.floor(e.points * getPointMultiplier());
                                score += pointReward;
                                scoreEl.textContent = `Score: ${score}`;
                                const coinReward = Math.floor((e.coins + Math.floor(e.maxHealth / 2) + Math.floor(wave / 2)) * getCoinMultiplier());
                                spawnCoin(e.x, e.y, coinReward);
                                if (upgrades.vampirism.level > 0) {
                                    player.health = Math.min(player.maxHealth, player.health + upgrades.vampirism.level);
                                    updateUI();
                                }
                                enemies.splice(j, 1);
                            }
                        }
                    }
                }
            }

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];

                // Homing bullets
                if (b.homing && enemies.length > 0) {
                    let nearest = null;
                    let nearestDist = Infinity;
                    for (const e of enemies) {
                        const dist = Math.hypot(e.x - b.x, e.y - b.y);
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearest = e;
                        }
                    }
                    if (nearest && nearestDist < 200) {
                        const targetAngle = Math.atan2(nearest.y - b.y, nearest.x - b.x);
                        const currentAngle = Math.atan2(b.vy, b.vx);
                        let angleDiff = targetAngle - currentAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        const turnSpeed = 0.05 * upgrades.homingBullets.level;
                        const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), turnSpeed);
                        const speed = Math.hypot(b.vx, b.vy);
                        b.vx = Math.cos(newAngle) * speed;
                        b.vy = Math.sin(newAngle) * speed;
                    }
                }

                b.x += b.vx;
                b.y += b.vy;

                // Remove bullets too far from player
                const distFromPlayer = Math.hypot(b.x - player.x, b.y - player.y);
                if (distFromPlayer > 800) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with enemies
                let bulletHit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (b.hitEnemies && b.hitEnemies.includes(j)) continue; // Already hit this enemy (piercing)

                    const dist = Math.hypot(b.x - e.x, b.y - e.y);
                    if (dist < b.radius + e.radius) {
                        e.health -= b.damage;

                        // Knockback
                        if (upgrades.knockback.level > 0) {
                            const knockAngle = Math.atan2(e.y - player.y, e.x - player.x);
                            const knockForce = upgrades.knockback.level * 10;
                            e.x += Math.cos(knockAngle) * knockForce;
                            e.y += Math.sin(knockAngle) * knockForce;
                        }

                        // Hit particles
                        const particleColor = b.isCrit ? '#ff5722' : '#fff';
                        for (let k = 0; k < (b.isCrit ? 6 : 3); k++) {
                            particles.push({
                                x: b.x,
                                y: b.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                radius: 2 + Math.random() * 2,
                                life: 15,
                                color: particleColor
                            });
                        }

                        // Explosive bullets
                        if (upgrades.explosiveBullets.level > 0) {
                            const explosionRadius = 30 + upgrades.explosiveBullets.level * 15;
                            createExplosion(b.x, b.y, '#ff9800', 8);
                            // Damage nearby enemies
                            for (let k = enemies.length - 1; k >= 0; k--) {
                                if (k === j) continue;
                                const e2 = enemies[k];
                                const dist2 = Math.hypot(b.x - e2.x, b.y - e2.y);
                                if (dist2 < explosionRadius) {
                                    e2.health -= Math.ceil(b.damage / 2);
                                    if (e2.health <= 0) {
                                        createExplosion(e2.x, e2.y, e2.color, 10);
                                        const pointReward = Math.floor(e2.points * getPointMultiplier());
                                        score += pointReward;
                                        const coinReward = Math.floor((e2.coins + Math.floor(e2.maxHealth / 2) + Math.floor(wave / 2)) * getCoinMultiplier());
                                        spawnCoin(e2.x, e2.y, coinReward);
                                        if (upgrades.vampirism.level > 0) {
                                            player.health = Math.min(player.maxHealth, player.health + upgrades.vampirism.level);
                                        }
                                        enemies.splice(k, 1);
                                        if (k < j) j--;
                                    }
                                }
                            }
                        }

                        if (e.health <= 0) {
                            createExplosion(e.x, e.y, e.color, 15);
                            const pointReward = Math.floor(e.points * getPointMultiplier());
                            score += pointReward;
                            scoreEl.textContent = `Score: ${score}`;
                            // Coins scale with enemy size and wave
                            const coinReward = Math.floor((e.coins + Math.floor(e.maxHealth / 2) + Math.floor(wave / 2)) * getCoinMultiplier());
                            spawnCoin(e.x, e.y, coinReward);
                            // Vampirism
                            if (upgrades.vampirism.level > 0) {
                                player.health = Math.min(player.maxHealth, player.health + upgrades.vampirism.level);
                                updateUI();
                            }
                            enemies.splice(j, 1);
                        }

                        // Piercing: track hit enemies and continue
                        if (b.piercing > 0) {
                            if (!b.hitEnemies) b.hitEnemies = [];
                            b.hitEnemies.push(j);
                            b.piercing--;
                        } else {
                            bulletHit = true;
                        }
                        break;
                    }
                }
                if (bulletHit) {
                    bullets.splice(i, 1);
                }
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];

                // Remove enemies too far from player
                const distFromPlayer = Math.hypot(e.x - player.x, e.y - player.y);
                if (distFromPlayer > 800) {
                    enemies.splice(i, 1);
                    continue;
                }

                const angle = Math.atan2(player.y - e.y, player.x - e.x);

                // Slow aura effect
                let speedMult = 1;
                if (upgrades.slowField.level > 0) {
                    const slowRadius = 100 + upgrades.slowField.level * 30;
                    if (distFromPlayer < slowRadius) {
                        speedMult = 1 - (upgrades.slowField.level * 0.2);
                    }
                }

                e.x += Math.cos(angle) * e.speed * speedMult;
                e.y += Math.sin(angle) * e.speed * speedMult;

                // Check collision with player
                const dist = Math.hypot(e.x - player.x, e.y - player.y);
                if (dist < e.radius + player.radius) {
                    // Shield absorbs hit
                    if (upgrades.shield.level > 0 && shieldActive) {
                        shieldActive = false;
                        shieldTimer = 600 - (upgrades.shield.level * 100); // 10 sec base, -1.67 sec per level
                        createExplosion(player.x, player.y, '#2196f3', 15);
                    } else {
                        const damage = Math.floor(10 * getArmorReduction());
                        player.health -= damage;
                        updateUI();
                    }
                    createExplosion(e.x, e.y, e.color, 10);
                    enemies.splice(i, 1);

                    if (player.health <= 0) {
                        gameOver();
                    }
                }
            }

            // Update coin pickups
            for (let i = coinPickups.length - 1; i >= 0; i--) {
                const c = coinPickups[i];

                // Move towards player if close
                const dist = Math.hypot(c.x - player.x, c.y - player.y);

                // Remove coins too far from player
                if (dist > 600) {
                    coinPickups.splice(i, 1);
                    continue;
                }

                if (dist < getMagnetRange()) {
                    const angle = Math.atan2(player.y - c.y, player.x - c.x);
                    c.x += Math.cos(angle) * 5;
                    c.y += Math.sin(angle) * 5;
                }

                // Collect coin
                if (dist < player.radius + c.radius) {
                    coins += c.amount;
                    updateUI();
                    coinPickups.splice(i, 1);
                    // Coin collect particles
                    for (let k = 0; k < 5; k++) {
                        particles.push({
                            x: c.x,
                            y: c.y,
                            vx: (Math.random() - 0.5) * 3,
                            vy: (Math.random() - 0.5) * 3,
                            radius: 3,
                            life: 20,
                            color: '#f1c40f'
                        });
                    }
                }
            }

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life--;
                p.radius *= 0.97;
                if (p.life <= 0 || p.radius < 0.5) {
                    particles.splice(i, 1);
                }
            }

            // Spawn enemies (limit max on screen based on wave)
            const maxEnemies = 5 + Math.floor(wave / 2); // Starts at 5, slowly increases
            spawnTimer++;
            if (spawnTimer >= spawnInterval && enemies.length < maxEnemies) {
                spawnTimer = 0;
                spawnEnemy();

                // Increase difficulty
                if (score > wave * 100) {
                    wave++;
                    waveEl.textContent = `Wave: ${wave}`;
                    spawnInterval = Math.max(80, spawnInterval - 5); // Slower spawn rate decrease
                }
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#16213e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Save context and apply camera transform
            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw infinite grid
            ctx.strokeStyle = '#1a2744';
            ctx.lineWidth = 1;
            const gridSize = 40;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            for (let x = startX; x < camera.x + canvas.width + gridSize; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, camera.y);
                ctx.lineTo(x, camera.y + canvas.height);
                ctx.stroke();
            }
            for (let y = startY; y < camera.y + canvas.height + gridSize; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(camera.x, y);
                ctx.lineTo(camera.x + canvas.width, y);
                ctx.stroke();
            }

            // Draw particles
            for (const p of particles) {
                ctx.globalAlpha = p.life / 30;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Draw coin pickups
            for (const c of coinPickups) {
                const bob = Math.sin(Date.now() / 200 + c.bobOffset) * 3;
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(c.x, c.y + bob, c.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Coin shine
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.beginPath();
                ctx.arc(c.x - 3, c.y + bob - 3, c.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw bullets
            for (const b of bullets) {
                ctx.fillStyle = '#f1c40f';
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();

                // Bullet glow
                ctx.shadowColor = '#f1c40f';
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            // Draw enemies
            for (const e of enemies) {
                // Enemy body
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.radius, 0, Math.PI * 2);
                ctx.fill();

                // Enemy outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Health bar
                if (e.health < e.maxHealth) {
                    const barWidth = e.radius * 2;
                    const barHeight = 4;
                    ctx.fillStyle = '#333';
                    ctx.fillRect(e.x - barWidth / 2, e.y - e.radius - 10, barWidth, barHeight);
                    ctx.fillStyle = '#2ecc71';
                    ctx.fillRect(e.x - barWidth / 2, e.y - e.radius - 10, barWidth * (e.health / e.maxHealth), barHeight);
                }

                // Eyes
                const eyeAngle = Math.atan2(player.y - e.y, player.x - e.x);
                const eyeOffset = e.radius * 0.3;
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(e.x + Math.cos(eyeAngle - 0.5) * eyeOffset, e.y + Math.sin(eyeAngle - 0.5) * eyeOffset, e.radius * 0.2, 0, Math.PI * 2);
                ctx.arc(e.x + Math.cos(eyeAngle + 0.5) * eyeOffset, e.y + Math.sin(eyeAngle + 0.5) * eyeOffset, e.radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(e.x + Math.cos(eyeAngle - 0.5) * eyeOffset + Math.cos(eyeAngle) * 2, e.y + Math.sin(eyeAngle - 0.5) * eyeOffset + Math.sin(eyeAngle) * 2, e.radius * 0.1, 0, Math.PI * 2);
                ctx.arc(e.x + Math.cos(eyeAngle + 0.5) * eyeOffset + Math.cos(eyeAngle) * 2, e.y + Math.sin(eyeAngle + 0.5) * eyeOffset + Math.sin(eyeAngle) * 2, e.radius * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw player
            ctx.save();
            ctx.translate(player.x, player.y);
            ctx.rotate(player.angle);

            // Gun
            ctx.fillStyle = '#7f8c8d';
            ctx.fillRect(player.radius * 0.3, -player.gunWidth / 2, player.gunLength, player.gunWidth);
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(player.gunLength - 5, -player.gunWidth / 2 - 2, 8, player.gunWidth + 4);

            ctx.restore();

            // Player body
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fill();

            // Player outline
            ctx.strokeStyle = '#2980b9';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Player inner highlight
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(player.x - 5, player.y - 5, player.radius * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Draw shield
            if (upgrades.shield.level > 0 && shieldActive) {
                ctx.strokeStyle = 'rgba(33, 150, 243, 0.7)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.radius + 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
                ctx.fill();
            }

            // Draw slow aura
            if (upgrades.slowField.level > 0) {
                const slowRadius = 100 + upgrades.slowField.level * 30;
                ctx.strokeStyle = 'rgba(0, 188, 212, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x, player.y, slowRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw orbitals
            if (upgrades.orbitalShield.level > 0) {
                const orbitalCount = upgrades.orbitalShield.level + 1;
                const orbitalDist = 50;
                for (let i = 0; i < orbitalCount; i++) {
                    const angle = orbitalAngle + (Math.PI * 2 / orbitalCount) * i;
                    const ox = player.x + Math.cos(angle) * orbitalDist;
                    const oy = player.y + Math.sin(angle) * orbitalDist;
                    ctx.fillStyle = '#7c4dff';
                    ctx.beginPath();
                    ctx.arc(ox, oy, 10, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            }

            // Draw dash cooldown indicator
            if (upgrades.dashCooldown.level > 0) {
                const dashReady = canDash;
                ctx.fillStyle = dashReady ? '#03a9f4' : '#333';
                ctx.fillRect(player.x - 15, player.y + player.radius + 5, 30, 4);
                if (!dashReady) {
                    const progress = 1 - (dashTimer / getDashCooldown());
                    ctx.fillStyle = '#03a9f4';
                    ctx.fillRect(player.x - 15, player.y + player.radius + 5, 30 * progress, 4);
                }
            }

            // Restore context (end camera transform)
            ctx.restore();

            // Shop paused overlay (drawn in screen space)
            if (shopOpen) {
                ctx.fillStyle = 'rgba(0,0,0,0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('GAME PAUSED', canvas.width / 2, 50);
            }

            // Draw coordinates indicator
            ctx.fillStyle = '#555';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(`X: ${Math.floor(player.x)} Y: ${Math.floor(player.y)}`, canvas.width - 10, canvas.height - 10);
        }

        function gameOver() {
            gameRunning = false;
            gameOverEl.style.display = 'block';
            finalScoreEl.textContent = score;
        }

        function restartGame() {
            gameRunning = true;
            shopOpen = false;
            shopEl.style.display = 'none';
            score = 0;
            wave = 1;
            coins = 0;
            spawnTimer = 0;
            spawnInterval = 120;
            regenTimer = 0;
            shieldActive = true;
            shieldTimer = 0;
            canDash = true;
            dashTimer = 0;
            isDashing = false;
            orbitalAngle = 0;

            // Reset upgrades
            for (const key in upgrades) {
                upgrades[key].level = 0;
            }

            player.x = 0;
            player.y = 0;
            camera.x = -canvas.width / 2;
            camera.y = -canvas.height / 2;
            player.maxHealth = player.baseMaxHealth;
            player.health = player.maxHealth;
            bullets.length = 0;
            enemies.length = 0;
            particles.length = 0;
            coinPickups.length = 0;
            scoreEl.textContent = 'Score: 0';
            waveEl.textContent = 'Wave: 1';
            coinsEl.textContent = 'Coins: 0';
            healthFill.style.width = '100%';
            gameOverEl.style.display = 'none';
            updateActiveUpgrades();
        }

        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Start the game
        updateActiveUpgrades();
        gameLoop();
    </script>
</body>
</html>

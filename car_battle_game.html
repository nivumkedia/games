<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Stunt Car Battle Royale!</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            color: white;
        }
        #gameCanvas {
            border: 4px solid white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            background: #87ceeb;
            display: none;
            touch-action: none;
        }
        #startMenu {
            text-align: center;
            background: rgba(0,0,0,0.7);
            padding: 60px 80px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #startMenu h1 {
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        #startMenu p {
            font-size: 20px;
            margin-bottom: 30px;
        }
        #storySelect {
            font-size: 24px;
            padding: 12px 24px;
            margin: 10px 0;
            border-radius: 10px;
            border: none;
            background: #667eea;
            color: white;
            cursor: pointer;
        }
        #startButton {
            font-size: 28px;
            padding: 18px 60px;
            margin-top: 10px;
            border-radius: 15px;
            border: none;
            background: #00ff88;
            color: #000;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        #startButton:hover {
            transform: scale(1.1);
        }
        #info {
            margin-top: 20px;
            text-align: center;
            font-size: 18px;
            background: rgba(0,0,0,0.3);
            padding: 15px 30px;
            border-radius: 10px;
            display: none;
        }
        #status {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        /* Device mode tabs */
        .device-tabs {
            display: flex;
            gap: 0;
            margin: 20px 0;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .device-tab {
            flex: 1;
            padding: 14px 10px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            background: rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.6);
            text-align: center;
        }
        .device-tab.active {
            background: #667eea;
            color: #fff;
        }
        .device-tab:hover:not(.active) {
            background: rgba(255,255,255,0.2);
        }
        .device-info {
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            margin-top: 8px;
            min-height: 40px;
        }

        /* Tutorial overlay */
        #tutorialOverlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            z-index: 200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .tut-box {
            background: linear-gradient(135deg, #1a1a3e, #2d1a4a);
            border: 3px solid rgba(102, 126, 234, 0.6);
            border-radius: 20px;
            padding: 30px 40px;
            max-width: 620px;
            width: 90%;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
            max-height: 85vh;
            overflow-y: auto;
        }
        .tut-title {
            font-size: 28px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 4px;
            text-shadow: 0 0 10px rgba(102, 126, 234, 0.4);
        }
        .tut-step-num {
            font-size: 12px;
            color: rgba(255,255,255,0.4);
            letter-spacing: 3px;
            margin-bottom: 16px;
        }
        .tut-body {
            font-size: 15px;
            color: #ccc;
            line-height: 1.7;
            text-align: left;
            margin-bottom: 20px;
        }
        .tut-body h3 {
            color: #00ff88;
            font-size: 17px;
            margin: 12px 0 6px;
        }
        .tut-body .tkey {
            display: inline-block;
            background: linear-gradient(135deg, #444, #333);
            color: #fff;
            padding: 2px 10px;
            border-radius: 5px;
            font-size: 13px;
            border: 1px solid #555;
            margin: 0 2px;
            font-weight: bold;
        }
        .tut-body .tut-panel {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 12px;
            margin: 10px 0;
        }
        .tut-body .feat-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin: 10px 0;
        }
        .tut-body .feat-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 8px 10px;
            width: 130px;
            text-align: center;
            font-size: 12px;
        }
        .tut-body .feat-item .fi-icon {
            font-size: 22px;
            display: block;
            margin-bottom: 2px;
        }
        .tut-body .feat-item .fi-name {
            color: #ffdd00;
            font-weight: bold;
            font-size: 12px;
        }
        .tut-body .feat-item .fi-desc {
            color: #999;
            font-size: 10px;
        }
        .tut-nav {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: center;
        }
        .tut-btn {
            font-size: 16px;
            padding: 10px 28px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s;
        }
        .tut-btn:hover { transform: scale(1.05); }
        .tut-btn-prev { background: #444; color: #ccc; }
        .tut-btn-next { background: #667eea; color: #fff; }
        .tut-btn-close {
            background: none;
            border: 1px solid rgba(255,255,255,0.2) !important;
            color: rgba(255,255,255,0.5);
            font-size: 13px;
            padding: 8px 20px;
            margin-top: 12px;
            border-radius: 8px;
            cursor: pointer;
        }
        .tut-btn-close:hover { color: #fff; border-color: rgba(255,255,255,0.5) !important; }
        .tut-dots {
            display: flex;
            gap: 6px;
        }
        .tut-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s;
        }
        .tut-dot.active {
            background: #667eea;
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.5);
        }

        /* Touch restart button */
        #touchRestart {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 22px;
            font-weight: bold;
            background: rgba(100, 100, 200, 0.6);
            border: 2px solid rgba(150, 150, 255, 0.6);
            color: white;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 101;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* Mobile responsive */
        @media (max-width: 900px) {
            #startMenu {
                padding: 30px 20px;
                margin: 10px;
                border-radius: 15px;
                max-width: 90vw;
            }
            #startMenu h1 {
                font-size: 24px;
                margin-bottom: 20px;
            }
            #startMenu p {
                font-size: 16px;
                margin-bottom: 15px;
            }
            #storySelect {
                font-size: 18px;
                padding: 8px 16px;
            }
            #startButton {
                font-size: 22px;
                padding: 14px 40px;
            }
            label {
                font-size: 16px !important;
            }
            #info {
                font-size: 12px;
                padding: 8px 12px;
            }
            #status {
                font-size: 16px;
            }
            .controls {
                font-size: 11px;
            }
            #gameCanvas {
                border-width: 2px;
            }
        }
    </style>
</head>
<body>
    <div id="startMenu">
        <h1>üèéÔ∏è STUNT CAR BATTLE ROYALE üèéÔ∏è</h1>
        <p style="margin-bottom: 30px;">Choose your arena size!</p>
        <label for="storySelect" style="font-size: 20px;">Number of Stories (Levels):</label><br>
        <select id="storySelect" style="margin-top: 10px;">
            <option value="3">3 Stories (3 Bots)</option>
            <option value="4">4 Stories (4 Bots)</option>
            <option value="5" selected>5 Stories (5 Bots)</option>
            <option value="6">6 Stories (6 Bots)</option>
            <option value="7">7 Stories (7 Bots)</option>
            <option value="8">8 Stories (8 Bots)</option>
            <option value="9">9 Stories (9 Bots)</option>
            <option value="10">10 Stories (10 Bots) - INSANE!</option>
        </select>
        <div style="margin-top: 30px; margin-bottom: 20px;">
            <input type="checkbox" id="challengeCheck" style="width: 20px; height: 20px; cursor: pointer;">
            <label for="challengeCheck" style="font-size: 20px; cursor: pointer;"> Challenge Mode (All Bots vs YOU!)</label>
        </div>

        <p style="margin-bottom: 5px; font-size: 18px;">Controls:</p>
        <div class="device-tabs">
            <button class="device-tab active" id="tabDesktop" onclick="selectDevice('desktop')">Desktop</button>
            <button class="device-tab" id="tabMobile" onclick="selectDevice('mobile')">Mobile</button>
        </div>
        <div class="device-info" id="deviceInfo">Arrow Keys to move, Up to jump, Space to brake</div>

        <div style="display:flex;gap:12px;justify-content:center;align-items:center">
            <button id="startButton">START BATTLE!</button>
            <button id="tutorialBtn" style="font-size:20px;padding:18px 30px;border-radius:15px;border:none;background:#667eea;color:#fff;cursor:pointer;font-weight:bold;transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.1)'" onmouseout="this.style.transform='scale(1)'">HOW TO PLAY</button>
        </div>
    </div>

    <div id="tutorialOverlay">
        <div class="tut-box">
            <div class="tut-title" id="tutTitle"></div>
            <div class="tut-step-num" id="tutStepNum"></div>
            <div class="tut-body" id="tutBody"></div>
            <div class="tut-nav">
                <button class="tut-btn tut-btn-prev" id="tutPrev">BACK</button>
                <div class="tut-dots" id="tutDots"></div>
                <button class="tut-btn tut-btn-next" id="tutNext">NEXT</button>
            </div>
            <button class="tut-btn-close" id="tutClose">BACK TO MENU</button>
        </div>
    </div>

    <canvas id="gameCanvas" width="1400" height="900"></canvas>

    <div id="info">
        <div id="status">BATTLE ROYALE - Last Car Standing Wins!</div>
        <div class="controls">
            Arrow Keys: Move | Arrow Up: Jump | Space: Brake | Press R to restart<br>
            WARNING: 4 seconds idle = ELIMINATION!
        </div>
    </div>

    <div id="touchRestart">R</div>

    <script>
        // Helper for rounded rectangles (works in all browsers)
        function roundedRect(ctx, x, y, w, h, r) {
            r = Math.min(r, w / 2, h / 2);
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusText = document.getElementById('status');
        const startMenu = document.getElementById('startMenu');
        const infoDiv = document.getElementById('info');
        const storySelect = document.getElementById('storySelect');
        const startButton = document.getElementById('startButton');
        const challengeCheck = document.getElementById('challengeCheck');

        let gameOver = false;
        let gameStarted = false;
        let numStories = 5;
        let numBots = 5;
        let challengeMode = false;
        const GRAVITY = 0.6;
        const STORY_HEIGHT = 150;
        let GROUND_Y = 850;

        let track = {};
        let player = {};
        let aiCars = [];
        let particles = [];
        let gameTimer = 0;
        let hunterBot = null;
        let lastKeyPressTime = 0;
        const IDLE_TIMEOUT = 240; // 4 seconds at 60fps
        let cameraX = 0;
        let cameraY = 0;
        let cameraShakeX = 0;
        let cameraShakeY = 0;
        let arenaLeft = 0;
        let arenaRight = 1400; // will be set to canvas.width on game start
        const SHRINK_INTERVAL = 1200; // 20 seconds at 60fps
        const SHRINK_AMOUNT = 80; // pixels from each side

        // Particle system for visual effects
        class Particle {
            constructor(x, y, color, vx, vy) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = vx;
                this.vy = vy;
                this.life = 1.0;
                this.size = Math.random() * 5 + 2;
                this.type = Math.random() < 0.3 ? 'spark' : 'debris';
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = (Math.random() - 0.5) * 0.3;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += GRAVITY * 0.3;
                this.vx *= 0.99;
                this.life -= 0.018;
                this.rotation += this.rotSpeed;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                if (this.type === 'spark') {
                    // Glowing spark
                    void 0; //ctx.shadowColor = this.color;
                    // glow effect (no shadow for performance)
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    void 0; //ctx.shadowBlur = 0;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Debris chunk
                    ctx.fillStyle = this.color;
                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size * 0.7);
                    ctx.fillStyle = 'rgba(255,255,255,0.2)';
                    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size * 0.2);
                }

                ctx.restore();
            }
        }

        function spawnParticles(x, y, count, color) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                particles.push(new Particle(
                    x, y, color,
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed - 3
                ));
            }
        }

        startButton.addEventListener('click', () => {
            numStories = parseInt(storySelect.value);
            numBots = numStories;
            challengeMode = challengeCheck.checked;
            startGame();
        });

        function generateTrack() {
            track = {
                platforms: [],
                ramps: [],
                jumpPads: [],
                teleporters: [],
                movingPlatforms: [],
                icePatches: [],
                fans: [],
                spikes: [],
                boostPads: [],
                obstacles: [],
                walls: []
            };

            // Generate ground with big holes
            const groundSegments = 5;
            const groundSegmentWidth = (canvas.width - 40) / groundSegments;
            for (let i = 0; i < groundSegments; i++) {
                // Skip 2 segments to create large holes
                if (i === 1 || i === 3) continue;
                const gapSize = 100;
                track.platforms.push({
                    x: 20 + i * groundSegmentWidth + gapSize / 2,
                    y: GROUND_Y,
                    width: groundSegmentWidth - gapSize,
                    height: 100,
                    type: 'ground'
                });
            }

            // Generate platforms for each story with big holes
            for (let story = 1; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT;
                const numPlatforms = 2 + Math.floor(Math.random() * 2); // fewer, smaller platforms
                const sectionWidth = (canvas.width - 40) / numPlatforms;

                for (let i = 0; i < numPlatforms; i++) {
                    // Big gaps between platforms - 150-250px holes
                    const gapSize = 150 + Math.random() * 100;
                    const platWidth = sectionWidth - gapSize;
                    if (platWidth < 100) continue;

                    const x = 20 + i * sectionWidth + (Math.random() < 0.5 ? 0 : gapSize);

                    // Top level ‚Äî decent gaps so bots can fall through
                    if (story === numStories) {
                        const topGap = 120 + Math.random() * 60; // 120-180px gaps
                        const topPlatWidth = sectionWidth - topGap;
                        if (topPlatWidth < 100) continue;
                        track.platforms.push({
                            x: 20 + i * sectionWidth + topGap / 2,
                            y: y,
                            width: topPlatWidth,
                            height: 65,
                            type: 'penthouse'
                        });
                    } else {
                        track.platforms.push({
                            x: x,
                            y: y + (Math.random() - 0.5) * 20,
                            width: platWidth,
                            height: 65,
                            type: 'platform'
                        });
                    }
                }
            }

            // Generate ramps between stories
            for (let story = 0; story < numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT;
                const numRamps = 2 + Math.floor(Math.random() * 2);

                for (let i = 0; i < numRamps; i++) {
                    const x = 100 + i * (canvas.width - 200) / numRamps;
                    track.ramps.push({
                        x: x,
                        y: y,
                        width: 130 + Math.random() * 100,
                        height: 150 + Math.random() * 80,
                        angle: -0.8 - Math.random() * 0.4
                    });
                }
            }

            // Generate jump pads
            for (let story = 0; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT - 5;
                if (Math.random() < 0.35) {
                    const x = 200 + Math.random() * (canvas.width - 400);
                    track.jumpPads.push({
                        x: x,
                        y: y,
                        width: 170,
                        height: 32,
                        power: 20 + Math.random() * 10,
                        animation: 0
                    });
                }
            }

            // Generate teleporters (pairs)
            for (let i = 0; i < Math.min(2, Math.floor(numStories / 2)); i++) {
                const story1 = Math.floor(Math.random() * numStories);
                const story2 = Math.floor(Math.random() * numStories);
                const x1 = 100 + Math.random() * (canvas.width - 300);
                const x2 = 100 + Math.random() * (canvas.width - 300);

                const tp1 = {
                    x: x1,
                    y: GROUND_Y - story1 * STORY_HEIGHT - 50,
                    width: 130,
                    height: 130,
                    linkedTo: null,
                    cooldown: 0
                };

                const tp2 = {
                    x: x2,
                    y: GROUND_Y - story2 * STORY_HEIGHT - 50,
                    width: 130,
                    height: 130,
                    linkedTo: tp1,
                    cooldown: 0
                };

                tp1.linkedTo = tp2;
                track.teleporters.push(tp1, tp2);
            }

            // Generate moving platforms
            for (let story = 1; story <= numStories; story++) {
                if (Math.random() < 0.45) {
                    const y = GROUND_Y - story * STORY_HEIGHT;
                    track.movingPlatforms.push({
                        x: 200,
                        y: y,
                        width: 210,
                        height: 55,
                        startX: 200,
                        endX: canvas.width - 300,
                        speed: 1 + Math.random(),
                        direction: 1
                    });
                }
            }

            // Generate ice patches
            for (let story = 0; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT - 5;
                if (Math.random() < 0.2) {
                    track.icePatches.push({
                        x: 150 + Math.random() * (canvas.width - 400),
                        y: y,
                        width: 210 + Math.random() * 100,
                        height: 22
                    });
                }
            }

            // Generate wind fans
            for (let story = 0; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT - 40;
                if (Math.random() < 0.15) {
                    track.fans.push({
                        x: 100 + Math.random() * (canvas.width - 300),
                        y: y,
                        width: 105,
                        height: 105,
                        force: 0.3 + Math.random() * 0.3,
                        direction: Math.random() < 0.5 ? 1 : -1,
                        animation: 0
                    });
                }
            }

            // Generate spikes - reduced frequency
            for (let story = 0; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT;
                if (Math.random() < 0.08) {
                    track.spikes.push({
                        x: 150 + Math.random() * (canvas.width - 400),
                        y: y - 40,
                        width: 130,
                        height: 42
                    });
                }
            }

            // Generate boost pads
            for (let story = 0; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT - 5;
                const numBoosts = 1 + Math.floor(Math.random() * 1);

                for (let i = 0; i < numBoosts; i++) {
                    track.boostPads.push({
                        x: 100 + Math.random() * (canvas.width - 300),
                        y: y,
                        width: 190,
                        height: 22
                    });
                }
            }

            // Generate bumpers - reduced frequency
            for (let story = 0; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT - 40;
                if (Math.random() < 0.12) {
                    track.obstacles.push({
                        x: 150 + Math.random() * (canvas.width - 400),
                        y: y,
                        width: 75 + Math.random() * 35,
                        height: 75 + Math.random() * 35,
                        type: 'bumper'
                    });
                }
            }

            // Generate walls
            for (let story = 0; story <= numStories; story++) {
                const y = GROUND_Y - story * STORY_HEIGHT - 50;
                if (Math.random() < 0.15) {
                    track.obstacles.push({
                        x: 200 + Math.random() * (canvas.width - 500),
                        y: y,
                        width: 85 + Math.random() * 45,
                        height: 95 + Math.random() * 35,
                        type: 'wall'
                    });
                }
            }
        }

        function initializeCars() {
            player = {
                x: canvas.width / 2,
                y: GROUND_Y - numStories * STORY_HEIGHT - 50,
                vx: 0,
                vy: 0,
                width: 105,
                height: 60,
                onGround: false,
                color: '#ff0000',
                maxSpeed: 11,
                acceleration: 0.6,
                jumpPower: -15,
                rotation: 0,
                rotationVel: 0,
                alive: true,
                id: 'player',
                teleportCooldown: 0
            };

            aiCars = [];
            const aiColors = ['#2a2a2a', '#1a3a6a', '#5a1a5a', '#1a5a2a', '#6a4a1a',
                             '#4a1a1a', '#1a4a5a', '#3a3a1a', '#5a2a3a', '#2a1a4a'];

            for (let i = 0; i < numBots; i++) {
                // All bots start on top level
                const xPos = 100 + (i * 180) % (canvas.width - 200);
                aiCars.push({
                    x: xPos,
                    y: GROUND_Y - numStories * STORY_HEIGHT - 50,
                    vx: 0,
                    vy: 0,
                    width: 100,
                    height: 55,
                    onGround: false,
                    color: aiColors[i],
                    maxSpeed: 10 + Math.random() * 4,
                    acceleration: 0.55 + Math.random() * 0.25,
                    jumpPower: -12 - Math.random() * 2,
                    rotation: 0,
                    rotationVel: 0,
                    aiTimer: Math.random() * 100,
                    lastJump: 0,
                    target: null,
                    alive: true,
                    id: `ai${i}`,
                    teleportCooldown: 0,
                    isHunter: false,
                    lastHitByPlayer: 0
                });
            }
        }

        function startGame() {
            startMenu.style.display = 'none';
            canvas.style.display = 'block';
            if (deviceMode === 'mobile') {
                resizeCanvas();
                infoDiv.style.display = 'none';
                touchRestartBtn.style.display = 'flex';
                window.addEventListener('resize', resizeCanvas);
            } else {
                infoDiv.style.display = 'block';
            }
            GROUND_Y = canvas.height - 50;
            gameStarted = true;
            generateTrack();
            initializeCars();
            particles = [];
            gameTimer = 0;
            lastKeyPressTime = 0;
            hunterBot = null;
            cameraX = 0;
            cameraY = 0;
            cameraShakeX = 0;
            cameraShakeY = 0;
            arenaLeft = 0;
            arenaRight = canvas.width;
            gameLoop();
        }

        const keys = {};
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            // Reset idle timer when player presses game control keys
            if (gameStarted && !gameOver && player.alive &&
                (e.key === 'ArrowUp' || e.key === 'ArrowDown' ||
                 e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === ' ')) {
                lastKeyPressTime = gameTimer;
            }

            e.preventDefault();
        });
        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            e.preventDefault();
        });

        // Device mode selection
        let deviceMode = 'desktop'; // 'desktop' or 'mobile'
        let touchTarget = null; // {x, y} world position the player is dragging toward
        let touchActive = false;
        const touchRestartBtn = document.getElementById('touchRestart');

        function selectDevice(mode) {
            deviceMode = mode;
            document.getElementById('tabDesktop').classList.toggle('active', mode === 'desktop');
            document.getElementById('tabMobile').classList.toggle('active', mode === 'mobile');
            const info = document.getElementById('deviceInfo');
            if (mode === 'desktop') {
                info.textContent = 'Arrow Keys to move, Up to jump, Space to brake';
            } else {
                info.textContent = 'Touch & drag to pull your car. Tap above car to jump. Car can still be knocked around!';
            }
        }
        // Make selectDevice available globally for onclick
        window.selectDevice = selectDevice;

        function resizeCanvas() {
            if (deviceMode === 'mobile') {
                const w = window.innerWidth;
                const h = window.innerHeight;
                canvas.width = w;
                canvas.height = h;
                canvas.style.width = w + 'px';
                canvas.style.height = h + 'px';
            }
        }

        // Touch controls - finger follow system
        function getTouchWorldPos(touch) {
            const rect = canvas.getBoundingClientRect();
            const screenX = touch.clientX - rect.left;
            const screenY = touch.clientY - rect.top;
            // Convert screen coords to world coords (account for camera)
            const worldX = screenX + cameraX;
            const worldY = screenY + cameraY;
            return { x: worldX, y: worldY };
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (deviceMode !== 'mobile') return;
            if (!gameStarted || gameOver) return;

            if (!player.alive) {
                keys['r'] = true;
                setTimeout(() => { keys['r'] = false; }, 100);
                return;
            }

            const pos = getTouchWorldPos(e.touches[0]);
            touchTarget = pos;
            touchActive = true;
            lastKeyPressTime = gameTimer;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (deviceMode !== 'mobile') return;
            if (!gameStarted || !touchActive) return;

            const pos = getTouchWorldPos(e.touches[0]);
            touchTarget = pos;
            lastKeyPressTime = gameTimer;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchActive = false;
            touchTarget = null;
        }, { passive: false });

        canvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchActive = false;
            touchTarget = null;
        }, { passive: false });

        // Mouse events (for mobile mode on desktop)
        function getMouseWorldPos(e) {
            const rect = canvas.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            return { x: screenX + cameraX, y: screenY + cameraY };
        }

        canvas.addEventListener('mousedown', (e) => {
            if (deviceMode !== 'mobile') return;
            if (!gameStarted || gameOver) return;

            if (!player.alive) {
                keys['r'] = true;
                setTimeout(() => { keys['r'] = false; }, 100);
                return;
            }

            touchTarget = getMouseWorldPos(e);
            touchActive = true;
            lastKeyPressTime = gameTimer;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (deviceMode !== 'mobile') return;
            if (!gameStarted || !touchActive) return;

            touchTarget = getMouseWorldPos(e);
            lastKeyPressTime = gameTimer;
        });

        canvas.addEventListener('mouseup', () => {
            touchActive = false;
            touchTarget = null;
        });

        canvas.addEventListener('mouseleave', () => {
            touchActive = false;
            touchTarget = null;
        });

        // Touch restart button
        touchRestartBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameOver || !player.alive) {
                keys['r'] = true;
                setTimeout(() => { keys['r'] = false; }, 100);
            }
        });
        touchRestartBtn.addEventListener('click', (e) => {
            if (gameOver || !player.alive) {
                keys['r'] = true;
                setTimeout(() => { keys['r'] = false; }, 100);
            }
        });

        // Prevent scrolling/zooming on mobile during gameplay
        document.addEventListener('touchmove', (e) => {
            if (gameStarted && deviceMode === 'mobile') e.preventDefault();
        }, { passive: false });

        function updateCamera() {
            if (!player.alive) return;

            // No horizontal scrolling - world is exactly canvas width
            cameraX = 0;

            // Center camera on player vertically
            const targetY = player.y - canvas.height / 2;

            // Smooth camera movement
            cameraY += (targetY - cameraY) * 0.1;

            // Clamp camera vertically to world bounds
            const worldTop = -(numStories * STORY_HEIGHT + 300);
            const worldBottom = GROUND_Y + 100;
            cameraY = Math.max(worldTop, Math.min(cameraY, worldBottom - canvas.height));

            // Apply and decay screen shake
            cameraShakeX *= 0.8;
            cameraShakeY *= 0.8;
            if (Math.abs(cameraShakeX) < 0.1) cameraShakeX = 0;
            if (Math.abs(cameraShakeY) < 0.1) cameraShakeY = 0;
        }

        function addScreenShake(intensity) {
            cameraShakeX = (Math.random() - 0.5) * intensity;
            cameraShakeY = (Math.random() - 0.5) * intensity;
        }

        function drawBackground() {
            // Rich sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#0b0e2d');
            gradient.addColorStop(0.15, '#1a1a4e');
            gradient.addColorStop(0.35, '#2d3a6e');
            gradient.addColorStop(0.55, '#4a6fa5');
            gradient.addColorStop(0.75, '#7bb3d4');
            gradient.addColorStop(1, '#c8e6f5');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Twinkling stars
            for (let i = 0; i < 30; i++) {
                const x = (i * 73 + i * i * 3) % canvas.width;
                const y = (i * 47 + i * 11) % 300;
                const twinkle = Math.sin(gameTimer * 0.05 + i * 1.7) * 0.4 + 0.6;
                const size = (i % 3 === 0) ? 2.5 : 1.5;
                ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Moon
            ctx.save();
            void 0; //ctx.shadowColor = 'rgba(255, 255, 200, 0.6)';
            //void 0; //ctx.shadowBlur = 40;
            const moonGrad = ctx.createRadialGradient(1200, 80, 0, 1200, 80, 40);
            moonGrad.addColorStop(0, '#fffff0');
            moonGrad.addColorStop(0.7, '#fffde0');
            moonGrad.addColorStop(1, 'rgba(255, 253, 200, 0)');
            ctx.fillStyle = moonGrad;
            ctx.beginPath();
            ctx.arc(1200, 80, 40, 0, Math.PI * 2);
            ctx.fill();
            void 0; //ctx.shadowBlur = 0;
            // Moon craters
            ctx.fillStyle = 'rgba(200, 200, 180, 0.3)';
            ctx.beginPath();
            ctx.arc(1190, 70, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(1210, 85, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Parallax city skyline (far) - simple silhouettes
            ctx.fillStyle = 'rgba(30, 30, 60, 0.6)';
            const skylineY = 450 - cameraY * 0.05;
            for (let i = 0; i < 20; i++) {
                const bx = i * 75 - 10;
                const bh = 40 + (i * 37 % 80);
                ctx.fillRect(bx, skylineY - bh, 55, bh + 200);
            }

            // Parallax city skyline (near)
            ctx.fillStyle = 'rgba(20, 20, 45, 0.7)';
            const skyline2Y = 520 - cameraY * 0.1;
            for (let i = 0; i < 14; i++) {
                const bx = i * 110 - 30;
                const bh = 60 + (i * 53 % 100);
                ctx.fillRect(bx, skyline2Y - bh, 85, bh + 200);
            }

            // Clouds with depth
            for (let i = 0; i < 5; i++) {
                const cx = (100 + i * 160 + gameTimer * (0.1 + i * 0.02)) % (canvas.width + 200) - 100;
                const cy = 180 + (i % 4) * 80;
                const scale = 0.7 + (i % 3) * 0.3;
                ctx.fillStyle = `rgba(255, 255, 255, ${0.15 + (i % 3) * 0.08})`;
                ctx.beginPath();
                ctx.arc(cx, cy, 25 * scale, 0, Math.PI * 2);
                ctx.arc(cx + 20 * scale, cy - 8 * scale, 20 * scale, 0, Math.PI * 2);
                ctx.arc(cx + 40 * scale, cy, 28 * scale, 0, Math.PI * 2);
                ctx.arc(cx + 18 * scale, cy + 5 * scale, 18 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawWalls() {
            // Walls with gradient
            track.walls.forEach(wall => {
                const wallGrad = ctx.createLinearGradient(wall.x, 0, wall.x + wall.width, 0);
                wallGrad.addColorStop(0, '#1a1a1a');
                wallGrad.addColorStop(1, '#2d3748');
                ctx.fillStyle = wallGrad;
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
            });
        }

        function drawArenaWalls() {
            const worldTop = -(numStories * STORY_HEIGHT + 500);
            const worldBottom = GROUND_Y + 200;
            const wallHeight = worldBottom - worldTop;
            const pulse = Math.sin(gameTimer * 0.08) * 0.15 + 0.85;

            // Left danger wall
            if (arenaLeft > 0) {
                // Outer glow
                const glow = ctx.createLinearGradient(arenaLeft - 80, 0, arenaLeft, 0);
                glow.addColorStop(0, 'rgba(255, 0, 0, 0)');
                glow.addColorStop(1, `rgba(255, 50, 0, ${0.15 * pulse})`);
                ctx.fillStyle = glow;
                ctx.fillRect(arenaLeft - 80, worldTop, 80, wallHeight);

                // Main wall
                const gradient = ctx.createLinearGradient(arenaLeft - 8, 0, arenaLeft, 0);
                gradient.addColorStop(0, `rgba(255, 30, 0, ${0.9 * pulse})`);
                gradient.addColorStop(1, `rgba(255, 80, 0, ${0.4 * pulse})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(arenaLeft - 8, worldTop, 8, wallHeight);

                // Energy line
                ctx.save();
                void 0; //ctx.shadowColor = '#ff4400';
                void 0; //ctx.shadowBlur = 15 * pulse;
                ctx.strokeStyle = `rgba(255, 100, 0, ${pulse})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(arenaLeft, worldTop);
                ctx.lineTo(arenaLeft, worldBottom);
                ctx.stroke();
                void 0; //ctx.shadowBlur = 0;
                ctx.restore();

                // Hazard chevrons
                ctx.fillStyle = `rgba(255, 200, 0, ${0.6 * pulse})`;
                for (let y = worldTop; y < worldBottom; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(arenaLeft - 8, y);
                    ctx.lineTo(arenaLeft + 10, y + 25);
                    ctx.lineTo(arenaLeft - 8, y + 50);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // Right danger wall
            if (arenaRight < canvas.width) {
                const glow = ctx.createLinearGradient(arenaRight, 0, arenaRight + 80, 0);
                glow.addColorStop(0, `rgba(255, 50, 0, ${0.15 * pulse})`);
                glow.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = glow;
                ctx.fillRect(arenaRight, worldTop, 80, wallHeight);

                const gradient = ctx.createLinearGradient(arenaRight, 0, arenaRight + 8, 0);
                gradient.addColorStop(0, `rgba(255, 80, 0, ${0.4 * pulse})`);
                gradient.addColorStop(1, `rgba(255, 30, 0, ${0.9 * pulse})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(arenaRight, worldTop, 8, wallHeight);

                ctx.save();
                void 0; //ctx.shadowColor = '#ff4400';
                void 0; //ctx.shadowBlur = 15 * pulse;
                ctx.strokeStyle = `rgba(255, 100, 0, ${pulse})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(arenaRight, worldTop);
                ctx.lineTo(arenaRight, worldBottom);
                ctx.stroke();
                void 0; //ctx.shadowBlur = 0;
                ctx.restore();

                ctx.fillStyle = `rgba(255, 200, 0, ${0.6 * pulse})`;
                for (let y = worldTop; y < worldBottom; y += 50) {
                    ctx.beginPath();
                    ctx.moveTo(arenaRight + 8, y);
                    ctx.lineTo(arenaRight - 10, y + 25);
                    ctx.lineTo(arenaRight + 8, y + 50);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        function drawPlatforms() {
            track.platforms.forEach(platform => {
                ctx.save();
                const px = platform.x, py = platform.y, pw = platform.width, ph = platform.height;

                // Drop shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
                ctx.beginPath();
                roundedRect(ctx,px + 4, py + 6, pw, ph, 4);
                ctx.fill();

                // 3D side face
                const sideH = 12;
                const sideGrad = ctx.createLinearGradient(0, py + ph, 0, py + ph + sideH);
                if (platform.type === 'penthouse') {
                    sideGrad.addColorStop(0, '#cc9900');
                    sideGrad.addColorStop(1, '#8a6600');
                } else if (platform.type === 'ground') {
                    sideGrad.addColorStop(0, '#4a3010');
                    sideGrad.addColorStop(1, '#2a1a08');
                } else {
                    sideGrad.addColorStop(0, '#5a4535');
                    sideGrad.addColorStop(1, '#3a2a1d');
                }
                ctx.fillStyle = sideGrad;
                ctx.fillRect(px + 3, py + ph, pw - 3, sideH);

                // Main platform face
                const gradient = ctx.createLinearGradient(0, py, 0, py + ph);
                if (platform.type === 'penthouse') {
                    gradient.addColorStop(0, '#ffe44d');
                    gradient.addColorStop(0.3, '#ffd700');
                    gradient.addColorStop(1, '#e6a800');
                } else if (platform.type === 'ground') {
                    gradient.addColorStop(0, '#7a6030');
                    gradient.addColorStop(0.2, '#6b5020');
                    gradient.addColorStop(1, '#4a3518');
                } else {
                    gradient.addColorStop(0, '#b8967a');
                    gradient.addColorStop(0.2, '#a0826d');
                    gradient.addColorStop(1, '#7a6050');
                }
                ctx.fillStyle = gradient;
                ctx.beginPath();
                roundedRect(ctx,px, py, pw, ph, 4);
                ctx.fill();

                // Top highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.fillRect(px + 4, py + 2, pw - 8, 4);

                // Surface texture lines
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.lineWidth = 1;
                for (let i = 0; i < pw; i += 30) {
                    ctx.beginPath();
                    ctx.moveTo(px + i, py);
                    ctx.lineTo(px + i, py + ph);
                    ctx.stroke();
                }

                // Edge outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                roundedRect(ctx,px, py, pw, ph, 4);
                ctx.stroke();

                if (platform.type === 'penthouse') {
                    // Glowing crown label
                    ctx.save();
                    void 0; //ctx.shadowColor = '#ffd700';
                    void 0; //ctx.shadowBlur = 10;
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('TOP LEVEL', px + pw / 2, py + 22);
                    ctx.textAlign = 'left';
                    void 0; //ctx.shadowBlur = 0;
                    ctx.restore();
                }

                ctx.restore();
            });
        }

        function drawMovingPlatforms() {
            track.movingPlatforms.forEach(plat => {
                plat.x += plat.speed * plat.direction;
                if (plat.x >= plat.endX || plat.x <= plat.startX) {
                    plat.direction *= -1;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                roundedRect(ctx,plat.x + 4, plat.y + 6, plat.width, plat.height, 6);
                ctx.fill();

                // 3D side
                ctx.fillStyle = '#3a4a9a';
                ctx.fillRect(plat.x + 3, plat.y + plat.height, plat.width - 3, 8);

                // Main platform
                const gradient = ctx.createLinearGradient(0, plat.y, 0, plat.y + plat.height);
                gradient.addColorStop(0, '#8090ee');
                gradient.addColorStop(0.3, '#667eea');
                gradient.addColorStop(1, '#4a60c8');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                roundedRect(ctx,plat.x, plat.y, plat.width, plat.height, 6);
                ctx.fill();

                // Glow edge
                ctx.save();
                void 0; //ctx.shadowColor = '#667eea';
                void 0; //ctx.shadowBlur = 8;
                ctx.strokeStyle = '#8899ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                roundedRect(ctx,plat.x, plat.y, plat.width, plat.height, 6);
                ctx.stroke();
                void 0; //ctx.shadowBlur = 0;
                ctx.restore();

                // Animated chevrons
                ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
                const chevDir = plat.direction;
                const chevOffset = (gameTimer * 2 * chevDir) % 30;
                ctx.save();
                ctx.beginPath();
                roundedRect(ctx,plat.x, plat.y, plat.width, plat.height, 6);
                ctx.clip();
                for (let i = -30 + chevOffset; i < plat.width + 30; i += 30) {
                    ctx.beginPath();
                    ctx.moveTo(plat.x + i, plat.y + plat.height);
                    ctx.lineTo(plat.x + i + 15 * chevDir, plat.y + plat.height / 2);
                    ctx.lineTo(plat.x + i, plat.y);
                    ctx.lineTo(plat.x + i + 8 * chevDir, plat.y);
                    ctx.lineTo(plat.x + i + 23 * chevDir, plat.y + plat.height / 2);
                    ctx.lineTo(plat.x + i + 8 * chevDir, plat.y + plat.height);
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            });
        }

        function drawRamps() {
            track.ramps.forEach(ramp => {
                ctx.save();

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.moveTo(ramp.x + 5, ramp.y + 6);
                ctx.lineTo(ramp.x + ramp.width + 5, ramp.y + 6);
                ctx.lineTo(ramp.x + ramp.width + 5, ramp.y - ramp.height + 6);
                ctx.closePath();
                ctx.fill();

                // 3D side face
                ctx.fillStyle = '#5a4530';
                ctx.beginPath();
                ctx.moveTo(ramp.x, ramp.y);
                ctx.lineTo(ramp.x + ramp.width, ramp.y);
                ctx.lineTo(ramp.x + ramp.width + 5, ramp.y + 10);
                ctx.lineTo(ramp.x + 5, ramp.y + 10);
                ctx.closePath();
                ctx.fill();

                // Ramp surface gradient
                const gradient = ctx.createLinearGradient(0, ramp.y, 0, ramp.y - ramp.height);
                gradient.addColorStop(0, '#a08060');
                gradient.addColorStop(0.5, '#c0a080');
                gradient.addColorStop(1, '#d4b896');
                ctx.fillStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(ramp.x, ramp.y);
                ctx.lineTo(ramp.x + ramp.width, ramp.y);
                ctx.lineTo(ramp.x + ramp.width, ramp.y - ramp.height);
                ctx.closePath();
                ctx.fill();

                // Surface highlight on slope
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.beginPath();
                ctx.moveTo(ramp.x + ramp.width * 0.3, ramp.y);
                ctx.lineTo(ramp.x + ramp.width * 0.7, ramp.y);
                ctx.lineTo(ramp.x + ramp.width * 0.7, ramp.y - ramp.height * 0.7);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = '#6a5040';
                ctx.lineWidth = 2.5;
                ctx.stroke();

                // Animated speed arrows on ramp surface
                ctx.save();
                ctx.beginPath();
                ctx.moveTo(ramp.x, ramp.y);
                ctx.lineTo(ramp.x + ramp.width, ramp.y);
                ctx.lineTo(ramp.x + ramp.width, ramp.y - ramp.height);
                ctx.closePath();
                ctx.clip();

                const arrowOffset = (gameTimer * 3) % 40;
                ctx.strokeStyle = 'rgba(255, 230, 100, 0.4)';
                ctx.lineWidth = 3;
                for (let i = -40 + arrowOffset; i < ramp.width + 40; i += 40) {
                    const t = i / ramp.width;
                    const baseY = ramp.y - ramp.height * t;
                    ctx.beginPath();
                    ctx.moveTo(ramp.x + i - 8, baseY + 10);
                    ctx.lineTo(ramp.x + i, baseY - 5);
                    ctx.lineTo(ramp.x + i + 8, baseY + 10);
                    ctx.stroke();
                }
                ctx.restore();

                ctx.restore();
            });
        }

        function drawJumpPads() {
            track.jumpPads.forEach(pad => {
                pad.animation += 0.1;
                const bounce = Math.sin(pad.animation) * 3;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(pad.x + 3, pad.y + 3 + bounce, pad.width, pad.height);

                // Gradient
                const gradient = ctx.createLinearGradient(0, pad.y + bounce, 0, pad.y + pad.height + bounce);
                gradient.addColorStop(0, '#ff00ff');
                gradient.addColorStop(1, '#ff66ff');
                ctx.fillStyle = gradient;
                ctx.fillRect(pad.x, pad.y + bounce, pad.width, pad.height);

                ctx.strokeStyle = '#990099';
                ctx.lineWidth = 3;
                ctx.strokeRect(pad.x, pad.y + bounce, pad.width, pad.height);

                // Spring icon
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(pad.x + pad.width / 2 - 10, pad.y + pad.height / 2 + bounce);
                ctx.lineTo(pad.x + pad.width / 2, pad.y + bounce);
                ctx.lineTo(pad.x + pad.width / 2 + 10, pad.y + pad.height / 2 + bounce);
                ctx.stroke();
            });
        }

        function drawTeleporters() {
            track.teleporters.forEach((tp, idx) => {
                const time = Date.now() / 100 + idx;
                const pulse = Math.sin(time) * 0.2 + 0.8;

                // Glow effect
                ctx.save();
                void 0; //ctx.shadowColor = '#00ffff';
                void 0; //ctx.shadowBlur = 20 * pulse;

                // Portal gradient
                const gradient = ctx.createRadialGradient(
                    tp.x + tp.width / 2, tp.y + tp.height / 2, 0,
                    tp.x + tp.width / 2, tp.y + tp.height / 2, tp.width / 2
                );
                gradient.addColorStop(0, 'rgba(0, 255, 255, ' + pulse + ')');
                gradient.addColorStop(1, 'rgba(0, 150, 200, ' + pulse * 0.5 + ')');
                ctx.fillStyle = gradient;

                ctx.beginPath();
                ctx.arc(tp.x + tp.width / 2, tp.y + tp.height / 2, tp.width / 2, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.stroke();

                void 0; //ctx.shadowBlur = 0;
                ctx.restore();

                // Teleport symbol
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('‚ö°', tp.x + tp.width / 2 - 10, tp.y + tp.height / 2 + 8);

                if (tp.cooldown > 0) tp.cooldown--;
            });
        }

        function drawIcePatches() {
            track.icePatches.forEach(ice => {
                const gradient = ctx.createLinearGradient(ice.x, 0, ice.x + ice.width, 0);
                gradient.addColorStop(0, 'rgba(200, 230, 255, 0.7)');
                gradient.addColorStop(0.5, 'rgba(220, 240, 255, 0.9)');
                gradient.addColorStop(1, 'rgba(200, 230, 255, 0.7)');
                ctx.fillStyle = gradient;
                ctx.fillRect(ice.x, ice.y, ice.width, ice.height);

                ctx.strokeStyle = '#88ccff';
                ctx.lineWidth = 2;
                ctx.strokeRect(ice.x, ice.y, ice.width, ice.height);

                // Ice crystals
                ctx.fillStyle = '#fff';
                for (let i = 0; i < 3; i++) {
                    const cx = ice.x + (i + 1) * ice.width / 4;
                    const cy = ice.y + ice.height / 2;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - 3);
                    ctx.lineTo(cx + 3, cy);
                    ctx.lineTo(cx, cy + 3);
                    ctx.lineTo(cx - 3, cy);
                    ctx.closePath();
                    ctx.fill();
                }
            });
        }

        function drawFans() {
            track.fans.forEach(fan => {
                fan.animation += 0.2;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(fan.x + 3, fan.y + 3, fan.width, fan.height);

                // Fan body
                const gradient = ctx.createLinearGradient(fan.x, fan.y, fan.x + fan.width, fan.y);
                gradient.addColorStop(0, '#555');
                gradient.addColorStop(1, '#888');
                ctx.fillStyle = gradient;
                ctx.fillRect(fan.x, fan.y, fan.width, fan.height);

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(fan.x, fan.y, fan.width, fan.height);

                // Spinning blades
                ctx.save();
                ctx.translate(fan.x + fan.width / 2, fan.y + fan.height / 2);
                ctx.rotate(fan.animation);
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(-15, 0);
                ctx.lineTo(15, 0);
                ctx.moveTo(0, -15);
                ctx.lineTo(0, 15);
                ctx.stroke();
                ctx.restore();

                // Wind particles
                for (let i = 0; i < 3; i++) {
                    const offset = (fan.animation + i) % 3;
                    const wx = fan.x + fan.width / 2 + fan.direction * offset * 20;
                    const wy = fan.y + fan.height / 2 + (Math.random() - 0.5) * 20;
                    ctx.fillStyle = 'rgba(200, 200, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(wx, wy, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        }

        function drawSpikes() {
            track.spikes.forEach(spike => {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                for (let i = 0; i < spike.width / 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(spike.x + i * 20 + 3, spike.y + spike.height + 3);
                    ctx.lineTo(spike.x + i * 20 + 10 + 3, spike.y + 3);
                    ctx.lineTo(spike.x + (i + 1) * 20 + 3, spike.y + spike.height + 3);
                    ctx.closePath();
                    ctx.fill();
                }

                const gradient = ctx.createLinearGradient(0, spike.y, 0, spike.y + spike.height);
                gradient.addColorStop(0, '#ff0000');
                gradient.addColorStop(1, '#990000');
                ctx.fillStyle = gradient;

                for (let i = 0; i < spike.width / 20; i++) {
                    ctx.beginPath();
                    ctx.moveTo(spike.x + i * 20, spike.y + spike.height);
                    ctx.lineTo(spike.x + i * 20 + 10, spike.y);
                    ctx.lineTo(spike.x + (i + 1) * 20, spike.y + spike.height);
                    ctx.closePath();
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
            });
        }

        function drawBoostPads() {
            track.boostPads.forEach((pad, idx) => {
                const time = Date.now() / 200;
                const offset = Math.sin(time + idx) * 2;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(pad.x + 3, pad.y + offset + 3, pad.width, pad.height);

                // Gradient
                const gradient = ctx.createLinearGradient(pad.x, 0, pad.x + pad.width, 0);
                gradient.addColorStop(0, '#ff6600');
                gradient.addColorStop(0.5, '#ffdd00');
                gradient.addColorStop(1, '#ff6600');
                ctx.fillStyle = gradient;
                ctx.fillRect(pad.x, pad.y + offset, pad.width, pad.height);

                // Animated stripes
                ctx.fillStyle = '#ff4400';
                const stripeWidth = 15;
                const stripeOffset = (Date.now() / 50) % (stripeWidth * 2);
                for (let i = -stripeOffset; i < pad.width; i += stripeWidth * 2) {
                    ctx.fillRect(pad.x + i, pad.y + offset, stripeWidth, pad.height);
                }

                ctx.strokeStyle = '#ff4400';
                ctx.lineWidth = 2;
                ctx.strokeRect(pad.x, pad.y + offset, pad.width, pad.height);
            });
        }

        function drawObstacles() {
            track.obstacles.forEach(obs => {
                if (obs.type === 'bumper') {
                    const centerX = obs.x + obs.width / 2;
                    const centerY = obs.y + obs.height / 2;
                    const radius = obs.width / 2;

                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.beginPath();
                    ctx.arc(centerX + 3, centerY + 3, radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Gradient
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
                    gradient.addColorStop(0, '#ff6666');
                    gradient.addColorStop(1, '#ff0000');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // Hazard stripes
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, radius - 5, 0, Math.PI * 2);
                    ctx.stroke();
                } else {
                    // Shadow
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.fillRect(obs.x + 3, obs.y + 3, obs.width, obs.height);

                    // Gradient
                    const gradient = ctx.createLinearGradient(0, obs.y, 0, obs.y + obs.height);
                    gradient.addColorStop(0, '#666');
                    gradient.addColorStop(1, '#333');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);

                    // Hazard stripes
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(obs.x, obs.y);
                    ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
                    ctx.moveTo(obs.x + obs.width, obs.y);
                    ctx.lineTo(obs.x, obs.y + obs.height);
                    ctx.stroke();
                }
            });
        }

        function drawCar(car) {
            if (!car.alive) return;

            ctx.save();
            ctx.translate(car.x, car.y);
            ctx.rotate(car.rotation);

            const w = car.width;
            const h = car.height;
            const isPlayer = car.id === 'player';

            // Hunter bot glow
            if (car.isHunter) {
                void 0; //ctx.shadowColor = '#ff0000';
                void 0; //ctx.shadowBlur = 25;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                roundedRect(ctx,-w / 2 - 4, -h / 2 - 4, w + 8, h + 8, 8);
                ctx.stroke();
                void 0; //ctx.shadowBlur = 0;
            }

            // Ground shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.25)';
            ctx.beginPath();
            ctx.ellipse(2, h / 2 + 8, w / 2.2, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            const speed = Math.abs(car.vx);

            // Car body - curved shape
            const bodyGrad = ctx.createLinearGradient(0, -h / 2, 0, h / 2);
            bodyGrad.addColorStop(0, adjustBrightness(car.color, 40));
            bodyGrad.addColorStop(0.3, car.color);
            bodyGrad.addColorStop(0.7, adjustBrightness(car.color, -20));
            bodyGrad.addColorStop(1, adjustBrightness(car.color, -50));
            ctx.fillStyle = bodyGrad;

            // Lower body (wider)
            ctx.beginPath();
            roundedRect(ctx,-w / 2, -h / 6, w, h / 2 + h / 6, 5);
            ctx.fill();
            ctx.strokeStyle = adjustBrightness(car.color, -60);
            ctx.lineWidth = 2;
            ctx.stroke();

            // Upper cabin (narrower)
            const cabinGrad = ctx.createLinearGradient(0, -h / 2, 0, -h / 6);
            cabinGrad.addColorStop(0, adjustBrightness(car.color, 20));
            cabinGrad.addColorStop(1, car.color);
            ctx.fillStyle = cabinGrad;
            ctx.beginPath();
            ctx.moveTo(-w / 4, -h / 6);
            ctx.lineTo(-w / 5, -h / 2 + 4);
            ctx.quadraticCurveTo(0, -h / 2 - 2, w / 5, -h / 2 + 4);
            ctx.lineTo(w / 3, -h / 6);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = adjustBrightness(car.color, -60);
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Windows
            const winGrad = ctx.createLinearGradient(0, -h / 2, 0, -h / 6);
            winGrad.addColorStop(0, 'rgba(140, 200, 255, 0.9)');
            winGrad.addColorStop(1, 'rgba(80, 140, 200, 0.8)');
            ctx.fillStyle = winGrad;
            // Front window
            ctx.beginPath();
            ctx.moveTo(w / 7, -h / 6 + 3);
            ctx.lineTo(w / 6, -h / 2 + 8);
            ctx.quadraticCurveTo(w / 8, -h / 2 + 5, w / 12, -h / 2 + 8);
            ctx.lineTo(-w / 10, -h / 6 + 3);
            ctx.closePath();
            ctx.fill();
            // Rear window
            ctx.beginPath();
            ctx.moveTo(-w / 8, -h / 6 + 3);
            ctx.lineTo(-w / 7, -h / 2 + 8);
            ctx.lineTo(-w / 5, -h / 2 + 8);
            ctx.lineTo(-w / 4 + 4, -h / 6 + 3);
            ctx.closePath();
            ctx.fill();

            // Window reflection
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(w / 9, -h / 6 + 4);
            ctx.lineTo(w / 8, -h / 2 + 10);
            ctx.lineTo(w / 14, -h / 2 + 10);
            ctx.lineTo(-w / 14, -h / 6 + 4);
            ctx.closePath();
            ctx.fill();

            // Headlights
            ctx.save();
            void 0; //ctx.shadowColor = isPlayer ? '#ffee88' : '#ffcc44';
            void 0; //ctx.shadowBlur = speed > 2 ? 12 : 6;
            ctx.fillStyle = isPlayer ? '#ffee88' : '#ffcc44';
            ctx.beginPath();
            roundedRect(ctx,w / 2 - 6, -h / 8, 6, 8, 2);
            ctx.fill();
            ctx.fillStyle = '#ffe0a0';
            ctx.beginPath();
            roundedRect(ctx,w / 2 - 6, h / 8 - 4, 6, 8, 2);
            ctx.fill();
            void 0; //ctx.shadowBlur = 0;
            ctx.restore();

            // Tail lights
            ctx.save();
            void 0; //ctx.shadowColor = '#ff2222';
            void 0; //ctx.shadowBlur = 8;
            ctx.fillStyle = '#ff3333';
            ctx.beginPath();
            roundedRect(ctx,-w / 2, -h / 8, 4, 7, 1);
            ctx.fill();
            ctx.beginPath();
            roundedRect(ctx,-w / 2, h / 8 - 3, 4, 7, 1);
            ctx.fill();
            void 0; //ctx.shadowBlur = 0;
            ctx.restore();

            // Spoiler for player car
            if (isPlayer) {
                ctx.fillStyle = adjustBrightness(car.color, -30);
                ctx.fillRect(-w / 2 - 6, -h / 4, 4, h / 2);
                ctx.fillStyle = adjustBrightness(car.color, -10);
                ctx.fillRect(-w / 2 - 10, -h / 4 - 2, 12, 3);
            }

            // Body highlight stripe
            ctx.fillStyle = `rgba(255, 255, 255, 0.15)`;
            ctx.fillRect(-w / 2 + 8, -h / 8, w - 16, 3);

            // Wheels with tire detail
            const wheelY = h / 2 - 2;
            const wheelR = 11;
            const hubR = 5;
            [-w / 3, w / 3].forEach(wx => {
                // Tire
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(wx, wheelY, wheelR, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.stroke();
                // Rim
                const rimGrad = ctx.createRadialGradient(wx - 1, wheelY - 1, 0, wx, wheelY, hubR);
                rimGrad.addColorStop(0, '#ddd');
                rimGrad.addColorStop(0.5, '#aaa');
                rimGrad.addColorStop(1, '#777');
                ctx.fillStyle = rimGrad;
                ctx.beginPath();
                ctx.arc(wx, wheelY, hubR, 0, Math.PI * 2);
                ctx.fill();
                // Wheel arch shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(wx, wheelY - 2, wheelR + 3, Math.PI, 0);
                ctx.lineTo(wx + wheelR + 3, wheelY - 2);
                ctx.lineTo(wx - wheelR - 3, wheelY - 2);
                ctx.fill();
            });

            // Player indicator
            if (isPlayer) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('YOU', 0, -h / 2 - 8);
                ctx.textAlign = 'left';
            }

            ctx.restore();
        }

        function adjustBrightness(color, amount) {
            const num = parseInt(color.replace('#', ''), 16);
            const r = Math.min(255, Math.max(0, (num >> 16) + amount));
            const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
            const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
            return `#${((r << 16) | (g << 8) | b).toString(16).padStart(6, '0')}`;
        }

        function checkPlatformCollision(car) {
            // Check regular platforms
            for (let platform of track.platforms) {
                const carBottom = car.y + car.height / 2;
                const carLeft = car.x - car.width / 2;
                const carRight = car.x + car.width / 2;

                if (carRight > platform.x && carLeft < platform.x + platform.width) {
                    if (carBottom >= platform.y && carBottom <= platform.y + platform.height && car.vy >= 0) {
                        car.y = platform.y - car.height / 2;
                        car.vy = 0;
                        car.onGround = true;
                        car.rotation = 0;
                        return true;
                    }
                }
            }

            // Check moving platforms
            for (let plat of track.movingPlatforms) {
                const carBottom = car.y + car.height / 2;
                const carLeft = car.x - car.width / 2;
                const carRight = car.x + car.width / 2;

                if (carRight > plat.x && carLeft < plat.x + plat.width) {
                    if (carBottom >= plat.y && carBottom <= plat.y + plat.height && car.vy >= 0) {
                        car.y = plat.y - car.height / 2;
                        car.vy = 0;
                        car.onGround = true;
                        car.rotation = 0;
                        car.vx += plat.speed * plat.direction * 0.5;
                        return true;
                    }
                }
            }

            return false;
        }

        function checkRampCollision(car) {
            for (let ramp of track.ramps) {
                const carBottom = car.y + car.height / 2;
                const carLeft = car.x - car.width / 2;
                const carRight = car.x + car.width / 2;

                if (carRight > ramp.x && carLeft < ramp.x + ramp.width) {
                    const relX = car.x - ramp.x;
                    const rampHeightAtX = (relX / ramp.width) * ramp.height;
                    const rampY = ramp.y - rampHeightAtX;

                    if (carBottom >= rampY - 5 && carBottom <= rampY + 10 && car.vy >= 0) {
                        car.y = rampY - car.height / 2;
                        car.vy = 0;
                        car.onGround = true;
                        car.rotation = Math.atan(ramp.height / ramp.width);
                        return true;
                    }
                }
            }
            return false;
        }

        function checkInteractives(car) {
            // Boost pads
            for (let pad of track.boostPads) {
                if (car.x + car.width / 2 > pad.x &&
                    car.x - car.width / 2 < pad.x + pad.width &&
                    car.y + car.height / 2 >= pad.y - 5 &&
                    car.y + car.height / 2 <= pad.y + pad.height + 5 &&
                    car.onGround) {

                    if (car.vx > 0) car.vx = Math.min(car.vx + 2, car.maxSpeed * 1.8);
                    else if (car.vx < 0) car.vx = Math.max(car.vx - 2, -car.maxSpeed * 1.8);
                    spawnParticles(car.x, car.y, 5, '#ff6600');
                }
            }

            // Jump pads
            for (let pad of track.jumpPads) {
                if (car.x + car.width / 2 > pad.x &&
                    car.x - car.width / 2 < pad.x + pad.width &&
                    car.y + car.height / 2 >= pad.y - 5 &&
                    car.y + car.height / 2 <= pad.y + pad.height + 5 &&
                    car.vy >= 0) {

                    car.vy = -pad.power;
                    car.onGround = false;
                    spawnParticles(car.x, car.y, 10, '#ff00ff');
                }
            }

            // Teleporters
            for (let tp of track.teleporters) {
                if (car.teleportCooldown <= 0) {
                    const dx = car.x - (tp.x + tp.width / 2);
                    const dy = car.y - (tp.y + tp.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < tp.width / 2 + car.width / 2 && tp.linkedTo && tp.cooldown <= 0) {
                        let destX = tp.linkedTo.x + tp.linkedTo.width / 2;
                        let destY = tp.linkedTo.y + tp.linkedTo.height / 2;
                        // Clamp destination inside arena bounds so teleporter can't kill you
                        destX = Math.max(arenaLeft + car.width, Math.min(arenaRight - car.width, destX));
                        car.x = destX;
                        car.y = destY;
                        car.vx = 0;
                        car.vy = 0;
                        car.teleportCooldown = 60;
                        tp.cooldown = 60;
                        tp.linkedTo.cooldown = 60;
                        spawnParticles(car.x, car.y, 15, '#00ffff');
                    }
                }
            }

            // Ice patches
            for (let ice of track.icePatches) {
                if (car.x + car.width / 2 > ice.x &&
                    car.x - car.width / 2 < ice.x + ice.width &&
                    car.y + car.height / 2 >= ice.y - 5 &&
                    car.y + car.height / 2 <= ice.y + ice.height + 5 &&
                    car.onGround) {
                    car.vx *= 1.01; // Ice = less friction
                }
            }

            // Fans
            for (let fan of track.fans) {
                if (car.x + car.width / 2 > fan.x &&
                    car.x - car.width / 2 < fan.x + fan.width &&
                    Math.abs(car.y - fan.y) < 100) {
                    car.vx += fan.force * fan.direction;
                }
            }

            // Spikes
            for (let spike of track.spikes) {
                if (car.x + car.width / 2 > spike.x &&
                    car.x - car.width / 2 < spike.x + spike.width &&
                    car.y + car.height / 2 >= spike.y &&
                    car.y - car.height / 2 <= spike.y + spike.height) {
                    car.vy = -15;
                    car.vx *= 1.5;
                    car.onGround = false;
                    spawnParticles(car.x, car.y, 8, '#ff0000');
                }
            }

            if (car.teleportCooldown > 0) car.teleportCooldown--;
        }

        function findNearestTarget(car, allCars) {
            // In challenge mode, always target the player
            if (challengeMode) {
                if (player.alive) return player;
                return null;
            }

            // 70% chance to target the player, 30% chance to target other bots
            if (Math.random() < 0.7) {
                // Target the player
                if (player.alive) {
                    return player;
                }
            }

            // 30% chance: target other bots
            let potentialTargets = [];

            for (let other of allCars) {
                if (other === car || !other.alive || other === player) continue;

                const dx = other.x - car.x;
                const dy = other.y - car.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // Add other bots within range to potential targets
                if (dist < 800) {
                    potentialTargets.push({car: other, dist: dist});
                }
            }

            if (potentialTargets.length === 0) {
                // If no other bots available, target player as fallback
                if (player.alive) return player;
                return null;
            }

            // Pick a random bot from available targets
            const randomIndex = Math.floor(Math.random() * potentialTargets.length);
            return potentialTargets[randomIndex].car;
        }

        function updateCar(car, isPlayer, allCars) {
            if (!car.alive) return;

            if (isPlayer && !gameOver) {
                if (deviceMode === 'mobile' && touchActive && touchTarget) {
                    // Finger-follow: pull car toward touch position
                    const dx = touchTarget.x - car.x;
                    const dy = touchTarget.y - car.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Horizontal pull
                    if (Math.abs(dx) > 20) {
                        car.vx += Math.sign(dx) * car.acceleration * 1.2;
                    }

                    // Jump if touching above the car
                    if (dy < -60 && car.onGround && dist > 50) {
                        car.vy = car.jumpPower;
                        car.onGround = false;
                    }

                    // Brake if touching very close
                    if (dist < 30 && car.onGround) {
                        car.vx *= 0.85;
                    }
                } else {
                    // Desktop keyboard controls
                    if (keys['ArrowRight']) {
                        car.vx += car.acceleration;
                    }
                    if (keys['ArrowLeft']) {
                        car.vx -= car.acceleration;
                    }
                    if (keys[' '] && car.onGround) {
                        car.vx *= 0.85;
                    }
                    if (keys['ArrowUp'] && car.onGround) {
                        car.vy = car.jumpPower;
                        car.onGround = false;
                    }
                }
            }

            if (!isPlayer && !gameOver) {
                car.aiTimer++;

                // Hunter bot special behavior
                if (car.isHunter) {
                    // Check if player is near other bots
                    let playerNearOthers = false;
                    for (let other of allCars) {
                        if (other !== player && other.alive && other !== car) {
                            const dx = player.x - other.x;
                            const dy = player.y - other.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < 200) {
                                playerNearOthers = true;
                                break;
                            }
                        }
                    }

                    if (playerNearOthers) {
                        // Player is fighting others, leave them alone
                        if (car.aiTimer % 90 === 0) {
                            car.target = findNearestTarget(car, allCars);
                        }
                    } else {
                        // Player is alone, hunt them!
                        car.target = player;
                    }
                } else {
                    // Normal bot behavior
                    if (!car.target || !car.target.alive || car.aiTimer % 90 === 0) {
                        car.target = findNearestTarget(car, allCars);
                    }
                }

                if (car.target) {
                    const distToTarget = car.target.x - car.x;
                    const heightDiff = car.y - car.target.y;

                    // Bots charge aggressively toward target, no caution near edges
                    if (distToTarget > 30) {
                        car.vx += car.acceleration * 2.0;
                    } else if (distToTarget < -30) {
                        car.vx -= car.acceleration * 2.0;
                    } else {
                        // Ram at full speed when close
                        if (distToTarget > 0) car.vx += car.acceleration * 2.5;
                        else car.vx -= car.acceleration * 2.5;
                    }

                    // Bots jump recklessly ‚Äî but only try to go UP if target is above
                    // If they fell below their target, they mostly just charge sideways
                    const canJump = car.onGround && car.aiTimer - car.lastJump > 15;
                    if (canJump) {
                        if (heightDiff > 80 && Math.abs(distToTarget) < 200 && Math.random() < 0.15) {
                            // Rarely try to jump back up
                            car.vy = car.jumpPower;
                            car.onGround = false;
                            car.lastJump = car.aiTimer;
                        } else if (heightDiff > -30 && heightDiff < 80 && Math.abs(distToTarget) < 200 && Math.random() < 0.3) {
                            // Jump when on same level and close ‚Äî this causes overshoots
                            car.vy = car.jumpPower;
                            car.onGround = false;
                            car.lastJump = car.aiTimer;
                        } else if (Math.random() < 0.06) {
                            car.vy = car.jumpPower;
                            car.onGround = false;
                            car.lastJump = car.aiTimer;
                        }
                    }
                } else {
                    // Wander wildly when no target
                    car.vx += (Math.random() - 0.5) * car.acceleration * 3;
                    if (car.onGround && Math.random() < 0.07) {
                        car.vy = car.jumpPower;
                        car.onGround = false;
                    }
                }
            }

            car.vx = Math.max(-car.maxSpeed, Math.min(car.maxSpeed, car.vx));

            if (!car.onGround) {
                car.vy += GRAVITY;
                car.rotationVel = car.vx * 0.015;
                car.rotation += car.rotationVel;
            } else {
                // Bots have less friction ‚Äî they slide more and overshoot platforms
                car.vx *= (isPlayer ? 0.96 : 0.98);
            }

            car.x += car.vx;
            car.y += car.vy;

            const onRamp = checkRampCollision(car);
            if (!onRamp) {
                const onPlatform = checkPlatformCollision(car);
                if (!onPlatform) {
                    car.onGround = false;
                }
            }

            checkInteractives(car);

            // Fall off sides = elimination (bots die closer to edge)
            const sideMargin = isPlayer ? car.width : car.width * 0.3;
            if (car.x < arenaLeft - sideMargin || car.x > arenaRight + sideMargin) {
                car.alive = false;
                spawnParticles(car.x, car.y, 20, car.color);
            }

            // Bounce down if going too high instead of dying
            const ceiling = GROUND_Y - numStories * STORY_HEIGHT - 200;
            if (car.y < ceiling) {
                car.y = ceiling;
                car.vy = Math.abs(car.vy) * 0.7 + 5;
                car.onGround = false;
            }

            // Bounce up if hitting the bottom instead of dying
            const floor = GROUND_Y + 100;
            if (car.y + car.height / 2 > floor) {
                car.y = floor - car.height / 2;
                car.vy = -Math.abs(car.vy) * 0.7 - 5;
                car.onGround = false;
                spawnParticles(car.x, floor, 8, car.color);
            }
        }

        function checkCollisions() {
            if (gameOver) return;

            const allCars = [player, ...aiCars];

            for (let i = 0; i < allCars.length; i++) {
                for (let j = i + 1; j < allCars.length; j++) {
                    const car1 = allCars[i];
                    const car2 = allCars[j];

                    if (!car1.alive || !car2.alive) continue;

                    const dx = car1.x - car2.x;
                    const dy = car1.y - car2.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < (car1.width + car2.width) / 2) {
                        const angle = Math.atan2(dy, dx);

                        // Calculate velocities and momentum
                        const car1Speed = Math.sqrt(car1.vx * car1.vx + car1.vy * car1.vy);
                        const car2Speed = Math.sqrt(car2.vx * car2.vx + car2.vy * car2.vy);

                        // Relative velocity (how fast are they approaching each other)
                        const relVelX = car1.vx - car2.vx;
                        const relVelY = car1.vy - car2.vy;
                        const relSpeed = Math.sqrt(relVelX * relVelX + relVelY * relVelY);

                        // Direction of collision
                        const normalX = Math.cos(angle);
                        const normalY = Math.sin(angle);

                        // Calculate relative velocity along collision normal
                        const velAlongNormal = relVelX * normalX + relVelY * normalY;

                        // Don't resolve if velocities are separating
                        if (velAlongNormal > 0) {
                            // Calculate restitution (bounciness) and mass ratio
                            const restitution = 0.8; // How bouncy the collision is

                            // Player is heavy, bots are light ‚Äî bots get knocked much farther
                            const mass1 = car1 === player ? 2.0 : 0.7;
                            const mass2 = car2 === player ? 2.0 : 0.7;

                            // Calculate impulse scalar
                            const impulseScalar = -(1 + restitution) * velAlongNormal / (mass1 + mass2);

                            // Apply impulse to separate the cars
                            const impulseX = impulseScalar * normalX;
                            const impulseY = impulseScalar * normalY;

                            // Realistic momentum transfer
                            car1.vx -= impulseX * mass2 * 1.5;
                            car1.vy -= impulseY * mass2 * 1.5;

                            car2.vx += impulseX * mass1 * 1.5;
                            car2.vy += impulseY * mass1 * 1.5;

                            // Add extra knockback based on impact speed (for gameplay feel)
                            const impactForce = relSpeed * 0.3;
                            car1.vx += normalX * impactForce;
                            car1.vy += normalY * impactForce - 2;

                            car2.vx -= normalX * impactForce;
                            car2.vy -= normalY * impactForce - 2;

                            // Push cars apart to prevent sticking
                            const overlap = (car1.width + car2.width) / 2 - dist;
                            const separationX = normalX * overlap * 0.5;
                            const separationY = normalY * overlap * 0.5;

                            car1.x += separationX;
                            car1.y += separationY;
                            car2.x -= separationX;
                            car2.y -= separationY;

                            car1.onGround = false;
                            car2.onGround = false;

                            // More particles for harder impacts
                            const particleCount = Math.floor(relSpeed * 2) + 5;
                            spawnParticles(car1.x, car1.y, particleCount, car1.color);
                            spawnParticles(car2.x, car2.y, particleCount, car2.color);

                            // Screen shake if player is involved
                            if (car1 === player || car2 === player) {
                                addScreenShake(relSpeed * 0.8);
                                // Track when player hits a bot (for challenge mode)
                                if (car1 === player && car2.lastHitByPlayer !== undefined) {
                                    car2.lastHitByPlayer = gameTimer;
                                }
                                if (car2 === player && car1.lastHitByPlayer !== undefined) {
                                    car1.lastHitByPlayer = gameTimer;
                                }
                            }
                        }
                    }
                }
            }

            track.obstacles.forEach(obs => {
                allCars.forEach(car => {
                    if (!car.alive) return;

                    const carLeft = car.x - car.width / 2;
                    const carRight = car.x + car.width / 2;
                    const carTop = car.y - car.height / 2;
                    const carBottom = car.y + car.height / 2;

                    if (obs.type === 'bumper') {
                        const centerX = obs.x + obs.width / 2;
                        const centerY = obs.y + obs.height / 2;
                        const radius = obs.width / 2;

                        const distX = car.x - centerX;
                        const distY = car.y - centerY;
                        const distance = Math.sqrt(distX * distX + distY * distY);

                        if (distance < radius + car.width / 2) {
                            const angle = Math.atan2(distY, distX);

                            // Calculate car's speed and direction
                            const carSpeed = Math.sqrt(car.vx * car.vx + car.vy * car.vy);

                            // Reflect velocity off bumper (like a real bumper)
                            const normalX = Math.cos(angle);
                            const normalY = Math.sin(angle);

                            // Bounce with amplification
                            const bounceMultiplier = 1.3 + carSpeed * 0.1;
                            car.vx = normalX * carSpeed * bounceMultiplier;
                            car.vy = normalY * carSpeed * bounceMultiplier - 4;

                            // Push car out of bumper
                            const overlap = radius + car.width / 2 - distance;
                            car.x += normalX * overlap;
                            car.y += normalY * overlap;

                            car.onGround = false;
                            spawnParticles(car.x, car.y, Math.floor(carSpeed * 2) + 8, car.color);

                            // Screen shake if player hit bumper
                            if (car === player) {
                                addScreenShake(carSpeed * 0.5);
                            }
                        }
                    } else {
                        if (carRight > obs.x && carLeft < obs.x + obs.width &&
                            carBottom > obs.y && carTop < obs.y + obs.height) {

                            // Calculate which side was hit
                            const carCenterX = car.x;
                            const carCenterY = car.y;
                            const obsCenterX = obs.x + obs.width / 2;
                            const obsCenterY = obs.y + obs.height / 2;

                            const dx = carCenterX - obsCenterX;
                            const dy = carCenterY - obsCenterY;

                            // Determine collision side
                            const overlapX = (car.width + obs.width) / 2 - Math.abs(dx);
                            const overlapY = (car.height + obs.height) / 2 - Math.abs(dy);

                            const carSpeed = Math.sqrt(car.vx * car.vx + car.vy * car.vy);

                            if (overlapX < overlapY) {
                                // Hit from left or right
                                if (dx < 0) {
                                    // Hit from left
                                    car.vx = -Math.abs(car.vx) * 1.2 - carSpeed * 0.3;
                                    car.x = obs.x - car.width / 2 - 2;
                                } else {
                                    // Hit from right
                                    car.vx = Math.abs(car.vx) * 1.2 + carSpeed * 0.3;
                                    car.x = obs.x + obs.width + car.width / 2 + 2;
                                }
                                car.vy -= 5 + carSpeed * 0.2;
                            } else {
                                // Hit from top or bottom
                                if (dy < 0) {
                                    // Hit from top
                                    car.vy = -Math.abs(car.vy) * 1.2;
                                    car.y = obs.y - car.height / 2 - 2;
                                } else {
                                    // Hit from bottom
                                    car.vy = Math.abs(car.vy) * 1.2;
                                    car.y = obs.y + obs.height + car.height / 2 + 2;
                                }
                                car.vx *= 0.7; // Lose some horizontal speed
                            }

                            car.onGround = false;
                            spawnParticles(car.x, car.y, Math.floor(carSpeed) + 5, car.color);

                            // Screen shake if player hit wall
                            if (car === player) {
                                addScreenShake(carSpeed * 0.4);
                            }
                        }
                    }
                });
            });
        }

        function checkWinCondition() {
            if (gameOver) return;

            const aliveCars = [player, ...aiCars].filter(car => car.alive);

            if (aliveCars.length === 1) {
                gameOver = true;
                if (aliveCars[0] === player) {
                    statusText.textContent = 'üèÜ YOU WIN! Last car standing! Press R to restart üèÜ';
                    statusText.style.color = '#00ff88';
                } else {
                    statusText.textContent = 'üíÄ YOU LOST! Press R to restart';
                    statusText.style.color = '#ff4444';
                }
            } else if (aliveCars.length === 0) {
                gameOver = true;
                statusText.textContent = 'EVERYONE FELL! Press R to restart';
                statusText.style.color = '#ffaa00';
            }
        }

        function drawUI() {
            // Speed indicator
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 10, 200, 35);

            const speedPercent = Math.abs(player.vx) / player.maxSpeed;
            const speedGradient = ctx.createLinearGradient(15, 0, 205, 0);
            speedGradient.addColorStop(0, '#00ff88');
            speedGradient.addColorStop(0.7, '#ffdd00');
            speedGradient.addColorStop(1, '#ff4444');
            ctx.fillStyle = speedGradient;
            ctx.fillRect(15, 15, speedPercent * 190, 20);

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(15, 15, 190, 20);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            void 0; //ctx.shadowColor = 'rgba(0,0,0,0.8)';
            void 0; //ctx.shadowBlur = 4;
            ctx.fillText('SPEED', 85, 30);
            void 0; //ctx.shadowBlur = 0;

            // Cars remaining
            const aliveCars = [player, ...aiCars].filter(car => car.alive);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(10, 55, 200, 35);
            ctx.fillStyle = '#ffdd00';
            ctx.font = 'bold 16px Arial';
            void 0; //ctx.shadowColor = 'rgba(0,0,0,0.8)';
            void 0; //ctx.shadowBlur = 4;
            ctx.fillText(`CARS LEFT: ${aliveCars.length}`, 30, 78);
            void 0; //ctx.shadowBlur = 0;

            // Shrink timer
            if (arenaRight - arenaLeft > 300) {
                const framesUntilShrink = SHRINK_INTERVAL - (gameTimer % SHRINK_INTERVAL);
                const secondsLeft = Math.ceil(framesUntilShrink / 60);
                const shrinkPercent = 1 - (framesUntilShrink / SHRINK_INTERVAL);

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 100, 200, 35);

                // Progress bar
                const barColor = secondsLeft <= 5 ? '#ff4444' : secondsLeft <= 10 ? '#ffaa00' : '#ff6600';
                ctx.fillStyle = barColor;
                ctx.fillRect(15, 105, shrinkPercent * 190, 20);

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(15, 105, 190, 20);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                void 0; //ctx.shadowColor = 'rgba(0,0,0,0.8)';
                void 0; //ctx.shadowBlur = 4;
                ctx.fillText(`SHRINK: ${secondsLeft}s`, 60, 120);
                void 0; //ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(10, 100, 200, 35);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                void 0; //ctx.shadowColor = 'rgba(0,0,0,0.8)';
                void 0; //ctx.shadowBlur = 4;
                ctx.fillText('MAX SHRINK!', 55, 122);
                void 0; //ctx.shadowBlur = 0;
            }

            // Challenge mode indicator
            if (challengeMode) {
                ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                ctx.fillRect(10, 145, 200, 35);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                void 0; //ctx.shadowColor = 'rgba(0,0,0,0.8)';
                void 0; //ctx.shadowBlur = 4;
                ctx.fillText('‚öîÔ∏è CHALLENGE MODE ‚öîÔ∏è', 30, 167);
                void 0; //ctx.shadowBlur = 0;
            }

            // Idle warning
            if (player.alive) {
                const idleTime = gameTimer - lastKeyPressTime;
                const timeLeft = IDLE_TIMEOUT - idleTime;

                if (timeLeft <= 120 && timeLeft > 0) { // Warning in last 2 seconds
                    const seconds = Math.ceil(timeLeft / 60);
                    const warningAlpha = (Math.sin(gameTimer * 0.3) + 1) / 2; // Pulsing effect
                    const warningY = challengeMode ? 190 : 145;

                    ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + warningAlpha * 0.5})`;
                    ctx.fillRect(10, warningY, 200, 40);

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 18px Arial';
                    void 0; //ctx.shadowColor = 'rgba(0,0,0,0.9)';
                    void 0; //ctx.shadowBlur = 6;
                    ctx.fillText(`‚è±Ô∏è MOVE IN ${seconds}s!`, 35, warningY + 25);
                    void 0; //ctx.shadowBlur = 0;
                }
            }

            if (gameOver && player.alive) {
                // WIN screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Confetti
                const confettiColors = ['#ff0000', '#00ff00', '#0088ff', '#ffdd00', '#ff00ff', '#00ffff'];
                for (let i = 0; i < 80; i++) {
                    const cx = (i * 137 + gameTimer * 2) % canvas.width;
                    const cy = ((i * 89 + gameTimer * 1.5) % (canvas.height + 200)) - 100;
                    const size = 4 + (i % 5) * 2;
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.rotate(gameTimer * 0.05 + i);
                    ctx.fillStyle = confettiColors[i % confettiColors.length];
                    ctx.fillRect(-size / 2, -size / 2, size, size * 0.4);
                    ctx.restore();
                }

                // Popup box
                const boxW = 500;
                const boxH = 300;
                const boxX = (canvas.width - boxW) / 2;
                const boxY = (canvas.height - boxH) / 2;

                // Box shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(boxX + 8, boxY + 8, boxW, boxH);

                // Box background
                const boxGrad = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxH);
                boxGrad.addColorStop(0, '#1a4d1a');
                boxGrad.addColorStop(1, '#0a2a0a');
                ctx.fillStyle = boxGrad;
                ctx.fillRect(boxX, boxY, boxW, boxH);

                // Gold border
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                ctx.strokeRect(boxX, boxY, boxW, boxH);
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 2;
                ctx.strokeRect(boxX + 6, boxY + 6, boxW - 12, boxH - 12);

                ctx.textAlign = 'center';
                void 0; //ctx.shadowColor = 'rgba(0,0,0,0.9)';
                void 0; //ctx.shadowBlur = 10;

                // Trophy
                ctx.font = '72px Arial';
                ctx.fillText('üèÜ', canvas.width / 2, boxY + 80);

                // Title
                ctx.font = 'bold 48px Arial';
                ctx.fillStyle = '#ffd700';
                ctx.fillText('YOU WIN!', canvas.width / 2, boxY + 150);

                // Subtitle
                ctx.font = 'bold 24px Arial';
                ctx.fillStyle = '#00ff88';
                ctx.fillText('Last Car Standing!', canvas.width / 2, boxY + 195);

                // Stats
                ctx.font = '18px Arial';
                ctx.fillStyle = '#ccc';
                const survivedSecs = Math.floor(gameTimer / 60);
                ctx.fillText(`Survived: ${survivedSecs}s  |  Stories: ${numStories}  |  Bots defeated: ${numBots}`, canvas.width / 2, boxY + 235);

                // Restart prompt
                const pulse = (Math.sin(gameTimer * 0.1) + 1) / 2;
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + pulse * 0.5})`;
                ctx.fillText('Press R to play again', canvas.width / 2, boxY + 275);

                void 0; //ctx.shadowBlur = 0;
                ctx.textAlign = 'left';

            } else if (!player.alive) {
                // ELIMINATED screen
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const boxW = 500;
                const boxH = 250;
                const boxX = (canvas.width - boxW) / 2;
                const boxY = (canvas.height - boxH) / 2;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(boxX + 8, boxY + 8, boxW, boxH);

                const boxGrad = ctx.createLinearGradient(boxX, boxY, boxX, boxY + boxH);
                boxGrad.addColorStop(0, '#4d1a1a');
                boxGrad.addColorStop(1, '#2a0a0a');
                ctx.fillStyle = boxGrad;
                ctx.fillRect(boxX, boxY, boxW, boxH);

                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 4;
                ctx.strokeRect(boxX, boxY, boxW, boxH);

                ctx.textAlign = 'center';
                void 0; //ctx.shadowColor = 'rgba(0,0,0,0.9)';
                void 0; //ctx.shadowBlur = 10;

                ctx.font = '56px Arial';
                ctx.fillText('üí•', canvas.width / 2, boxY + 70);

                ctx.font = 'bold 48px Arial';
                ctx.fillStyle = '#ff4444';
                ctx.fillText('ELIMINATED!', canvas.width / 2, boxY + 135);

                ctx.font = '18px Arial';
                ctx.fillStyle = '#ccc';
                const survivedSecs2 = Math.floor(gameTimer / 60);
                ctx.fillText(`Survived: ${survivedSecs2}s`, canvas.width / 2, boxY + 175);

                const pulse = (Math.sin(gameTimer * 0.1) + 1) / 2;
                ctx.font = 'bold 22px Arial';
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + pulse * 0.5})`;
                ctx.fillText('Press R to try again', canvas.width / 2, boxY + 225);

                void 0; //ctx.shadowBlur = 0;
                ctx.textAlign = 'left';
            }
        }

        function updateParticles() {
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => {
                p.update();
                p.draw();
            });
        }

        function reset() {
            gameOver = false;
            startMenu.style.display = 'block';
            canvas.style.display = 'none';
            infoDiv.style.display = 'none';
            touchRestartBtn.style.display = 'none';
            touchActive = false;
            touchTarget = null;
            gameStarted = false;
            challengeMode = false;
            keys['r'] = false;
            keys['R'] = false;
            gameTimer = 0;
            lastKeyPressTime = 0;
            hunterBot = null;
            cameraX = 0;
            cameraY = 0;
            cameraShakeX = 0;
            cameraShakeY = 0;
        }

        function gameLoop() {
            if (!gameStarted) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update camera to follow player
            updateCamera();

            drawBackground();

            // Darken areas outside arena bounds
            if (arenaLeft > 0) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(0, 0, arenaLeft, canvas.height);
            }
            if (arenaRight < canvas.width) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(arenaRight, 0, canvas.width - arenaRight, canvas.height);
            }

            // Draw arena walls first (outside the clip)
            ctx.save();
            ctx.translate(-cameraX + cameraShakeX, -cameraY + cameraShakeY);
            drawArenaWalls();
            ctx.restore();

            // Clip everything to arena bounds, then draw world objects
            ctx.save();
            if (arenaLeft > 0 || arenaRight < canvas.width) {
                ctx.beginPath();
                ctx.rect(arenaLeft, 0, arenaRight - arenaLeft, canvas.height);
                ctx.clip();
            }
            ctx.save();
            ctx.translate(-cameraX + cameraShakeX, -cameraY + cameraShakeY);

            drawWalls();
            drawPlatforms();
            drawMovingPlatforms();
            drawBoostPads();
            drawRamps();
            drawJumpPads();
            drawTeleporters();
            drawIcePatches();
            drawFans();
            drawSpikes();
            drawObstacles();

            const allCars = [player, ...aiCars];
            allCars.forEach(car => drawCar(car));

            updateParticles();

            // Draw world-space UI (follows player)
            if (player.alive && !player.onGround) {
                ctx.fillStyle = 'rgba(255, 200, 0, 0.9)';
                ctx.font = 'bold 28px Arial';
                void 0; //ctx.shadowColor = 'rgba(0,0,0,0.9)';
                void 0; //ctx.shadowBlur = 8;
                ctx.fillText('‚úàÔ∏è AIRBORNE!', player.x - 70, player.y - 50);
                void 0; //ctx.shadowBlur = 0;
            }

            // Restore camera transform
            ctx.restore();
            // Restore clip region
            ctx.restore();

            drawUI();

            // Draw touch indicator in mobile mode
            if (deviceMode === 'mobile' && touchActive && touchTarget && player.alive) {
                ctx.save();
                const screenX = touchTarget.x - cameraX;
                const screenY = touchTarget.y - cameraY;
                const pulse = Math.sin(gameTimer * 0.15) * 0.2 + 0.6;

                // Outer ring
                ctx.strokeStyle = `rgba(255, 255, 255, ${pulse * 0.5})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 25, 0, Math.PI * 2);
                ctx.stroke();

                // Inner dot
                ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 6, 0, Math.PI * 2);
                ctx.fill();

                // Line from car to touch
                const carScreenX = player.x - cameraX;
                const carScreenY = player.y - cameraY;
                ctx.strokeStyle = `rgba(255, 255, 255, 0.2)`;
                ctx.lineWidth = 1;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                ctx.moveTo(carScreenX, carScreenY);
                ctx.lineTo(screenX, screenY);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.restore();
            }

            // Assign hunter bot after 2 seconds (120 frames) - not in challenge mode
            if (!gameOver) {
                gameTimer++;

                // Shrink arena every 20 seconds
                if (gameTimer % SHRINK_INTERVAL === 0 && arenaRight - arenaLeft > 300) {
                    arenaLeft += SHRINK_AMOUNT;
                    arenaRight -= SHRINK_AMOUNT;
                    addScreenShake(10);
                }

                if (!challengeMode && gameTimer === 120 && hunterBot === null) {
                    // Clear all hunter flags first
                    aiCars.forEach(car => car.isHunter = false);

                    // Pick a random alive bot to be the hunter
                    const aliveBots = aiCars.filter(car => car.alive);
                    if (aliveBots.length > 0) {
                        hunterBot = aliveBots[Math.floor(Math.random() * aliveBots.length)];
                        hunterBot.isHunter = true;
                    }
                }

                // If hunter died, clear it
                if (hunterBot && !hunterBot.alive) {
                    hunterBot.isHunter = false;
                    hunterBot = null;
                }
            }

            updateCar(player, true, allCars);
            aiCars.forEach(car => updateCar(car, false, allCars));

            checkCollisions();
            checkWinCondition();

            // Check for idle timeout
            if (!gameOver && player.alive && gameTimer - lastKeyPressTime > IDLE_TIMEOUT) {
                player.alive = false;
                spawnParticles(player.x, player.y, 30, player.color);
                statusText.textContent = '‚è±Ô∏è ELIMINATED - 4 SECOND IDLE TIMEOUT!';
                statusText.style.color = '#ff4444';
            }

            if ((gameOver || !player.alive) && (keys['r'] || keys['R'])) {
                reset();
            }

            requestAnimationFrame(gameLoop);
        }
        // ---- TUTORIAL SYSTEM ----
        const tutSteps = [
            {
                title: 'STUNT CAR BATTLE ROYALE',
                body: `<h3>Welcome!</h3>
                    You're dropped into a multi-story arena with AI bots. Smash, ram, and launch them off the edges to be the <b style="color:#00ff88">last car standing!</b>
                    <div class="tut-panel" style="font-size:40px;letter-spacing:16px;text-align:center">üèéÔ∏èüí•üèéÔ∏èüí®</div>`
            },
            {
                title: 'CONTROLS',
                body: `<h3>Desktop</h3>
                    <div class="tut-panel">
                        <table style="margin:0 auto;text-align:left;border-spacing:10px 6px;color:#ccc;font-size:14px">
                            <tr><td style="color:#00ff88">Move Left</td><td><span class="tkey">‚Üê</span></td></tr>
                            <tr><td style="color:#00ff88">Move Right</td><td><span class="tkey">‚Üí</span></td></tr>
                            <tr><td style="color:#00ff88">Jump</td><td><span class="tkey">‚Üë</span></td></tr>
                            <tr><td style="color:#00ff88">Brake</td><td><span class="tkey">Space</span></td></tr>
                            <tr><td style="color:#00ff88">Restart</td><td><span class="tkey">R</span></td></tr>
                        </table>
                    </div>
                    <h3>Mobile</h3>
                    Touch & drag to pull your car toward your finger. Tap above your car to jump. Select <b>Mobile</b> mode on the menu to enable touch controls.`
            },
            {
                title: 'THE ARENA',
                body: `<h3>Multi-Story Battleground</h3>
                    The arena has multiple stories connected by <b style="color:#d4b896">ramps</b>. You and all bots start on the <b style="color:#ffd700">top level (gold platforms)</b>.
                    <div class="tut-panel">
                        <span style="color:#ffdd00">‚ö†Ô∏è</span> <b>Fall off the side edges and you're eliminated!</b><br><br>
                        <span style="color:#ff6600">‚ö†Ô∏è</span> The arena <b style="color:#ff4444">shrinks</b> every 20 seconds ‚Äî red energy walls close in from both sides, pushing everyone into a smaller space!
                    </div>
                    Choose <b>3‚Äì10 stories</b> in the menu. More stories = more bots = more chaos!`
            },
            {
                title: 'ARENA FEATURES',
                body: `<div class="feat-grid">
                        <div class="feat-item"><span class="fi-icon">üü´</span><span class="fi-name">Ramps</span><span class="fi-desc">Launch up to higher levels</span></div>
                        <div class="feat-item"><span class="fi-icon" style="color:#ff00ff">‚¨ÜÔ∏è</span><span class="fi-name">Jump Pads</span><span class="fi-desc">Pink springs, mega jump</span></div>
                        <div class="feat-item"><span class="fi-icon" style="color:#667eea">‚ÜîÔ∏è</span><span class="fi-name">Moving Platforms</span><span class="fi-desc">Blue, carry you sideways</span></div>
                        <div class="feat-item"><span class="fi-icon" style="color:#00ffff">‚ö°</span><span class="fi-name">Teleporters</span><span class="fi-desc">Cyan portals, warp between</span></div>
                        <div class="feat-item"><span class="fi-icon" style="color:#ff6600">üî•</span><span class="fi-name">Boost Pads</span><span class="fi-desc">Orange = speed burst</span></div>
                        <div class="feat-item"><span class="fi-icon" style="color:#88ccff">‚ùÑÔ∏è</span><span class="fi-name">Ice Patches</span><span class="fi-desc">Low friction, you slide</span></div>
                        <div class="feat-item"><span class="fi-icon">üåÄ</span><span class="fi-name">Wind Fans</span><span class="fi-desc">Push you sideways</span></div>
                        <div class="feat-item"><span class="fi-icon" style="color:#ff0000">‚ö†Ô∏è</span><span class="fi-name">Spikes</span><span class="fi-desc">Launch you painfully</span></div>
                    </div>`
            },
            {
                title: 'HAZARDS & OBSTACLES',
                body: `<h3>Watch Out!</h3>
                    <div class="feat-grid">
                        <div class="feat-item"><span class="fi-icon" style="color:#ff4444">üî¥</span><span class="fi-name">Bumpers</span><span class="fi-desc">Bounce you hard on impact</span></div>
                        <div class="feat-item"><span class="fi-icon" style="color:#888">üß±</span><span class="fi-name">Walls</span><span class="fi-desc">Gray blocks, bounce off</span></div>
                    </div>
                    <div class="tut-panel">
                        <b style="color:#ff4444">‚è±Ô∏è Idle Timeout:</b> If you don't press any keys for <b>4 seconds</b>, you'll be instantly eliminated! Keep moving!
                    </div>`
            },
            {
                title: 'COMBAT & PHYSICS',
                body: `<h3>How to Win Fights</h3>
                    <div class="tut-panel" style="text-align:left">
                        <span style="color:#00ff88">‚ñ∏</span> <b>You are heavier than bots</b> ‚Äî your hits send them flying further<br><br>
                        <span style="color:#00ff88">‚ñ∏</span> <b>Ram at full speed</b> for maximum knockback<br><br>
                        <span style="color:#00ff88">‚ñ∏</span> <b>Jumping attacks</b> are devastating ‚Äî land on top of bots<br><br>
                        <span style="color:#00ff88">‚ñ∏</span> Hit bots near <b>platform edges</b> to knock them off<br><br>
                        <span style="color:#00ff88">‚ñ∏</span> Use <b>ramps and boost pads</b> to gain speed before ramming
                    </div>`
            },
            {
                title: 'SPECIAL MODES',
                body: `<h3>Hunter Bot</h3>
                    <div class="tut-panel">
                        After 2 seconds, one random bot gets a <b style="color:#ff0000">red glow</b> and becomes the <b style="color:#ff4444">Hunter</b> ‚Äî it aggressively targets you! If the Hunter is eliminated, the threat disappears.
                    </div>
                    <h3>Challenge Mode</h3>
                    <div class="tut-panel">
                        Toggle <b>Challenge Mode</b> in the menu ‚Äî <b style="color:#ff4444">ALL bots target only you!</b> No mercy. Can you survive?
                    </div>`
            },
            {
                title: 'TIPS & TRICKS',
                body: `<div class="tut-panel" style="text-align:left;font-size:14px;line-height:2">
                        <span style="color:#ffdd00">‚≠ê</span> Stay on higher platforms ‚Äî let bots fall off naturally<br>
                        <span style="color:#ffdd00">‚≠ê</span> Use moving platforms to get unpredictable angles<br>
                        <span style="color:#ffdd00">‚≠ê</span> Brake with <span class="tkey">Space</span> to stop sliding off edges<br>
                        <span style="color:#ffdd00">‚≠ê</span> Teleporters can save you from the shrinking walls<br>
                        <span style="color:#ffdd00">‚≠ê</span> Ramps + boost pads = insane launch combos<br>
                        <span style="color:#ffdd00">‚≠ê</span> Bots overshoot jumps ‚Äî lure them near edges!<br>
                        <span style="color:#ffdd00">‚≠ê</span> More stories = more places to hide and ambush
                    </div>
                    <div style="text-align:center;margin-top:12px;font-size:18px;color:#00ff88">Good luck out there! üèÜ</div>`
            }
        ];

        let tutCurrent = 0;
        const tutOverlay = document.getElementById('tutorialOverlay');

        function showTutorial() {
            startMenu.style.display = 'none';
            tutOverlay.style.display = 'flex';
            tutCurrent = 0;
            renderTutStep();
        }

        function renderTutStep() {
            const s = tutSteps[tutCurrent];
            document.getElementById('tutTitle').textContent = s.title;
            document.getElementById('tutStepNum').textContent = 'STEP ' + (tutCurrent + 1) + ' / ' + tutSteps.length;
            document.getElementById('tutBody').innerHTML = s.body;
            document.getElementById('tutPrev').style.visibility = tutCurrent === 0 ? 'hidden' : 'visible';
            document.getElementById('tutNext').textContent = tutCurrent === tutSteps.length - 1 ? 'DONE' : 'NEXT';
            const dots = document.getElementById('tutDots');
            dots.innerHTML = '';
            for (let i = 0; i < tutSteps.length; i++) {
                const d = document.createElement('div');
                d.className = 'tut-dot' + (i === tutCurrent ? ' active' : '');
                dots.appendChild(d);
            }
        }

        document.getElementById('tutorialBtn').addEventListener('click', showTutorial);

        document.getElementById('tutNext').addEventListener('click', function() {
            if (tutCurrent < tutSteps.length - 1) {
                tutCurrent++;
                renderTutStep();
            } else {
                tutOverlay.style.display = 'none';
                startMenu.style.display = 'block';
            }
        });

        document.getElementById('tutPrev').addEventListener('click', function() {
            if (tutCurrent > 0) {
                tutCurrent--;
                renderTutStep();
            }
        });

        document.getElementById('tutClose').addEventListener('click', function() {
            tutOverlay.style.display = 'none';
            startMenu.style.display = 'block';
        });
    </script>
</body>
</html>

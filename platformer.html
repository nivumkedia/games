<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Adventure</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(180deg, #B8E6F8 0%, #D8F0FA 40%, #F0F8EC 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #gameContainer { display: flex; flex-direction: column; align-items: center; gap: 15px; }
        #gameCanvas {
            border: 4px solid #5D9E3C;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(93, 158, 60, 0.4);
        }
        #ui { display: flex; gap: 30px; color: #2d5016; font-size: 18px; }
        #ui span { background: rgba(255,255,255,0.8); padding: 8px 16px; border-radius: 20px; border: 2px solid #5D9E3C; }
        #instructions { color: #4a7030; font-size: 14px; text-align: center; }
        #message { position: absolute; color: #2d5016; font-size: 32px; font-weight: bold; text-shadow: 2px 2px 4px rgba(255,255,255,0.8); display: none; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <span>Score: <b id="score">0</b></span>
            <span>Level: <b id="level">1</b></span>
            <span>Lives: <b id="lives">3</b></span>
        </div>
        <canvas id="gameCanvas" width="800" height="500"></canvas>
        <div id="instructions">Arrow Keys/WASD to move | SPACE to jump | Collect coins, find water to heal, avoid lava!</div>
        <div id="message"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const livesEl = document.getElementById('lives');
        const messageEl = document.getElementById('message');

        let score = 0, level = 1, lives = 10, gameRunning = true, invincible = 0, levelComplete = false, deathsThisLevel = 0;

        // ---- Tutorial system ----
        let tutorialShown = {};
        let activeTutorials = [];
        let tutorialIndex = 0;
        let tutorialPaused = false;

        const tutorialDefs = {
            movement: { text: 'Arrow Keys / WASD to move, or click & drag!', target: 'player', offsetY: -70 },
            jump: { text: 'SPACE / UP to jump, or tap / click!', target: 'player', offsetY: -40 },
            coins: { text: 'Collect coins for points!', target: 'coin' },
            spikes: { text: 'Avoid spikes! They hurt!', target: 'spike' },
            lava: { text: 'Stay away from lava!', target: 'lava' },
            flag: { text: 'Reach the flag to finish!', target: 'flag' },
            springs: { text: 'Springs bounce you high!', target: 'spring' },
            water: { text: 'Water heals +1 life!', target: 'water' },
            movingPlatforms: { text: 'Moving platforms! Time your jumps!', target: 'movingPlatform' },
            portals: { text: 'Portals teleport you!', target: 'portal' },
            drones: { text: 'Drones shoot lasers! Dodge them!', target: 'drone' }
        };

        function getTutorialsForLevel(lvl) {
            var tips = [];
            if (lvl === 1) tips.push('movement', 'jump', 'coins', 'spikes', 'lava', 'flag');
            if (lvl === 2) tips.push('springs', 'water');
            if (lvl === 4) tips.push('movingPlatforms');
            if (lvl === 5) tips.push('portals');
            if (lvl === 20) tips.push('drones');
            return tips.filter(function(t) { return !tutorialShown[t]; });
        }

        function getTutorialTargetPos(def) {
            if (def.target === 'player') return { x: player.x + player.width / 2, y: player.y };
            if (def.target === 'coin') { var c = coins.find(function(c) { return !c.collected; }); return c ? { x: c.x + 10, y: c.y } : null; }
            if (def.target === 'spike') { var s = spikes[0]; return s ? { x: s.x + s.width / 2, y: s.y } : null; }
            if (def.target === 'lava') { var l = lava[0]; return l ? { x: l.x + l.width / 2, y: l.y } : null; }
            if (def.target === 'flag') return flag ? { x: flag.x + 10, y: flag.y } : null;
            if (def.target === 'spring') { var sp = springs[0]; return sp ? { x: sp.x + sp.width / 2, y: sp.y } : null; }
            if (def.target === 'water') { var w = water.find(function(w) { return !w.collected; }); return w ? { x: w.x + w.width / 2, y: w.y } : null; }
            if (def.target === 'movingPlatform') { var mp = movingPlatforms[0]; return mp ? { x: mp.x + mp.width / 2, y: mp.y } : null; }
            if (def.target === 'portal') { var p = portals[0]; return p ? { x: p.x + 15, y: p.y } : null; }
            if (def.target === 'drone') { var d = drones[0]; return d ? { x: d.x + d.width / 2, y: d.y } : null; }
            return null;
        }

        function showLevelTutorials() {
            var tips = getTutorialsForLevel(level);
            if (tips.length === 0) return;
            activeTutorials = tips;
            tutorialIndex = 0;
            tutorialPaused = true;
            tips.forEach(function(t) { tutorialShown[t] = true; });
        }

        function nextTutorial() {
            tutorialIndex++;
            if (tutorialIndex >= activeTutorials.length) {
                activeTutorials = [];
                tutorialIndex = 0;
                tutorialPaused = false;
            }
        }

        function dismissTutorials() {
            activeTutorials = [];
            tutorialIndex = 0;
            tutorialPaused = false;
        }

        function drawTutorials() {
            if (activeTutorials.length === 0) return;
            var t = globalTime * 0.016;
            var tipKey = activeTutorials[tutorialIndex];
            var def = tutorialDefs[tipKey];
            if (!def) return;
            var pos = getTutorialTargetPos(def);
            if (!pos) { nextTutorial(); return; }

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            var textY = pos.y - 45 + (def.offsetY || 0);
            if (textY < 30) textY = pos.y + 55;
            if (textY > 460) textY = 430;
            var textX = pos.x;
            if (textX < 100) textX = 100;
            if (textX > 700) textX = 700;

            var arrowPulse = Math.sin(t * 4) * 3;
            var arrowY = textY + 18;
            var arrowTargetY = pos.y - 5;
            if (textY > pos.y) { arrowY = textY - 8; arrowTargetY = pos.y + 25; }

            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2.5;
            ctx.setLineDash([5, 4]);
            ctx.beginPath();
            ctx.moveTo(textX, arrowY + arrowPulse);
            ctx.lineTo(pos.x, arrowTargetY + arrowPulse);
            ctx.stroke();
            ctx.setLineDash([]);

            var angle = Math.atan2(arrowTargetY - arrowY, pos.x - textX);
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(pos.x + arrowPulse * 0.3, arrowTargetY + arrowPulse);
            ctx.lineTo(pos.x - Math.cos(angle - 0.4) * 10, arrowTargetY + arrowPulse - Math.sin(angle - 0.4) * 10);
            ctx.lineTo(pos.x - Math.cos(angle + 0.4) * 10, arrowTargetY + arrowPulse - Math.sin(angle + 0.4) * 10);
            ctx.closePath();
            ctx.fill();

            ctx.font = 'bold 16px "Segoe UI", Tahoma, sans-serif';
            var textWidth = ctx.measureText(def.text).width;
            var boxW = textWidth + 28;
            var boxH = 32;
            var boxX = textX - boxW / 2;
            var boxY = textY - boxH / 2;
            if (boxX < 4) boxX = 4;
            if (boxX + boxW > 796) boxX = 796 - boxW;

            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.beginPath(); ctx.roundRect(boxX, boxY, boxW, boxH, 10); ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.roundRect(boxX, boxY, boxW, boxH, 10); ctx.stroke();

            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(def.text, boxX + boxW / 2, boxY + boxH / 2);

            var bottomY = canvas.height - 30;
            var isLast = tutorialIndex >= activeTutorials.length - 1;
            var btnLabel = isLast ? 'Got it!' : 'Next  \u25B6';

            var dotsStr = '';
            for (var di = 0; di < activeTutorials.length; di++) {
                dotsStr += di === tutorialIndex ? '\u25CF ' : '\u25CB ';
            }
            ctx.font = '14px "Segoe UI", Tahoma, sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.fillText(dotsStr.trim(), canvas.width / 2, bottomY + 16);

            ctx.font = 'bold 18px "Segoe UI", Tahoma, sans-serif';
            var btnTextW = ctx.measureText(btnLabel).width;
            var btnW = btnTextW + 36;
            var btnH = 36;
            var btnX = canvas.width / 2 - btnW / 2;
            var btnY = bottomY - btnH / 2;

            ctx.fillStyle = 'rgba(255,215,0,0.15)';
            ctx.beginPath(); ctx.roundRect(btnX - 4, btnY - 4, btnW + 8, btnH + 8, 14); ctx.fill();
            ctx.fillStyle = '#FFD700';
            ctx.beginPath(); ctx.roundRect(btnX, btnY, btnW, btnH, 10); ctx.fill();
            ctx.fillStyle = '#1a1a1a';
            ctx.fillText(btnLabel, canvas.width / 2, bottomY);

            // Skip button (top right)
            if (activeTutorials.length > 1) {
                var skipLabel = 'Skip All';
                ctx.font = 'bold 13px "Segoe UI", Tahoma, sans-serif';
                var skipW = ctx.measureText(skipLabel).width + 20;
                var skipH = 26;
                var skipX = canvas.width - skipW - 10;
                var skipY = 10;
                drawTutorials._skipX = skipX;
                drawTutorials._skipY = skipY;
                drawTutorials._skipW = skipW;
                drawTutorials._skipH = skipH;

                ctx.fillStyle = 'rgba(255,255,255,0.15)';
                ctx.beginPath(); ctx.roundRect(skipX, skipY, skipW, skipH, 8); ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                ctx.lineWidth = 1.5;
                ctx.beginPath(); ctx.roundRect(skipX, skipY, skipW, skipH, 8); ctx.stroke();
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(skipLabel, skipX + skipW / 2, skipY + skipH / 2);
            } else {
                drawTutorials._skipX = -1;
            }

            ctx.textAlign = 'start';
            ctx.textBaseline = 'alphabetic';
        }

        const player = {
            x: 50, y: 400, width: 30, height: 36,
            vx: 0, vy: 0, speed: 5, jumpPower: -13,
            onGround: false, facing: 1, animFrame: 0,
            portalCooldown: 0
        };

        const gravity = 0.6, friction = 0.85;
        const keys = {};

        let platforms = [], coins = [], spikes = [], springs = [], lava = [], portals = [], water = [];
        let movingPlatforms = [], flag = null, particles = [], clouds = [];
        let drones = [], lasers = [];
        let waterTimer = 0; // frames spent in water

        // ---- Visual-only state ----
        let screenShake = { x: 0, y: 0, intensity: 0 };
        let ambientParticles = [];
        let playerTrail = [];
        let backgroundTrees = [];
        let bgMountains = [];
        let globalTime = 0;
        let lavaEmbers = [];

        const colors = {
            player: '#E85D04', playerDark: '#BC4B03',
            platform: '#5D9E3C', platformTop: '#7EC850', platformDirt: '#8B5A2B',
            coin: '#FFD700', coinShine: '#FFF8DC',
            spike: '#4B5563', flag: '#22C55E', flagPole: '#92400E',
            sky1: '#87CEEB', sky2: '#E0F6FF', cloud: '#FFFFFF', sun: '#FCD34D',
            spring: '#FFD700', springBase: '#B8860B',
            lava: '#FF4500', lavaGlow: '#FF6347',
            portal: '#9B59B6', portalGlow: '#8E44AD',
            drone: '#374151', droneLight: '#EF4444',
            laser: '#EF4444', laserGlow: '#FCA5A5',
            water: '#2196F3', waterDeep: '#1565C0', waterSurface: '#64B5F6'
        };

        // ---- Visual initialization ----
        function initVisuals() {
            // Ambient floating particles (fireflies/dust)
            ambientParticles = [];
            for (let i = 0; i < 18; i++) {
                ambientParticles.push({
                    x: Math.random() * 800,
                    y: Math.random() * 480,
                    size: 1 + Math.random() * 2,
                    speed: 0.15 + Math.random() * 0.25,
                    angle: Math.random() * Math.PI * 2,
                    angleSpeed: (Math.random() - 0.5) * 0.03,
                    brightness: Math.random(),
                    brightnessDir: Math.random() > 0.5 ? 1 : -1,
                    color: Math.random() > 0.5 ? '#ffe88a' : '#ffffff'
                });
            }

            // Background trees (two layers)
            backgroundTrees = [];
            for (let i = 0; i < 9; i++) {
                backgroundTrees.push({
                    x: 20 + i * 95 + Math.random() * 40,
                    y: 390 + Math.random() * 15,
                    h: 55 + Math.random() * 30,
                    w: 18 + Math.random() * 10,
                    layer: 0
                });
            }
            for (let i = 0; i < 7; i++) {
                backgroundTrees.push({
                    x: 50 + i * 115 + Math.random() * 40,
                    y: 400 + Math.random() * 10,
                    h: 35 + Math.random() * 20,
                    w: 12 + Math.random() * 8,
                    layer: 1
                });
            }

            // Mountains (parallax layers)
            bgMountains = [
                // far layer
                [
                    { x: 0, y: 310 }, { x: 80, y: 240 }, { x: 180, y: 280 }, { x: 260, y: 210 },
                    { x: 360, y: 250 }, { x: 440, y: 200 }, { x: 540, y: 245 }, { x: 640, y: 215 },
                    { x: 720, y: 260 }, { x: 800, y: 290 }
                ],
                // mid layer
                [
                    { x: 0, y: 340 }, { x: 100, y: 290 }, { x: 200, y: 320 }, { x: 300, y: 270 },
                    { x: 400, y: 305 }, { x: 500, y: 265 }, { x: 600, y: 300 }, { x: 700, y: 280 },
                    { x: 800, y: 330 }
                ]
            ];

            // Lava embers
            lavaEmbers = [];
        }

        function initClouds() {
            clouds = [];
            for (let i = 0; i < 6; i++) {
                clouds.push({
                    x: Math.random() * 800,
                    y: 30 + Math.random() * 90,
                    size: 28 + Math.random() * 28,
                    speed: 0.18 + Math.random() * 0.18,
                    puffs: 3 + Math.floor(Math.random() * 3)
                });
            }
        }

        function generateLevel(lvl) {
            platforms = []; coins = []; spikes = []; springs = []; lava = []; portals = []; water = [];
            movingPlatforms = []; particles = []; levelComplete = false;
            drones = []; lasers = []; waterTimer = 0;

            // Ground
            platforms.push({ x: 0, y: 460, width: 800, height: 40, isGround: true });

            const layouts = [
                // Level 1 - intro
                () => {
                    // Split ground for lava pit
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 520, height: 40, isGround: true });
                    platforms.push({ x: 580, y: 460, width: 220, height: 40, isGround: true });
                    platforms.push({ x: 100, y: 380, width: 90, height: 20 });
                    platforms.push({ x: 280, y: 320, width: 85, height: 20 });
                    platforms.push({ x: 450, y: 260, width: 85, height: 20 });
                    platforms.push({ x: 620, y: 200, width: 90, height: 20 });
                    platforms.push({ x: 700, y: 140, width: 70, height: 20 });
                    spikes.push({ x: 380, y: 445, width: 36, height: 15 });
                    lava.push({ x: 520, y: 461, width: 60, height: 39 });
                },
                // Level 2 - springs
                () => {
                    // Split ground for lava pit
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 340, height: 40, isGround: true });
                    platforms.push({ x: 410, y: 460, width: 390, height: 40, isGround: true });
                    platforms.push({ x: 80, y: 390, width: 75, height: 20 });
                    platforms.push({ x: 220, y: 340, width: 70, height: 20 });
                    platforms.push({ x: 380, y: 290, width: 15, height: 20 });
                    platforms.push({ x: 435, y: 290, width: 15, height: 20 });
                    platforms.push({ x: 540, y: 240, width: 70, height: 20 });
                    platforms.push({ x: 680, y: 180, width: 75, height: 20 });
                    platforms.push({ x: 700, y: 120, width: 70, height: 20 });
                    springs.push({ x: 150, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    spikes.push({ x: 500, y: 445, width: 36, height: 15 });
                    lava.push({ x: 340, y: 461, width: 70, height: 39 });
                    water.push({ x: 395, y: 291, width: 40, height: 19, collected: false });
                },
                // Level 3 - jumps
                () => {
                    // Split ground for lava pits
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 200, height: 40, isGround: true });
                    platforms.push({ x: 270, y: 460, width: 360, height: 40, isGround: true });
                    platforms.push({ x: 690, y: 460, width: 110, height: 40, isGround: true });
                    platforms.push({ x: 60, y: 400, width: 65, height: 20 });
                    platforms.push({ x: 170, y: 350, width: 60, height: 20 });
                    platforms.push({ x: 280, y: 300, width: 60, height: 20 });
                    platforms.push({ x: 390, y: 350, width: 60, height: 20 });
                    platforms.push({ x: 500, y: 290, width: 60, height: 20 });
                    platforms.push({ x: 610, y: 240, width: 60, height: 20 });
                    platforms.push({ x: 700, y: 180, width: 65, height: 20 });
                    platforms.push({ x: 720, y: 120, width: 55, height: 20 });
                    springs.push({ x: 130, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    spikes.push({ x: 300, y: 445, width: 36, height: 15 });
                    lava.push({ x: 200, y: 461, width: 70, height: 39 });
                    lava.push({ x: 630, y: 461, width: 60, height: 39 });
                },
                // Level 4 - moving platforms
                () => {
                    // Split ground for lava pits
                    platforms.splice(0, 1);
                    platforms.push({ x: 0, y: 460, width: 180, height: 40, isGround: true });
                    platforms.push({ x: 250, y: 460, width: 410, height: 40, isGround: true });
                    platforms.push({ x: 720, y: 460, width: 80, height: 40, isGround: true });
                    platforms.push({ x: 40, y: 410, width: 55, height: 20 });
                    platforms.push({ x: 150, y: 360, width: 50, height: 20 });
                    platforms.push({ x: 290, y: 310, width: 50, height: 20 });
                    platforms.push({ x: 430, y: 360, width: 50, height: 20 });
                    platforms.push({ x: 570, y: 300, width: 10, height: 20 });
                    platforms.push({ x: 620, y: 300, width: 10, height: 20 });
                    platforms.push({ x: 430, y: 220, width: 55, height: 20 });
                    platforms.push({ x: 590, y: 160, width: 55, height: 20 });
                    platforms.push({ x: 700, y: 110, width: 65, height: 20 });
                    movingPlatforms.push({ x: 200, y: 280, width: 55, height: 15, minX: 160, maxX: 270, vx: 2 });
                    movingPlatforms.push({ x: 360, y: 250, width: 55, height: 15, minY: 200, maxY: 300, vy: 2 });
                    movingPlatforms.push({ x: 500, y: 220, width: 55, height: 15, minX: 460, maxX: 570, vx: 2.5 });
                    springs.push({ x: 100, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 500, y: 440, width: 30, height: 20, compressed: false });
                    spikes.push({ x: 400, y: 445, width: 36, height: 15 });
                    lava.push({ x: 180, y: 461, width: 70, height: 39 });
                    lava.push({ x: 660, y: 461, width: 60, height: 39 });
                    water.push({ x: 580, y: 301, width: 40, height: 19, collected: false });
                },
                // Level 5 - portals
                () => {
                    platforms.push({ x: 30, y: 420, width: 50, height: 20 });
                    platforms.push({ x: 120, y: 370, width: 50, height: 20 });
                    platforms.push({ x: 30, y: 310, width: 50, height: 20 });
                    platforms.push({ x: 120, y: 250, width: 50, height: 20 });
                    platforms.push({ x: 230, y: 310, width: 50, height: 20 });
                    platforms.push({ x: 340, y: 260, width: 50, height: 20 });
                    platforms.push({ x: 460, y: 320, width: 50, height: 20 });
                    platforms.push({ x: 570, y: 260, width: 50, height: 20 });
                    platforms.push({ x: 460, y: 180, width: 55, height: 20 });
                    platforms.push({ x: 610, y: 140, width: 55, height: 20 });
                    platforms.push({ x: 720, y: 100, width: 55, height: 20 });
                    movingPlatforms.push({ x: 170, y: 200, width: 50, height: 15, minX: 130, maxX: 230, vx: 2.5 });
                    movingPlatforms.push({ x: 390, y: 200, width: 50, height: 15, minY: 160, maxY: 260, vy: 2.5 });
                    movingPlatforms.push({ x: 540, y: 180, width: 50, height: 15, minX: 500, maxX: 600, vx: 3 });
                    movingPlatforms.push({ x: 680, y: 120, width: 45, height: 15, minY: 80, maxY: 160, vy: 2 });
                    movingPlatforms.push({ x: 300, y: 280, width: 45, height: 15, minX: 260, maxX: 360, vx: 3 });
                    springs.push({ x: 85, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 200, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 300, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 530, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 680, y: 440, width: 30, height: 20, compressed: false });
                    portals.push({ x: 50, y: 270, width: 30, height: 40, targetX: 250, targetY: 270, color: '#9B59B6' });
                    portals.push({ x: 360, y: 220, width: 30, height: 40, targetX: 480, targetY: 280, color: '#E74C3C' });
                    portals.push({ x: 590, y: 220, width: 30, height: 40, targetX: 630, targetY: 100, color: '#3498DB' });
                    portals.push({ x: 480, y: 140, width: 30, height: 40, targetX: 140, targetY: 210, color: '#1ABC9C' });
                    portals.push({ x: 250, y: 270, width: 30, height: 40, targetX: 590, targetY: 220, color: '#F39C12' });
                    spikes.push({ x: 100, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 160, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 250, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 340, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 400, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 500, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 600, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 720, y: 445, width: 36, height: 15 });
                    lava.push({ x: 120, y: 475, width: 45, height: 25 });
                    lava.push({ x: 180, y: 475, width: 50, height: 25 });
                    lava.push({ x: 280, y: 475, width: 50, height: 25 });
                    lava.push({ x: 430, y: 475, width: 50, height: 25 });
                    lava.push({ x: 560, y: 475, width: 50, height: 25 });
                    lava.push({ x: 650, y: 475, width: 50, height: 25 });
                },
                // Level 6 - lava
                () => {
                    platforms.push({ x: 25, y: 420, width: 48, height: 20 });
                    platforms.push({ x: 110, y: 370, width: 45, height: 20 });
                    platforms.push({ x: 195, y: 320, width: 45, height: 20 });
                    platforms.push({ x: 110, y: 260, width: 45, height: 20 });
                    platforms.push({ x: 280, y: 280, width: 45, height: 20 });
                    platforms.push({ x: 370, y: 330, width: 45, height: 20 });
                    platforms.push({ x: 460, y: 270, width: 45, height: 20 });
                    platforms.push({ x: 540, y: 220, width: 10, height: 20 });
                    platforms.push({ x: 590, y: 220, width: 10, height: 20 });
                    platforms.push({ x: 370, y: 180, width: 50, height: 20 });
                    platforms.push({ x: 480, y: 140, width: 50, height: 20 });
                    platforms.push({ x: 600, y: 180, width: 50, height: 20 });
                    platforms.push({ x: 700, y: 130, width: 55, height: 20 });
                    water.push({ x: 550, y: 221, width: 40, height: 19, collected: false });
                    movingPlatforms.push({ x: 210, y: 200, width: 48, height: 15, minX: 160, maxX: 270, vx: 3 });
                    movingPlatforms.push({ x: 420, y: 220, width: 48, height: 15, minY: 180, maxY: 280, vy: 2.5 });
                    movingPlatforms.push({ x: 620, y: 140, width: 48, height: 15, minX: 570, maxX: 680, vx: 3.5 });
                    movingPlatforms.push({ x: 150, y: 180, width: 45, height: 15, minY: 140, maxY: 220, vy: 3 });
                    movingPlatforms.push({ x: 330, y: 240, width: 45, height: 15, minX: 280, maxX: 380, vx: 3 });
                    movingPlatforms.push({ x: 560, y: 100, width: 45, height: 15, minX: 510, maxX: 610, vx: 3.5 });
                    springs.push({ x: 70, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 180, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 320, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 600, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 720, y: 440, width: 30, height: 20, compressed: false });
                    springs.push({ x: 570, y: 205, width: 25, height: 15, compressed: false });
                    springs.push({ x: 390, y: 165, width: 25, height: 15, compressed: false });
                    portals.push({ x: 130, y: 220, width: 30, height: 40, targetX: 300, targetY: 240, color: '#9B59B6' });
                    portals.push({ x: 480, y: 230, width: 30, height: 40, targetX: 390, targetY: 140, color: '#E74C3C' });
                    portals.push({ x: 390, y: 140, width: 30, height: 40, targetX: 570, targetY: 180, color: '#3498DB' });
                    portals.push({ x: 620, y: 140, width: 30, height: 40, targetX: 720, targetY: 90, color: '#1ABC9C' });
                    portals.push({ x: 215, y: 280, width: 30, height: 40, targetX: 480, targetY: 230, color: '#F39C12' });
                    spikes.push({ x: 100, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 140, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 200, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 240, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 300, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 360, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 400, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 500, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 560, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 640, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 700, y: 445, width: 36, height: 15 });
                    lava.push({ x: 60, y: 475, width: 40, height: 25 });
                    lava.push({ x: 100, y: 475, width: 40, height: 25 });
                    lava.push({ x: 160, y: 475, width: 40, height: 25 });
                    lava.push({ x: 220, y: 475, width: 50, height: 25 });
                    lava.push({ x: 280, y: 475, width: 40, height: 25 });
                    lava.push({ x: 350, y: 475, width: 50, height: 25 });
                    lava.push({ x: 430, y: 475, width: 50, height: 25 });
                    lava.push({ x: 530, y: 475, width: 50, height: 25 });
                    lava.push({ x: 620, y: 475, width: 40, height: 25 });
                    lava.push({ x: 680, y: 475, width: 40, height: 25 });
                },
                // Level 7 - maze
                () => {
                    platforms.push({ x: 20, y: 420, width: 45, height: 20 });
                    platforms.push({ x: 100, y: 370, width: 42, height: 20 });
                    platforms.push({ x: 180, y: 420, width: 42, height: 20 });
                    platforms.push({ x: 260, y: 360, width: 42, height: 20 });
                    platforms.push({ x: 100, y: 300, width: 42, height: 20 });
                    platforms.push({ x: 190, y: 250, width: 42, height: 20 });
                    platforms.push({ x: 320, y: 300, width: 42, height: 20 });
                    platforms.push({ x: 410, y: 250, width: 42, height: 20 });
                    platforms.push({ x: 500, y: 310, width: 42, height: 20 });
                    platforms.push({ x: 590, y: 260, width: 42, height: 20 });
                    platforms.push({ x: 410, y: 180, width: 45, height: 20 });
                    platforms.push({ x: 510, y: 140, width: 45, height: 20 });
                    platforms.push({ x: 620, y: 180, width: 45, height: 20 });
                    platforms.push({ x: 710, y: 120, width: 55, height: 20 });
                    movingPlatforms.push({ x: 140, y: 200, width: 45, height: 15, minY: 160, maxY: 260, vy: 3 });
                    movingPlatforms.push({ x: 280, y: 200, width: 45, height: 15, minX: 240, maxX: 340, vx: 3.5 });
                    movingPlatforms.push({ x: 460, y: 200, width: 45, height: 15, minY: 160, maxY: 250, vy: 3.5 });
                    movingPlatforms.push({ x: 580, y: 150, width: 45, height: 15, minX: 530, maxX: 630, vx: 3.5 });
                    movingPlatforms.push({ x: 670, y: 160, width: 45, height: 15, minY: 120, maxY: 200, vy: 3 });
                    movingPlatforms.push({ x: 50, y: 350, width: 42, height: 15, minX: 20, maxX: 100, vx: 2.5 });
                    movingPlatforms.push({ x: 350, y: 220, width: 42, height: 15, minY: 180, maxY: 270, vy: 3.5 });
                    movingPlatforms.push({ x: 720, y: 80, width: 45, height: 15, minX: 680, maxX: 760, vx: 4 });
                    springs.push({ x: 65, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 140, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 230, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 340, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 440, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 540, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 640, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 730, y: 440, width: 28, height: 20, compressed: false });
                    springs.push({ x: 610, y: 165, width: 22, height: 15, compressed: false });
                    springs.push({ x: 210, y: 235, width: 22, height: 15, compressed: false });
                    springs.push({ x: 430, y: 165, width: 22, height: 15, compressed: false });
                    portals.push({ x: 120, y: 260, width: 30, height: 40, targetX: 340, targetY: 260, color: '#9B59B6' });
                    portals.push({ x: 430, y: 210, width: 30, height: 40, targetX: 530, targetY: 270, color: '#E74C3C' });
                    portals.push({ x: 610, y: 220, width: 30, height: 40, targetX: 530, targetY: 100, color: '#3498DB' });
                    portals.push({ x: 640, y: 140, width: 30, height: 40, targetX: 430, targetY: 140, color: '#1ABC9C' });
                    portals.push({ x: 210, y: 210, width: 30, height: 40, targetX: 520, targetY: 270, color: '#F39C12' });
                    portals.push({ x: 340, y: 260, width: 30, height: 40, targetX: 610, targetY: 140, color: '#E91E63' });
                    portals.push({ x: 520, y: 100, width: 30, height: 40, targetX: 730, targetY: 80, color: '#00BCD4' });
                    spikes.push({ x: 80, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 120, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 180, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 240, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 300, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 360, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 420, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 480, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 540, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 600, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 660, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 720, y: 445, width: 36, height: 15 });
                    lava.push({ x: 50, y: 475, width: 35, height: 25 });
                    lava.push({ x: 90, y: 475, width: 35, height: 25 });
                    lava.push({ x: 150, y: 475, width: 40, height: 25 });
                    lava.push({ x: 210, y: 475, width: 40, height: 25 });
                    lava.push({ x: 260, y: 475, width: 40, height: 25 });
                    lava.push({ x: 320, y: 475, width: 40, height: 25 });
                    lava.push({ x: 380, y: 475, width: 40, height: 25 });
                    lava.push({ x: 450, y: 475, width: 40, height: 25 });
                    lava.push({ x: 510, y: 475, width: 40, height: 25 });
                    lava.push({ x: 570, y: 475, width: 40, height: 25 });
                    lava.push({ x: 630, y: 475, width: 40, height: 25 });
                    lava.push({ x: 700, y: 475, width: 40, height: 25 });
                },
                // Level 8 - precision
                () => {
                    platforms.push({ x: 15, y: 420, width: 40, height: 20 });
                    platforms.push({ x: 90, y: 380, width: 38, height: 20 });
                    platforms.push({ x: 165, y: 340, width: 38, height: 20 });
                    platforms.push({ x: 90, y: 290, width: 38, height: 20 });
                    platforms.push({ x: 165, y: 240, width: 38, height: 20 });
                    platforms.push({ x: 250, y: 290, width: 38, height: 20 });
                    platforms.push({ x: 335, y: 340, width: 38, height: 20 });
                    platforms.push({ x: 420, y: 290, width: 38, height: 20 });
                    platforms.push({ x: 500, y: 240, width: 10, height: 20 });
                    platforms.push({ x: 550, y: 240, width: 10, height: 20 });
                    water.push({ x: 510, y: 241, width: 40, height: 19, collected: false });
                    platforms.push({ x: 420, y: 180, width: 38, height: 20 });
                    platforms.push({ x: 335, y: 130, width: 38, height: 20 });
                    platforms.push({ x: 505, y: 130, width: 38, height: 20 });
                    platforms.push({ x: 590, y: 180, width: 38, height: 20 });
                    platforms.push({ x: 670, y: 130, width: 42, height: 20 });
                    platforms.push({ x: 730, y: 90, width: 50, height: 20 });
                    movingPlatforms.push({ x: 220, y: 180, width: 42, height: 15, minX: 180, maxX: 280, vx: 4 });
                    movingPlatforms.push({ x: 360, y: 200, width: 42, height: 15, minY: 160, maxY: 260, vy: 3.5 });
                    movingPlatforms.push({ x: 570, y: 120, width: 42, height: 15, minX: 520, maxX: 620, vx: 4 });
                    movingPlatforms.push({ x: 640, y: 160, width: 42, height: 15, minY: 120, maxY: 200, vy: 4 });
                    movingPlatforms.push({ x: 700, y: 120, width: 42, height: 15, minX: 650, maxX: 740, vx: 4.5 });
                    movingPlatforms.push({ x: 50, y: 350, width: 40, height: 15, minX: 20, maxX: 100, vx: 3 });
                    movingPlatforms.push({ x: 280, y: 220, width: 40, height: 15, minY: 180, maxY: 270, vy: 4 });
                    movingPlatforms.push({ x: 460, y: 100, width: 40, height: 15, minX: 420, maxX: 520, vx: 4.5 });
                    movingPlatforms.push({ x: 750, y: 50, width: 40, height: 15, minY: 40, maxY: 90, vy: 3 });
                    springs.push({ x: 55, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 130, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 200, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 280, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 380, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 470, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 550, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 630, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 700, y: 440, width: 26, height: 20, compressed: false });
                    springs.push({ x: 610, y: 165, width: 20, height: 15, compressed: false });
                    springs.push({ x: 440, y: 165, width: 20, height: 15, compressed: false });
                    springs.push({ x: 185, y: 225, width: 20, height: 15, compressed: false });
                    portals.push({ x: 110, y: 250, width: 30, height: 40, targetX: 270, targetY: 250, color: '#9B59B6' });
                    portals.push({ x: 355, y: 90, width: 30, height: 40, targetX: 525, targetY: 200, color: '#E74C3C' });
                    portals.push({ x: 440, y: 140, width: 30, height: 40, targetX: 610, targetY: 140, color: '#3498DB' });
                    portals.push({ x: 690, y: 90, width: 30, height: 40, targetX: 525, targetY: 90, color: '#1ABC9C' });
                    portals.push({ x: 185, y: 200, width: 30, height: 40, targetX: 440, targetY: 250, color: '#F39C12' });
                    portals.push({ x: 270, y: 250, width: 30, height: 40, targetX: 355, targetY: 300, color: '#E91E63' });
                    portals.push({ x: 525, y: 90, width: 30, height: 40, targetX: 690, targetY: 90, color: '#00BCD4' });
                    portals.push({ x: 610, y: 140, width: 30, height: 40, targetX: 750, targetY: 50, color: '#9C27B0' });
                    spikes.push({ x: 70, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 110, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 160, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 220, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 260, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 320, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 360, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 420, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 480, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 540, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 600, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 660, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 720, y: 445, width: 36, height: 15 });
                    lava.push({ x: 40, y: 475, width: 35, height: 25 });
                    lava.push({ x: 80, y: 475, width: 35, height: 25 });
                    lava.push({ x: 140, y: 475, width: 35, height: 25 });
                    lava.push({ x: 190, y: 475, width: 35, height: 25 });
                    lava.push({ x: 240, y: 475, width: 35, height: 25 });
                    lava.push({ x: 290, y: 475, width: 35, height: 25 });
                    lava.push({ x: 350, y: 475, width: 35, height: 25 });
                    lava.push({ x: 400, y: 475, width: 35, height: 25 });
                    lava.push({ x: 450, y: 475, width: 35, height: 25 });
                    lava.push({ x: 510, y: 475, width: 35, height: 25 });
                    lava.push({ x: 560, y: 475, width: 35, height: 25 });
                    lava.push({ x: 620, y: 475, width: 35, height: 25 });
                    lava.push({ x: 680, y: 475, width: 35, height: 25 });
                },
                // Level 9 - hard mode
                () => {
                    platforms.push({ x: 10, y: 430, width: 38, height: 20 });
                    platforms.push({ x: 85, y: 390, width: 35, height: 20 });
                    platforms.push({ x: 160, y: 350, width: 35, height: 20 });
                    platforms.push({ x: 85, y: 300, width: 35, height: 20 });
                    platforms.push({ x: 160, y: 250, width: 35, height: 20 });
                    platforms.push({ x: 240, y: 300, width: 35, height: 20 });
                    platforms.push({ x: 320, y: 250, width: 35, height: 20 });
                    platforms.push({ x: 400, y: 300, width: 35, height: 20 });
                    platforms.push({ x: 480, y: 250, width: 35, height: 20 });
                    platforms.push({ x: 560, y: 200, width: 35, height: 20 });
                    platforms.push({ x: 400, y: 170, width: 35, height: 20 });
                    platforms.push({ x: 320, y: 120, width: 35, height: 20 });
                    platforms.push({ x: 480, y: 120, width: 35, height: 20 });
                    platforms.push({ x: 640, y: 150, width: 35, height: 20 });
                    platforms.push({ x: 720, y: 200, width: 35, height: 20 });
                    platforms.push({ x: 640, y: 100, width: 38, height: 20 });
                    platforms.push({ x: 750, y: 70, width: 45, height: 20 });
                    movingPlatforms.push({ x: 200, y: 190, width: 38, height: 15, minX: 150, maxX: 260, vx: 4.5 });
                    movingPlatforms.push({ x: 280, y: 180, width: 38, height: 15, minY: 140, maxY: 220, vy: 4.5 });
                    movingPlatforms.push({ x: 420, y: 80, width: 38, height: 15, minX: 360, maxX: 500, vx: 5 });
                    movingPlatforms.push({ x: 560, y: 130, width: 38, height: 15, minY: 90, maxY: 170, vy: 4.5 });
                    movingPlatforms.push({ x: 700, y: 100, width: 38, height: 15, minX: 650, maxX: 760, vx: 5 });
                    movingPlatforms.push({ x: 50, y: 340, width: 35, height: 15, minX: 20, maxX: 100, vx: 4 });
                    movingPlatforms.push({ x: 350, y: 200, width: 35, height: 15, minY: 150, maxY: 250, vy: 5 });
                    movingPlatforms.push({ x: 600, y: 50, width: 35, height: 15, minX: 550, maxX: 660, vx: 5.5 });
                    springs.push({ x: 50, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 120, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 200, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 280, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 360, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 440, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 520, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 600, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 660, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 740, y: 440, width: 24, height: 20, compressed: false });
                    springs.push({ x: 580, y: 185, width: 18, height: 15, compressed: false });
                    springs.push({ x: 740, y: 185, width: 18, height: 15, compressed: false });
                    springs.push({ x: 420, y: 155, width: 18, height: 15, compressed: false });
                    springs.push({ x: 180, y: 235, width: 18, height: 15, compressed: false });
                    portals.push({ x: 105, y: 260, width: 30, height: 40, targetX: 260, targetY: 260, color: '#9B59B6' });
                    portals.push({ x: 180, y: 210, width: 30, height: 40, targetX: 420, targetY: 260, color: '#E74C3C' });
                    portals.push({ x: 340, y: 80, width: 30, height: 40, targetX: 580, targetY: 160, color: '#3498DB' });
                    portals.push({ x: 500, y: 80, width: 30, height: 40, targetX: 660, targetY: 160, color: '#1ABC9C' });
                    portals.push({ x: 660, y: 60, width: 30, height: 40, targetX: 770, targetY: 30, color: '#F39C12' });
                    portals.push({ x: 260, y: 260, width: 30, height: 40, targetX: 340, targetY: 210, color: '#E91E63' });
                    portals.push({ x: 420, y: 260, width: 30, height: 40, targetX: 500, targetY: 210, color: '#00BCD4' });
                    portals.push({ x: 660, y: 110, width: 30, height: 40, targetX: 770, targetY: 30, color: '#9C27B0' });
                    spikes.push({ x: 60, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 100, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 160, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 220, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 260, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 320, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 380, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 420, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 480, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 540, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 580, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 640, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 700, y: 445, width: 36, height: 15 });
                    spikes.push({ x: 760, y: 445, width: 36, height: 15 });
                    lava.push({ x: 40, y: 475, width: 35, height: 25 });
                    lava.push({ x: 80, y: 475, width: 35, height: 25 });
                    lava.push({ x: 130, y: 475, width: 35, height: 25 });
                    lava.push({ x: 180, y: 475, width: 35, height: 25 });
                    lava.push({ x: 240, y: 475, width: 35, height: 25 });
                    lava.push({ x: 290, y: 475, width: 35, height: 25 });
                    lava.push({ x: 350, y: 475, width: 35, height: 25 });
                    lava.push({ x: 410, y: 475, width: 35, height: 25 });
                    lava.push({ x: 460, y: 475, width: 35, height: 25 });
                    lava.push({ x: 510, y: 475, width: 35, height: 25 });
                    lava.push({ x: 570, y: 475, width: 35, height: 25 });
                    lava.push({ x: 620, y: 475, width: 35, height: 25 });
                    lava.push({ x: 680, y: 475, width: 35, height: 25 });
                    lava.push({ x: 730, y: 475, width: 35, height: 25 });
                }
            ];

            if (lvl <= layouts.length) {
                layouts[lvl - 1]();
            } else {
                generateProceduralLevel(lvl);
            }

            if (lvl >= 20) {
                const droneCount = Math.min(Math.floor((lvl - 19) / 3) + 1, 5);
                for (let i = 0; i < droneCount; i++) {
                    const dx = 150 + Math.random() * 500;
                    const dy = 80 + Math.random() * 200;
                    drones.push({
                        x: dx, y: dy, width: 40, height: 25,
                        startX: dx, patrolRange: 100 + Math.random() * 100,
                        direction: 1, speed: 1.5 + lvl * 0.05,
                        fireTimer: 60 + Math.floor(Math.random() * 60),
                        fireRate: Math.max(90 - lvl, 40)
                    });
                }
            }

            platforms.forEach((p) => {
                if (!p.isGround && Math.random() > 0.4) {
                    coins.push({ x: p.x + p.width / 2 - 10, y: p.y - 30, width: 20, height: 20, collected: false, bobOffset: Math.random() * Math.PI * 2 });
                }
            });

            const flagPositions = [
                { x: 720, y: 80 }, { x: 720, y: 60 }, { x: 740, y: 60 }, { x: 720, y: 50 },
                { x: 740, y: 40 }, { x: 700, y: 70 }, { x: 710, y: 60 }, { x: 730, y: 30 }, { x: 755, y: 10 }
            ];
            let flagPos;
            if (lvl <= 9) { flagPos = flagPositions[lvl - 1]; }
            else if (lvl >= 20) { flagPos = { x: 720, y: 100 }; }
            else { flagPos = { x: 730, y: 40 }; }
            flag = { x: flagPos.x, y: flagPos.y, width: 20, height: 60 };

            player.x = 50; player.y = 410; player.vx = 0; player.vy = 0;
            player.onGround = false; invincible = 0;
        }

        function generateProceduralLevel(lvl) {
            const seed = lvl * 12345;
            let randCounter = 0;
            const seededRandom = () => {
                randCounter++;
                const x = Math.sin(seed + randCounter) * 10000;
                return x - Math.floor(x);
            };

            if (lvl >= 20) {
                platforms.push({ x: 50, y: 370, width: 140, height: 20 });
                platforms.push({ x: 280, y: 300, width: 130, height: 20 });
                platforms.push({ x: 500, y: 230, width: 120, height: 20 });
                platforms.push({ x: 700, y: 160, width: 90, height: 20 });
                portals.push({ x: 100, y: 330, width: 30, height: 40, targetX: 300, targetY: 260, color: '#9B59B6' });
                springs.push({ x: 220, y: 440, width: 30, height: 20, compressed: false });
                springs.push({ x: 450, y: 440, width: 30, height: 20, compressed: false });
                return;
            }

            const difficulty = Math.min((lvl - 9) / 10, 1);
            const platformSize = 60 - difficulty * 8;
            const numPlatforms = 8 + Math.floor(difficulty * 4);
            const totalXRange = 610, totalYRange = 280;
            const baseStepX = totalXRange / numPlatforms, baseStepY = totalYRange / numPlatforms;
            let prevX = 50, prevY = 400;

            for (let i = 0; i < numPlatforms; i++) {
                const variation = (seededRandom() - 0.5) * 0.4;
                let newX = prevX + baseStepX * (1 + variation);
                let newY = prevY - baseStepY * (0.8 + seededRandom() * 0.4);
                let clampedX = Math.max(10, Math.min(660, newX));
                let clampedY = Math.max(100, Math.min(420, newY));
                // Ensure each step is jumpable: max 110px horizontal, max 70px up
                if (clampedX - prevX > 110) clampedX = prevX + 110;
                if (prevY - clampedY > 70) clampedY = prevY - 70;
                const width = platformSize + seededRandom() * 15;
                if (seededRandom() > 0.3) {
                    platforms.push({ x: clampedX, y: clampedY, width: width, height: 20 });
                } else {
                    const isHorizontal = seededRandom() > 0.5;
                    if (isHorizontal) {
                        movingPlatforms.push({ x: clampedX, y: clampedY, width: width - 5, height: 15, minX: Math.max(10, clampedX - 30), maxX: Math.min(750, clampedX + 30), vx: 1.5 + difficulty * (seededRandom() > 0.5 ? 1 : -1) });
                    } else {
                        movingPlatforms.push({ x: clampedX, y: clampedY, width: width - 5, height: 15, minY: Math.max(60, clampedY - 25), maxY: Math.min(400, clampedY + 25), vy: 1.5 + difficulty * (seededRandom() > 0.5 ? 1 : -1) });
                    }
                }
                prevX = clampedX; prevY = clampedY;
            }

            // Build a reachable staircase from the last generated platform to the flag area.
            // Max jumpable gap: ~120px horizontal, ~80px up (comfortable margin).
            const finalX = 720, finalY = 100;
            let curX = prevX, curY = prevY;
            let bridgeCount = 0;
            while ((finalX - curX > 120 || curY - finalY > 80) && bridgeCount < 5) {
                const stepX = Math.min(100, (finalX - curX) / 2);
                const stepY = Math.min(60, (curY - finalY) / 2);
                curX += stepX;
                curY -= stepY;
                curX = Math.min(curX, finalX - 60);
                curY = Math.max(curY, finalY + 30);
                platforms.push({ x: curX, y: curY, width: 55 + seededRandom() * 15, height: 20 });
                bridgeCount++;
            }
            platforms.push({ x: finalX, y: finalY, width: 70, height: 20 });

            const numSpikes = 4 + Math.floor(difficulty * 4);
            for (let i = 0; i < numSpikes; i++) { spikes.push({ x: 100 + (i * (600 / numSpikes)) + seededRandom() * 40, y: 445, width: 36, height: 15 }); }

            const numLava = 3 + Math.floor(difficulty * 4);
            for (let i = 0; i < numLava; i++) { lava.push({ x: 80 + (i * (620 / numLava)) + seededRandom() * 30, y: 475, width: 40, height: 25 }); }

            // Rare water pool in a platform
            if (seededRandom() > 0.6) {
                const staticPlats = platforms.filter(p => !p.isGround && p.width >= 50);
                if (staticPlats.length > 0) {
                    const wp = staticPlats[Math.floor(seededRandom() * staticPlats.length)];
                    const origX = wp.x, origW = wp.width, origY = wp.y, origH = wp.height;
                    wp.width = 10;
                    platforms.push({ x: origX + origW - 10, y: origY, width: 10, height: origH });
                    water.push({ x: origX + 10, y: origY + 1, width: origW - 20, height: origH - 1, collected: false });
                }
            }

            const numSprings = 3 + Math.floor(difficulty * 3);
            for (let i = 0; i < numSprings; i++) { springs.push({ x: 80 + seededRandom() * 640, y: 440, width: 28, height: 20, compressed: false }); }

            const numPortals = 2 + Math.floor(difficulty * 2);
            const portalColors = ['#9B59B6', '#E74C3C', '#3498DB', '#1ABC9C'];
            for (let i = 0; i < numPortals; i++) {
                const px = 100 + seededRandom() * 550;
                const py = 120 + seededRandom() * 220;
                // Ensure target is far enough from source and all other portals
                let tx, ty, attempts = 0;
                do {
                    tx = 100 + seededRandom() * 550;
                    ty = 100 + seededRandom() * 240;
                    attempts++;
                } while (attempts < 20 && (Math.abs(tx - px) < 80 && Math.abs(ty - py) < 80 ||
                    portals.some(p => Math.abs(tx - p.x) < 50 && Math.abs(ty - p.y) < 50)));
                portals.push({ x: px, y: py, width: 30, height: 40, targetX: tx, targetY: ty, color: portalColors[i % portalColors.length] });
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({ x, y, vx: (Math.random() - 0.5) * 6, vy: (Math.random() - 0.5) * 6, life: 1, color, size: 2 + Math.random() * 3 });
            }
        }

        function rectCollision(a, b) {
            return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
        }

        function update(dt) {
            if (!gameRunning || tutorialPaused) return;
            if (invincible > 0) invincible -= dt;

            globalTime++;

            // Update screen shake
            if (screenShake.intensity > 0) {
                screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
                screenShake.intensity *= Math.pow(0.85, dt);
                if (screenShake.intensity < 0.3) { screenShake.intensity = 0; screenShake.x = 0; screenShake.y = 0; }
            }

            // Input
            if (keys['ArrowLeft'] || keys['KeyA']) { player.vx = -player.speed; player.facing = -1; }
            else if (keys['ArrowRight'] || keys['KeyD']) { player.vx = player.speed; player.facing = 1; }
            else { player.vx *= Math.pow(friction, dt); }

            if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && player.onGround) {
                player.vy = player.jumpPower;
                player.onGround = false;
            }

            player.vy += gravity * dt;
            if (player.vy > 15) player.vy = 15;

            // Player trail
            if (Math.abs(player.vx) > 2.5 || Math.abs(player.vy) > 3) {
                playerTrail.push({ x: player.x + player.width / 2, y: player.y + player.height / 2, life: 1, size: player.width * 0.4 });
                if (playerTrail.length > 8) playerTrail.shift();
            }
            playerTrail.forEach(t => { t.life -= 0.12 * dt; });
            playerTrail = playerTrail.filter(t => t.life > 0);

            // Dust when running on ground
            if (player.onGround && Math.abs(player.vx) > 2 && globalTime % 5 === 0) {
                particles.push({ x: player.x + player.width / 2, y: player.y + player.height, vx: -player.vx * 0.3 + (Math.random() - 0.5) * 2, vy: -Math.random() * 1.5, life: 0.7, color: '#c8a060', size: 2 + Math.random() * 2 });
            }

            // Horizontal movement & collision
            player.x += player.vx * dt;
            const allPlatforms = [...platforms, ...movingPlatforms];
            for (const p of allPlatforms) {
                if (rectCollision(player, p)) {
                    if (player.vx > 0) player.x = p.x - player.width;
                    else if (player.vx < 0) player.x = p.x + p.width;
                    player.vx = 0;
                }
            }

            // Vertical movement & collision
            player.y += player.vy * dt;
            player.onGround = false;
            for (const p of allPlatforms) {
                if (rectCollision(player, p)) {
                    if (player.vy > 0) {
                        player.y = p.y - player.height;
                        player.vy = 0;
                        player.onGround = true;
                        if (p.vx) player.x += p.vx * dt;
                    } else if (player.vy < 0) {
                        player.y = p.y + p.height;
                        player.vy = 0;
                    }
                }
            }

            movingPlatforms.forEach(mp => {
                if (mp.vx !== undefined) { mp.x += mp.vx * dt; if (mp.x <= mp.minX || mp.x >= mp.maxX) mp.vx *= -1; }
                if (mp.vy !== undefined) { mp.y += mp.vy * dt; if (mp.y <= mp.minY || mp.y >= mp.maxY) mp.vy *= -1; }
            });

            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;

            if (player.y > canvas.height && invincible <= 0) { loseLife(); return; }

            if (invincible <= 0) {
                for (const spike of spikes) { if (rectCollision(player, spike)) { loseLife(); return; } }
            }
            if (invincible <= 0) {
                for (const l of lava) { if (rectCollision(player, l)) { loseLife(); return; } }
            }

            // Water - heals 1 life (one-time use)
            water.forEach(w => {
                if (!w.collected && rectCollision(player, w)) {
                    w.collected = true;
                    lives++; livesEl.textContent = lives;
                    createParticles(w.x + w.width / 2, w.y, '#64B5F6', 12);
                    createParticles(w.x + w.width / 2, w.y, '#BBDEFB', 8);
                }
            });

            springs.forEach(spring => {
                if (rectCollision(player, spring) && player.vy > 0) {
                    player.vy = -18;
                    spring.compressed = true;
                    screenShake.intensity = 5;
                    setTimeout(() => spring.compressed = false, 200);
                    createParticles(spring.x + 15, spring.y, colors.spring, 5);
                }
            });

            // Portal cooldown timer (counts down each frame)
            if (player.portalCooldown > 0) player.portalCooldown -= dt;
            portals.forEach(portal => {
                if (rectCollision(player, portal)) {
                    if (player.portalCooldown <= 0) {
                        player.x = portal.targetX; player.y = portal.targetY;
                        player.vy = Math.min(player.vy, 0); // don't fall fast into target
                        player.portalCooldown = 30; // ~0.5s cooldown timer
                        createParticles(portal.x + 15, portal.y + 20, portal.color, 10);
                        createParticles(portal.targetX + 15, portal.targetY + 20, portal.color, 10);
                    }
                }
            });

            coins.forEach(coin => {
                if (!coin.collected && rectCollision(player, coin)) {
                    coin.collected = true; score += 10; scoreEl.textContent = score;
                    createParticles(coin.x + 10, coin.y + 10, colors.coin, 8);
                }
            });

            if (!levelComplete && rectCollision(player, flag)) {
                levelComplete = true;
                if (level >= 50) {
                    score += 500; scoreEl.textContent = score; gameRunning = false;
                    showMessage('YOU WIN! Final Score: ' + score + ' - Press R', '#FFD700');
                } else {
                    let bonusLives = 0;
                    if (level >= 8) { bonusLives = Math.max(0, 4 - deathsThisLevel); lives += bonusLives; livesEl.textContent = lives; }
                    level++; levelEl.textContent = level; score += 50; scoreEl.textContent = score;
                    deathsThisLevel = 0; generateLevel(level);
                    let msg = 'Level ' + level;
                    if (level >= 20) msg += ' - DRONES!';
                    if (bonusLives > 0) msg += ' (+' + bonusLives + ' lives)';
                    showMessage(msg, '#22C55E');
                    setTimeout(() => { hideMessage(); showLevelTutorials(); }, 1500);
                }
            }

            drones.forEach(drone => {
                drone.x += drone.speed * drone.direction * dt;
                if (drone.x <= drone.startX - drone.patrolRange || drone.x >= drone.startX + drone.patrolRange) { drone.direction *= -1; }
                drone.fireTimer -= dt;
                if (drone.fireTimer <= 0) {
                    drone.fireTimer = drone.fireRate;
                    const angle = Math.atan2(player.y - drone.y, player.x - drone.x);
                    lasers.push({ x: drone.x + drone.width / 2, y: drone.y + drone.height, vx: Math.cos(angle) * 6, vy: Math.sin(angle) * 6, life: 120 });
                    createParticles(drone.x + drone.width / 2, drone.y + drone.height, colors.laser, 3);
                }
            });

            lasers = lasers.filter(laser => {
                laser.x += laser.vx * dt; laser.y += laser.vy * dt; laser.life -= dt;
                if (invincible <= 0) {
                    const laserRect = { x: laser.x - 5, y: laser.y - 5, width: 10, height: 10 };
                    if (rectCollision(player, laserRect)) { loseLife(); return false; }
                }
                return laser.life > 0 && laser.x > 0 && laser.x < 800 && laser.y > 0 && laser.y < 500;
            });

            if (Math.abs(player.vx) > 0.5) player.animFrame += 0.15 * dt;

            clouds.forEach(c => { c.x += c.speed * dt; if (c.x > 900) c.x = -100; });

            particles = particles.filter(p => {
                p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 0.15 * dt; p.life -= 0.025 * dt;
                return p.life > 0;
            });

            // Update ambient particles
            ambientParticles.forEach(ap => {
                ap.angle += ap.angleSpeed * dt;
                ap.x += Math.cos(ap.angle) * ap.speed * dt;
                ap.y += (Math.sin(ap.angle) * ap.speed * 0.5 - 0.05) * dt;
                ap.brightness += ap.brightnessDir * 0.02 * dt;
                if (ap.brightness > 1) { ap.brightness = 1; ap.brightnessDir = -1; }
                if (ap.brightness < 0) { ap.brightness = 0; ap.brightnessDir = 1; }
                if (ap.x > 810) ap.x = -10;
                if (ap.x < -10) ap.x = 810;
                if (ap.y < 0) ap.y = 490;
                if (ap.y > 490) ap.y = 0;
            });

            // Emit lava embers
            if (lava.length > 0 && globalTime % 4 === 0) {
                const src = lava[Math.floor(Math.random() * lava.length)];
                lavaEmbers.push({ x: src.x + Math.random() * src.width, y: src.y, vx: (Math.random() - 0.5) * 1.5, vy: -1.5 - Math.random() * 2, life: 1, size: 1.5 + Math.random() * 2 });
            }
            lavaEmbers = lavaEmbers.filter(e => { e.x += e.vx * dt; e.y += e.vy * dt; e.vy += 0.08 * dt; e.life -= 0.025 * dt; return e.life > 0; });
            if (lavaEmbers.length > 40) lavaEmbers.splice(0, lavaEmbers.length - 40);
        }

        function loseLife() {
            if (invincible > 0) return;
            lives--; deathsThisLevel++; livesEl.textContent = lives;
            createParticles(player.x + 15, player.y + 18, colors.player, 15);
            screenShake.intensity = 10;
            if (lives <= 0) {
                gameRunning = false;
                showMessage('Game Over! Press R to restart', '#DC2626');
            } else {
                player.x = 50; player.y = 410; player.vx = 0; player.vy = 0;
                invincible = 90;
            }
        }

        function showMessage(text, color) { messageEl.textContent = text; messageEl.style.color = color; messageEl.style.display = 'block'; }
        function hideMessage() { messageEl.style.display = 'none'; }

        function restart() {
            score = 0; level = 1; lives = 10; deathsThisLevel = 0;
            tutorialShown = {}; activeTutorials = []; tutorialIndex = 0; tutorialPaused = false;
            scoreEl.textContent = score; levelEl.textContent = level; livesEl.textContent = lives;
            gameRunning = true; invincible = 0; hideMessage();
            playerTrail = []; lavaEmbers = [];
            generateLevel(1);
            showLevelTutorials();
        }

        // ===================== DRAW =====================
        function draw() {
            const t = globalTime * 0.016; // smooth time in seconds-ish

            ctx.save();
            ctx.translate(screenShake.x, screenShake.y);

            // --- 1. REALISTIC SKY ---
            const skyGrad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            skyGrad.addColorStop(0, '#6DD0F5');
            skyGrad.addColorStop(0.2, '#8EDEF5');
            skyGrad.addColorStop(0.45, '#B0E8F8');
            skyGrad.addColorStop(0.65, '#D0F0FA');
            skyGrad.addColorStop(0.8, '#E8F6FC');
            skyGrad.addColorStop(1, '#F5FBF0');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Atmospheric haze near horizon
            const hazeGrad = ctx.createLinearGradient(0, 280, 0, 460);
            hazeGrad.addColorStop(0, 'rgba(210,230,245,0)');
            hazeGrad.addColorStop(0.5, 'rgba(210,230,245,0.08)');
            hazeGrad.addColorStop(1, 'rgba(220,238,220,0.15)');
            ctx.fillStyle = hazeGrad;
            ctx.fillRect(0, 280, 800, 180);

            // Warm sun-side glow on right side of sky
            const warmGlow = ctx.createRadialGradient(750, 100, 30, 700, 150, 350);
            warmGlow.addColorStop(0, 'rgba(255,245,210,0.08)');
            warmGlow.addColorStop(1, 'rgba(255,240,200,0)');
            ctx.fillStyle = warmGlow;
            ctx.fillRect(400, 0, 400, 350);

            // --- 2. SUN WITH RAYS ---
            const sunX = 700, sunY = 65;
            // Outer atmospheric glow
            const flareGrad2 = ctx.createRadialGradient(sunX, sunY, 20, sunX, sunY, 160);
            flareGrad2.addColorStop(0, 'rgba(255,250,210,0.3)');
            flareGrad2.addColorStop(0.4, 'rgba(255,240,180,0.1)');
            flareGrad2.addColorStop(1, 'rgba(255,240,180,0)');
            ctx.fillStyle = flareGrad2;
            ctx.beginPath(); ctx.arc(sunX, sunY, 160, 0, Math.PI * 2); ctx.fill();

            // Inner flare
            const flareGrad = ctx.createRadialGradient(sunX, sunY, 10, sunX, sunY, 80);
            flareGrad.addColorStop(0, 'rgba(255,255,240,0.6)');
            flareGrad.addColorStop(0.5, 'rgba(255,245,150,0.2)');
            flareGrad.addColorStop(1, 'rgba(255,240,120,0)');
            ctx.fillStyle = flareGrad;
            ctx.beginPath(); ctx.arc(sunX, sunY, 80, 0, Math.PI * 2); ctx.fill();

            // Soft rotating rays
            ctx.save();
            ctx.translate(sunX, sunY);
            ctx.rotate(t * 0.08);
            ctx.globalAlpha = 0.1;
            for (let i = 0; i < 16; i++) {
                const angle = (i / 16) * Math.PI * 2;
                const len = 55 + (i % 2) * 25 + (i % 3) * 10;
                ctx.strokeStyle = i % 2 === 0 ? '#ffe87a' : '#fff4b0';
                ctx.lineWidth = 2.5 - (i % 2) * 0.8;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * 35, Math.sin(angle) * 35);
                ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();

            // Sun body with realistic glow
            const sunBodyGrad = ctx.createRadialGradient(sunX - 4, sunY - 4, 2, sunX, sunY, 36);
            sunBodyGrad.addColorStop(0, '#FFFFF0');
            sunBodyGrad.addColorStop(0.3, '#FFF8D0');
            sunBodyGrad.addColorStop(0.7, '#FFE44D');
            sunBodyGrad.addColorStop(1, '#F0A030');
            ctx.fillStyle = sunBodyGrad;
            ctx.beginPath(); ctx.arc(sunX, sunY, 36, 0, Math.PI * 2); ctx.fill();

            // --- 3. FAR MOUNTAIN RANGE (atmospheric perspective - faded, blue-tinted) ---
            const mParallax0 = (t * 4) % 800;
            for (let offset = -800; offset <= 800; offset += 800) {
                const mPts = bgMountains[0];
                // Mountain body with gradient
                const farMtnGrad = ctx.createLinearGradient(0, 200, 0, 460);
                farMtnGrad.addColorStop(0, 'rgba(185,210,225,0.22)');
                farMtnGrad.addColorStop(0.3, 'rgba(195,218,205,0.18)');
                farMtnGrad.addColorStop(1, 'rgba(205,228,210,0.12)');
                ctx.fillStyle = farMtnGrad;
                ctx.beginPath();
                mPts.forEach((pt, i) => {
                    const px = pt.x + offset - mParallax0 * 0.15;
                    if (i === 0) ctx.moveTo(px, pt.y);
                    else ctx.lineTo(px, pt.y);
                });
                ctx.lineTo(800 + offset - mParallax0 * 0.15, 460);
                ctx.lineTo(0 + offset - mParallax0 * 0.15, 460);
                ctx.fill();
                // Snow caps on peaks
                ctx.fillStyle = 'rgba(245,252,255,0.25)';
                mPts.forEach((pt, i) => {
                    if (i > 0 && i < mPts.length - 1 && pt.y < mPts[i-1].y && pt.y < mPts[i+1].y) {
                        const px = pt.x + offset - mParallax0 * 0.15;
                        ctx.beginPath();
                        ctx.moveTo(px - 20, pt.y + 18);
                        ctx.lineTo(px, pt.y);
                        ctx.lineTo(px + 20, pt.y + 18);
                        ctx.closePath();
                        ctx.fill();
                    }
                });
            }

            // MID MOUNTAIN RANGE (slightly more saturated, less haze)
            for (let offset = -800; offset <= 800; offset += 800) {
                const mPts2 = bgMountains[1];
                const midMtnGrad = ctx.createLinearGradient(0, 260, 0, 460);
                midMtnGrad.addColorStop(0, 'rgba(145,195,150,0.25)');
                midMtnGrad.addColorStop(0.5, 'rgba(160,205,160,0.2)');
                midMtnGrad.addColorStop(1, 'rgba(175,215,170,0.15)');
                ctx.fillStyle = midMtnGrad;
                ctx.beginPath();
                mPts2.forEach((pt, i) => {
                    const px = pt.x + offset - mParallax0 * 0.3;
                    if (i === 0) ctx.moveTo(px, pt.y);
                    else ctx.lineTo(px, pt.y);
                });
                ctx.lineTo(800 + offset - mParallax0 * 0.3, 460);
                ctx.lineTo(0 + offset - mParallax0 * 0.3, 460);
                ctx.fill();
                // Sunlit right slope highlights
                ctx.fillStyle = 'rgba(200,235,160,0.2)';
                mPts2.forEach((pt, i) => {
                    if (i > 0 && i < mPts2.length - 1 && pt.y < mPts2[i-1].y) {
                        const px = pt.x + offset - mParallax0 * 0.3;
                        ctx.beginPath();
                        ctx.moveTo(px, pt.y);
                        ctx.lineTo(px + 30, pt.y + 30);
                        ctx.lineTo(px, pt.y + 30);
                        ctx.closePath();
                        ctx.fill();
                    }
                });
            }

            // Foreground rolling hills
            ctx.fillStyle = '#A8D880';
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            ctx.moveTo(0, 430);
            ctx.bezierCurveTo(100, 400, 200, 420, 320, 405);
            ctx.bezierCurveTo(420, 390, 520, 415, 620, 400);
            ctx.bezierCurveTo(700, 390, 750, 410, 800, 395);
            ctx.lineTo(800, 460); ctx.lineTo(0, 460);
            ctx.fill();
            // Sunlit tops of hills
            ctx.fillStyle = 'rgba(200,245,140,0.15)';
            ctx.beginPath();
            ctx.moveTo(0, 430);
            ctx.bezierCurveTo(100, 400, 200, 420, 320, 405);
            ctx.bezierCurveTo(420, 390, 520, 415, 620, 400);
            ctx.bezierCurveTo(700, 390, 750, 410, 800, 395);
            ctx.lineTo(800, 410); ctx.lineTo(0, 440);
            ctx.fill();
            ctx.globalAlpha = 1;

            // --- 4. BACKGROUND TREES (with shading and depth) ---
            backgroundTrees.forEach(tree => {
                const isFar = tree.layer === 0;
                const alpha = isFar ? 0.2 : 0.3;
                ctx.globalAlpha = alpha;
                const trunkW = tree.w * 0.18;
                const trunkH = tree.h * 0.4;

                // Trunk with gradient
                const trunkGrad = ctx.createLinearGradient(tree.x + tree.w * 0.4, 0, tree.x + tree.w * 0.6, 0);
                trunkGrad.addColorStop(0, isFar ? '#7A5D40' : '#8B6C50');
                trunkGrad.addColorStop(0.5, isFar ? '#9A7A58' : '#A08860');
                trunkGrad.addColorStop(1, isFar ? '#6A5038' : '#7A5840');
                ctx.fillStyle = trunkGrad;
                ctx.fillRect(tree.x + tree.w * 0.41, tree.y - trunkH, trunkW, trunkH + 5);

                // Canopy with lit top and shaded bottom
                const canopyY = tree.y - tree.h * 0.65;
                const canopyR = tree.w * 0.6;
                const canopyGrad = ctx.createRadialGradient(
                    tree.x + tree.w * 0.4, canopyY - canopyR * 0.3, canopyR * 0.15,
                    tree.x + tree.w * 0.5, canopyY, canopyR
                );
                canopyGrad.addColorStop(0, isFar ? '#8AD87A' : '#78CC68');
                canopyGrad.addColorStop(0.5, isFar ? '#6ABF5E' : '#58B04A');
                canopyGrad.addColorStop(1, isFar ? '#4A9F40' : '#3D8E35');
                ctx.fillStyle = canopyGrad;
                // Multiple overlapping canopy blobs for natural look
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.5, canopyY, canopyR, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.2, canopyY + canopyR * 0.25, canopyR * 0.7, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.8, canopyY + canopyR * 0.25, canopyR * 0.7, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.35, canopyY - canopyR * 0.3, canopyR * 0.5, 0, Math.PI * 2); ctx.fill();
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.65, canopyY - canopyR * 0.2, canopyR * 0.55, 0, Math.PI * 2); ctx.fill();

                // Sunlight highlight on top-right
                ctx.fillStyle = 'rgba(180,245,120,0.25)';
                ctx.beginPath(); ctx.arc(tree.x + tree.w * 0.65, canopyY - canopyR * 0.2, canopyR * 0.4, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- 5. REALISTIC CLOUDS (volumetric with light/shadow) ---
            clouds.forEach(c => {
                const totalW = c.puffs * c.size * 0.55;
                // Ground shadow
                ctx.globalAlpha = 0.06;
                ctx.fillStyle = '#556';
                ctx.beginPath();
                ctx.ellipse(c.x + totalW * 0.4, 440, totalW * 0.5, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Cloud bottom shadow layer
                ctx.globalAlpha = 0.12;
                ctx.fillStyle = '#8CA0B8';
                for (let pi = 0; pi < c.puffs; pi++) {
                    const puffR = c.size * (0.42 + (pi === Math.floor(c.puffs / 2) ? 0.1 : 0));
                    ctx.beginPath();
                    ctx.arc(c.x + pi * c.size * 0.55, c.y + puffR * 0.25, puffR * 0.9, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.globalAlpha = 1;

                // Main cloud body - each puff has lit top, shaded bottom
                for (let pi = 0; pi < c.puffs; pi++) {
                    const puffR = c.size * (0.45 + (pi === Math.floor(c.puffs / 2) ? 0.12 : 0));
                    const px = c.x + pi * c.size * 0.55;
                    // Main puff with realistic lighting
                    const cloudGrad = ctx.createRadialGradient(px + puffR * 0.15, c.y - puffR * 0.3, puffR * 0.1, px, c.y + puffR * 0.1, puffR);
                    cloudGrad.addColorStop(0, 'rgba(255,255,255,0.7)');
                    cloudGrad.addColorStop(0.4, 'rgba(250,252,255,0.6)');
                    cloudGrad.addColorStop(0.75, 'rgba(230,240,250,0.45)');
                    cloudGrad.addColorStop(1, 'rgba(210,225,240,0.2)');
                    ctx.fillStyle = cloudGrad;
                    ctx.beginPath();
                    ctx.arc(px, c.y, puffR, 0, Math.PI * 2);
                    ctx.fill();
                }
                // Bright sun-kissed highlight on top
                ctx.fillStyle = 'rgba(255,255,255,0.2)';
                const midPuff = Math.floor(c.puffs / 2);
                const hlX = c.x + midPuff * c.size * 0.55;
                const hlR = c.size * 0.3;
                ctx.beginPath(); ctx.arc(hlX + hlR * 0.3, c.y - c.size * 0.3, hlR, 0, Math.PI * 2); ctx.fill();
            });

            // --- 6. AMBIENT PARTICLES (fireflies/dust) ---
            ambientParticles.forEach(ap => {
                ctx.globalAlpha = ap.brightness * 0.3;
                const apGrad = ctx.createRadialGradient(ap.x, ap.y, 0, ap.x, ap.y, ap.size * 2.5);
                apGrad.addColorStop(0, ap.color);
                apGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = apGrad;
                ctx.beginPath(); ctx.arc(ap.x, ap.y, ap.size * 2.5, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- 7. LAVA ---
            lava.forEach(l => {
                // Outer glow
                const lGlow = ctx.createRadialGradient(l.x + l.width / 2, l.y, 0, l.x + l.width / 2, l.y + l.height / 2, l.width * 0.8);
                lGlow.addColorStop(0, 'rgba(255,100,0,0.5)');
                lGlow.addColorStop(1, 'rgba(255,40,0,0)');
                ctx.fillStyle = lGlow;
                ctx.fillRect(l.x - 8, l.y - 10, l.width + 16, l.height + 18);

                // Base lava gradient
                const lavaGrad = ctx.createLinearGradient(l.x, l.y, l.x, l.y + l.height);
                lavaGrad.addColorStop(0, '#ff7700');
                lavaGrad.addColorStop(0.4, '#ff4500');
                lavaGrad.addColorStop(1, '#cc2200');
                ctx.fillStyle = lavaGrad;
                ctx.fillRect(l.x, l.y, l.width, l.height);

                // Animated wave surface
                ctx.fillStyle = '#ff9933';
                ctx.beginPath();
                ctx.moveTo(l.x, l.y);
                const waveSegs = Math.max(4, Math.floor(l.width / 8));
                for (let i = 0; i <= waveSegs; i++) {
                    const wx = l.x + (i / waveSegs) * l.width;
                    const wy = l.y + Math.sin(t * 3 + i * 1.2 + l.x * 0.05) * 3;
                    ctx.lineTo(wx, wy);
                }
                ctx.lineTo(l.x + l.width, l.y + 5);
                ctx.lineTo(l.x, l.y + 5);
                ctx.fill();

                // Bright hotspots
                for (let i = 0; i < 2; i++) {
                    const hx = l.x + 8 + i * (l.width * 0.5);
                    const hy = l.y + 6 + Math.sin(t * 2.5 + i * 2.1) * 3;
                    const hGrad = ctx.createRadialGradient(hx, hy, 0, hx, hy, 7);
                    hGrad.addColorStop(0, 'rgba(255,230,100,0.9)');
                    hGrad.addColorStop(1, 'rgba(255,120,0,0)');
                    ctx.fillStyle = hGrad;
                    ctx.beginPath(); ctx.arc(hx, hy, 7, 0, Math.PI * 2); ctx.fill();
                }
            });

            // Lava embers
            lavaEmbers.forEach(e => {
                ctx.globalAlpha = e.life;
                const ec = `hsl(${20 + e.life * 30},100%,${50 + e.life * 30}%)`;
                ctx.fillStyle = ec;
                ctx.beginPath(); ctx.arc(e.x, e.y, e.size * e.life, 0, Math.PI * 2); ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- WATER POOLS (healing) ---
            water.forEach(w => {
                const wcx = w.x + w.width / 2, wcy = w.y + w.height / 2;

                // Outer healing glow
                const wGlow = ctx.createRadialGradient(wcx, w.y, 0, wcx, wcy, w.width * 0.9);
                wGlow.addColorStop(0, 'rgba(33,150,243,0.35)');
                wGlow.addColorStop(1, 'rgba(33,150,243,0)');
                ctx.fillStyle = wGlow;
                ctx.fillRect(w.x - 8, w.y - 8, w.width + 16, w.height + 16);

                // Base water gradient
                const wGrad = ctx.createLinearGradient(w.x, w.y, w.x, w.y + w.height);
                wGrad.addColorStop(0, colors.waterSurface);
                wGrad.addColorStop(0.4, colors.water);
                wGrad.addColorStop(1, colors.waterDeep);
                ctx.fillStyle = wGrad;
                ctx.globalAlpha = 0.8;
                ctx.fillRect(w.x, w.y, w.width, w.height);
                ctx.globalAlpha = 1;

                // Animated wave surface
                ctx.fillStyle = '#90CAF9';
                ctx.globalAlpha = 0.6;
                ctx.beginPath();
                ctx.moveTo(w.x, w.y);
                const wSegs = Math.max(3, Math.floor(w.width / 8));
                for (let i = 0; i <= wSegs; i++) {
                    const wx = w.x + (i / wSegs) * w.width;
                    const wy = w.y + Math.sin(t * 2.5 + i * 0.9 + w.x * 0.04) * 2;
                    ctx.lineTo(wx, wy);
                }
                ctx.lineTo(w.x + w.width, w.y + 4);
                ctx.lineTo(w.x, w.y + 4);
                ctx.fill();
                ctx.globalAlpha = 1;

                // Healing sparkle
                if (Math.sin(t * 4 + w.x) > 0.5) {
                    ctx.fillStyle = 'white';
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath(); ctx.arc(wcx + Math.sin(t * 3) * 5, w.y + 3, 2, 0, Math.PI * 2); ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });

            // --- 8. PLATFORMS ---
            [...platforms, ...movingPlatforms].forEach(p => {
                const isMoving = movingPlatforms.includes(p);

                // Drop shadow beneath platform
                ctx.fillStyle = 'rgba(0,0,0,0.12)';
                ctx.fillRect(p.x + 2, p.y + p.height, p.width - 2, 4);

                // Dirt/stone body with realistic gradient
                const dirtGrad = ctx.createLinearGradient(p.x, p.y + 4, p.x, p.y + p.height);
                dirtGrad.addColorStop(0, isMoving ? '#8060C0' : '#8B6832');
                dirtGrad.addColorStop(0.5, isMoving ? '#6b4fa0' : '#7A5428');
                dirtGrad.addColorStop(1, isMoving ? '#4a3070' : '#5C3D18');
                ctx.fillStyle = dirtGrad;
                ctx.fillRect(p.x, p.y + 4, p.width, p.height - 4);

                // Left edge highlight (light from sun on right)
                ctx.fillStyle = isMoving ? 'rgba(180,140,255,0.15)' : 'rgba(200,170,120,0.2)';
                ctx.fillRect(p.x, p.y + 4, 2, p.height - 4);
                // Right edge shadow
                ctx.fillStyle = 'rgba(0,0,0,0.15)';
                ctx.fillRect(p.x + p.width - 2, p.y + 4, 2, p.height - 4);

                // Stone texture cracks
                ctx.strokeStyle = isMoving ? 'rgba(100,60,160,0.3)' : 'rgba(60,30,10,0.25)';
                ctx.lineWidth = 1;
                for (let sx = p.x + 8; sx < p.x + p.width - 4; sx += 14) {
                    ctx.beginPath(); ctx.moveTo(sx, p.y + 5); ctx.lineTo(sx + 3, p.y + p.height - 2); ctx.stroke();
                }
                // Horizontal crack
                if (p.width > 40) {
                    ctx.beginPath(); ctx.moveTo(p.x + 4, p.y + p.height * 0.6); ctx.lineTo(p.x + p.width - 4, p.y + p.height * 0.65); ctx.stroke();
                }

                // Grass top band
                const grassGrad = ctx.createLinearGradient(p.x, p.y, p.x, p.y + 7);
                grassGrad.addColorStop(0, isMoving ? '#b06aff' : '#8AD450');
                grassGrad.addColorStop(1, isMoving ? '#7040c0' : '#5aaa30');
                ctx.fillStyle = grassGrad;
                ctx.fillRect(p.x, p.y, p.width, 7);

                // Top sunlit highlight
                ctx.fillStyle = isMoving ? 'rgba(200,150,255,0.5)' : 'rgba(200,255,120,0.5)';
                ctx.fillRect(p.x + 2, p.y, p.width - 4, 2);

                // Grass blades (more realistic)
                if (!isMoving) {
                    const bladeCount = Math.max(3, Math.floor(p.width / 10));
                    for (let ti = 0; ti < bladeCount; ti++) {
                        const tx = p.x + 3 + ti * (p.width / bladeCount) + Math.sin(ti * 7) * 2;
                        const bladeH = 3 + Math.abs(Math.sin(ti * 3.7)) * 4;
                        const lean = Math.sin(t * 1.5 + ti * 0.8) * 1.5;
                        ctx.strokeStyle = ti % 3 === 0 ? '#4CAF50' : '#5DC93A';
                        ctx.lineWidth = 1.2;
                        ctx.beginPath();
                        ctx.moveTo(tx, p.y);
                        ctx.quadraticCurveTo(tx + lean, p.y - bladeH * 0.6, tx + lean * 1.5, p.y - bladeH);
                        ctx.stroke();
                    }
                }

                // Small pebbles/texture on dirt face
                if (!isMoving && p.height > 12) {
                    ctx.globalAlpha = 0.18;
                    ctx.fillStyle = '#9A7B4A';
                    for (let mi = 0; mi < 3; mi++) {
                        const mxPos = p.x + 6 + mi * (p.width / 3.5);
                        ctx.beginPath(); ctx.ellipse(mxPos, p.y + 11, 3, 2, 0.3, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                }
            });

            // --- 9. METALLIC SPIKES ---
            spikes.forEach(spike => {
                const count = Math.floor(spike.width / 12);
                for (let i = 0; i < count; i++) {
                    const sx = spike.x + i * 12;
                    const sGrad = ctx.createLinearGradient(sx, spike.y + spike.height, sx + 6, spike.y);
                    sGrad.addColorStop(0, '#2a2f38');
                    sGrad.addColorStop(0.4, '#6a7585');
                    sGrad.addColorStop(0.7, '#c8cfd8');
                    sGrad.addColorStop(1, '#8090a0');
                    ctx.fillStyle = sGrad;
                    ctx.beginPath();
                    ctx.moveTo(sx, spike.y + spike.height);
                    ctx.lineTo(sx + 6, spike.y);
                    ctx.lineTo(sx + 12, spike.y + spike.height);
                    ctx.closePath();
                    ctx.fill();
                    // Gleam
                    ctx.globalAlpha = 0.6;
                    ctx.strokeStyle = '#e8eef5';
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(sx + 4, spike.y + spike.height - 2);
                    ctx.lineTo(sx + 6, spike.y + 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            });

            // --- 10. SPRINGS ---
            springs.forEach(spring => {
                const h = spring.compressed ? 8 : spring.height;
                const sw = spring.width;

                // Base plate
                const baseGrad = ctx.createLinearGradient(spring.x, spring.y + h - 5, spring.x + sw, spring.y + h);
                baseGrad.addColorStop(0, '#8a6010');
                baseGrad.addColorStop(0.5, '#c8980a');
                baseGrad.addColorStop(1, '#8a6010');
                ctx.fillStyle = baseGrad;
                ctx.fillRect(spring.x, spring.y + h - 5, sw, 5);

                // Coil segments
                const coilH = h - 5;
                const coilSegs = 4;
                const segH = coilH / coilSegs;
                for (let ci = 0; ci < coilSegs; ci++) {
                    const cy = spring.y + ci * segH;
                    const bright = ci % 2 === 0 ? 1 : 0.7;
                    ctx.fillStyle = `rgba(255,${Math.floor(200 * bright)},0,1)`;
                    ctx.fillRect(spring.x + 3, cy, sw - 6, segH - 1);
                    // Coil highlight
                    ctx.fillStyle = 'rgba(255,255,200,0.4)';
                    ctx.fillRect(spring.x + 4, cy, (sw - 8) * 0.4, 2);
                }

                // Top cap
                const topGrad = ctx.createLinearGradient(spring.x, spring.y, spring.x + sw, spring.y + 4);
                topGrad.addColorStop(0, '#ffe870');
                topGrad.addColorStop(0.5, '#ffffff');
                topGrad.addColorStop(1, '#ffe870');
                ctx.fillStyle = topGrad;
                ctx.fillRect(spring.x, spring.y, sw, 4);
            });

            // --- 11. PORTALS ---
            portals.forEach(portal => {
                const px = portal.x + 15, py = portal.y + 20;
                const spin = t * 2.5;

                // Outer glow
                const pGlow = ctx.createRadialGradient(px, py, 5, px, py, 32);
                pGlow.addColorStop(0, portal.color + 'aa');
                pGlow.addColorStop(1, portal.color + '00');
                ctx.fillStyle = pGlow;
                ctx.beginPath(); ctx.ellipse(px, py, 32, 34, 0, 0, Math.PI * 2); ctx.fill();

                // Rotating outer ring
                ctx.save();
                ctx.translate(px, py);
                ctx.rotate(spin);
                ctx.strokeStyle = portal.color;
                ctx.lineWidth = 2.5;
                ctx.globalAlpha = 0.85;
                ctx.beginPath();
                for (let ri = 0; ri < 8; ri++) {
                    const ra = (ri / 8) * Math.PI * 2;
                    const rr = 18 + Math.sin(spin * 2 + ri) * 2;
                    ctx.moveTo(Math.cos(ra) * (rr - 5), Math.sin(ra) * (rr - 5) * 1.2);
                    ctx.lineTo(Math.cos(ra) * rr, Math.sin(ra) * rr * 1.2);
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
                // Orbiting particles
                for (let oi = 0; oi < 4; oi++) {
                    const oa = spin + (oi / 4) * Math.PI * 2;
                    const ox = Math.cos(oa) * 18, oy = Math.sin(oa) * 20;
                    ctx.fillStyle = portal.color;
                    ctx.beginPath(); ctx.arc(ox, oy, 2.5, 0, Math.PI * 2); ctx.fill();
                }
                ctx.restore();

                // Inner portal body
                const portalBody = ctx.createRadialGradient(px, py, 1, px, py, 14);
                portalBody.addColorStop(0, 'rgba(255,255,255,0.95)');
                portalBody.addColorStop(0.4, portal.color + 'dd');
                portalBody.addColorStop(1, portal.color + '44');
                ctx.fillStyle = portalBody;
                ctx.beginPath(); ctx.ellipse(px, py, 14, 18, 0, 0, Math.PI * 2); ctx.fill();

                // Warp shimmer
                ctx.globalAlpha = 0.3 + Math.sin(t * 4 + portal.x) * 0.2;
                ctx.fillStyle = 'white';
                ctx.beginPath(); ctx.ellipse(px - 3, py - 4, 5, 8, -0.4, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            });

            // --- 12. FLAG ---
            if (flag) {
                // Pole shadow
                ctx.fillStyle = 'rgba(0,0,0,0.2)';
                ctx.fillRect(flag.x + 10, flag.y, 3, flag.height);

                // Pole gradient
                const poleGrad = ctx.createLinearGradient(flag.x + 8, 0, flag.x + 12, 0);
                poleGrad.addColorStop(0, '#5a2a04');
                poleGrad.addColorStop(0.4, '#c07030');
                poleGrad.addColorStop(1, '#5a2a04');
                ctx.fillStyle = poleGrad;
                ctx.fillRect(flag.x + 8, flag.y, 4, flag.height);

                // Waving flag cloth
                const waveAmp = 4;
                const waveFreq = t * 4;
                ctx.fillStyle = '#22C55E';
                ctx.beginPath();
                ctx.moveTo(flag.x + 12, flag.y);
                // Top edge wave
                for (let fi = 0; fi <= 26; fi++) {
                    const fx = flag.x + 12 + fi;
                    const fy = flag.y + Math.sin(waveFreq + fi * 0.3) * waveAmp * (fi / 26);
                    if (fi === 0) ctx.lineTo(fx, fy); else ctx.lineTo(fx, fy);
                }
                // Bottom edge wave
                for (let fi = 26; fi >= 0; fi--) {
                    const fx = flag.x + 12 + fi;
                    const fy = flag.y + 26 + Math.sin(waveFreq + fi * 0.3 + 1) * waveAmp * (fi / 26);
                    ctx.lineTo(fx, fy);
                }
                ctx.closePath();
                ctx.fill();

                // Flag highlight
                ctx.globalAlpha = 0.3;
                ctx.fillStyle = '#aaffc0';
                ctx.beginPath();
                ctx.moveTo(flag.x + 12, flag.y + 2);
                for (let fi = 0; fi <= 26; fi++) {
                    const fx = flag.x + 12 + fi;
                    const fy = flag.y + 2 + Math.sin(waveFreq + fi * 0.3) * waveAmp * (fi / 26);
                    ctx.lineTo(fx, fy);
                }
                ctx.lineTo(flag.x + 12, flag.y + 8);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
            }

            // --- 13. 3D SPINNING COINS ---
            coins.forEach(coin => {
                if (!coin.collected) {
                    const bob = Math.sin(t * 2 + coin.bobOffset) * 2.5;
                    const cx = coin.x + 10, cy = coin.y + 10 + bob;
                    const spinAngle = t * 3 + coin.bobOffset;
                    const scaleX = Math.abs(Math.cos(spinAngle));

                    // Outer glow
                    const coinGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 16);
                    coinGlow.addColorStop(0, 'rgba(255,215,0,0.4)');
                    coinGlow.addColorStop(1, 'rgba(255,215,0,0)');
                    ctx.fillStyle = coinGlow;
                    ctx.beginPath(); ctx.arc(cx, cy, 16, 0, Math.PI * 2); ctx.fill();

                    // Coin body (squished for 3D effect)
                    ctx.save();
                    ctx.translate(cx, cy);
                    ctx.scale(Math.max(0.1, scaleX), 1);
                    const cGrad = ctx.createRadialGradient(-3, -3, 1, 0, 0, 9);
                    cGrad.addColorStop(0, '#fffacc');
                    cGrad.addColorStop(0.4, '#ffd700');
                    cGrad.addColorStop(1, '#b8860b');
                    ctx.fillStyle = cGrad;
                    ctx.beginPath(); ctx.arc(0, 0, 9, 0, Math.PI * 2); ctx.fill();
                    // Edge highlight
                    ctx.strokeStyle = '#ffe87a';
                    ctx.lineWidth = 1.5;
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath(); ctx.arc(0, 0, 7, -Math.PI * 0.7, Math.PI * 0.1); ctx.stroke();
                    ctx.globalAlpha = 1;
                    ctx.restore();

                    // Sparkle
                    if (Math.sin(t * 5 + coin.bobOffset * 2) > 0.7) {
                        ctx.fillStyle = 'white';
                        ctx.globalAlpha = 0.9;
                        for (let si = 0; si < 4; si++) {
                            const sa = (si / 4) * Math.PI * 2 + t * 4;
                            const sd = 11;
                            ctx.beginPath(); ctx.arc(cx + Math.cos(sa) * sd, cy + Math.sin(sa) * sd, 1.5, 0, Math.PI * 2); ctx.fill();
                        }
                        ctx.globalAlpha = 1;
                    }
                }
            });

            // --- 14. BETTER DRONES ---
            drones.forEach(drone => {
                const dc = drone.x + drone.width / 2, dy = drone.y + drone.height / 2;

                // Searchlight cone
                ctx.globalAlpha = 0.12;
                const lightGrad = ctx.createLinearGradient(dc, drone.y + drone.height, dc, drone.y + drone.height + 120);
                lightGrad.addColorStop(0, '#ffffaa');
                lightGrad.addColorStop(1, 'rgba(255,255,100,0)');
                ctx.fillStyle = lightGrad;
                ctx.beginPath();
                ctx.moveTo(dc - 8, drone.y + drone.height);
                ctx.lineTo(dc - 55, drone.y + drone.height + 120);
                ctx.lineTo(dc + 55, drone.y + drone.height + 120);
                ctx.lineTo(dc + 8, drone.y + drone.height);
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;

                // Engine glow
                ctx.globalAlpha = 0.35;
                const engGlow = ctx.createRadialGradient(dc, drone.y, 0, dc, drone.y, 30);
                engGlow.addColorStop(0, '#66aaff');
                engGlow.addColorStop(1, 'rgba(100,150,255,0)');
                ctx.fillStyle = engGlow;
                ctx.beginPath(); ctx.arc(dc, drone.y, 30, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;

                // Body
                const bodyGrad = ctx.createLinearGradient(drone.x, drone.y, drone.x, drone.y + drone.height);
                bodyGrad.addColorStop(0, '#5a6575');
                bodyGrad.addColorStop(1, '#2a3040');
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.roundRect(drone.x, drone.y, drone.width, drone.height, 4);
                ctx.fill();

                // Body highlight
                ctx.fillStyle = 'rgba(150,180,220,0.25)';
                ctx.fillRect(drone.x + 2, drone.y + 2, drone.width - 4, 4);

                // Cockpit
                ctx.fillStyle = '#0a1520';
                ctx.beginPath();
                ctx.ellipse(drone.x + drone.width / 2, drone.y + drone.height / 2, 10, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'rgba(100,200,255,0.5)';
                ctx.beginPath();
                ctx.ellipse(drone.x + drone.width / 2 - 2, drone.y + drone.height / 2 - 1, 5, 3, -0.3, 0, Math.PI * 2);
                ctx.fill();

                // Propellers
                const propAngle = t * 18;
                [drone.x + 6, drone.x + drone.width - 6].forEach((px, idx) => {
                    ctx.save();
                    ctx.translate(px, drone.y - 2);
                    ctx.rotate(idx === 0 ? propAngle : -propAngle);
                    ctx.globalAlpha = 0.75;
                    ctx.fillStyle = '#8090a8';
                    ctx.fillRect(-9, -1.5, 18, 3);
                    ctx.restore();
                });

                // Exhaust particles
                if (globalTime % 3 === 0) {
                    particles.push({ x: dc + (Math.random() - 0.5) * 10, y: drone.y - 3, vx: (Math.random() - 0.5) * 1.5, vy: -0.8 - Math.random(), life: 0.6, color: '#88aaff', size: 2 });
                }

                // Warning light
                const warn = drone.fireTimer < 20;
                const blink = Math.sin(t * (warn ? 15 : 4)) > 0;
                ctx.fillStyle = warn ? '#ff3030' : (blink ? '#ef4444' : '#991b1b');
                ctx.globalAlpha = warn ? (0.7 + Math.sin(t * 20) * 0.3) : 1;
                ctx.beginPath();
                ctx.arc(dc, drone.y + drone.height - 3, warn ? 5 : 3.5, 0, Math.PI * 2);
                ctx.fill();
                if (warn) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#ff8888';
                    ctx.beginPath(); ctx.arc(dc, drone.y + drone.height - 3, 9, 0, Math.PI * 2); ctx.fill();
                }
                ctx.globalAlpha = 1;
            });

            // --- 15. LASERS WITH BLOOM ---
            lasers.forEach(laser => {
                const lx = laser.x, ly = laser.y;
                const lx2 = laser.x - laser.vx * 3, ly2 = laser.y - laser.vy * 3;

                // Wide bloom
                ctx.globalAlpha = 0.15;
                ctx.strokeStyle = '#ffaaaa';
                ctx.lineWidth = 14;
                ctx.lineCap = 'round';
                ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx2, ly2); ctx.stroke();

                // Mid glow
                ctx.globalAlpha = 0.35;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 6;
                ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx2, ly2); ctx.stroke();

                // Core
                ctx.globalAlpha = 1;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(lx, ly); ctx.lineTo(lx2, ly2); ctx.stroke();

                // Head dot
                ctx.fillStyle = '#ffeeee';
                ctx.beginPath(); ctx.arc(lx, ly, 3, 0, Math.PI * 2); ctx.fill();
            });
            ctx.lineWidth = 1; ctx.globalAlpha = 1; ctx.lineCap = 'butt';

            // --- 16. PLAYER TRAIL ---
            playerTrail.forEach((tr, i) => {
                ctx.globalAlpha = tr.life * 0.35;
                ctx.fillStyle = invincible > 0 ? '#aaddff' : '#ff8833';
                ctx.beginPath();
                ctx.arc(tr.x, tr.y, tr.size * tr.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // --- 17. PLAYER ---
            if (invincible <= 0 || Math.floor(invincible / 5) % 2 === 0) {
                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y);
                ctx.scale(player.facing, 1);
                ctx.translate(-player.width / 2, 0);

                // Subtle glow
                ctx.globalAlpha = 0.2;
                const plGlow = ctx.createRadialGradient(15, 18, 2, 15, 18, 20);
                plGlow.addColorStop(0, invincible > 0 ? '#88ccff' : '#ff8833');
                plGlow.addColorStop(1, 'rgba(255,120,0,0)');
                ctx.fillStyle = plGlow;
                ctx.beginPath(); ctx.arc(15, 18, 20, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;

                // Body
                ctx.fillStyle = colors.player;
                ctx.fillRect(5, 10, 20, 22);
                // Body gradient highlight
                ctx.fillStyle = 'rgba(255,180,100,0.3)';
                ctx.fillRect(6, 11, 8, 10);

                // Head
                ctx.fillStyle = colors.player;
                ctx.beginPath();
                ctx.arc(15, 10, 9, 0, Math.PI * 2);
                ctx.fill();

                // Eye white
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(18, 8, 3.5, 0, Math.PI * 2);
                ctx.fill();
                // Pupil
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.arc(19, 8, 1.8, 0, Math.PI * 2);
                ctx.fill();
                // Eye shine
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(20, 7, 0.8, 0, Math.PI * 2);
                ctx.fill();

                // Legs
                ctx.fillStyle = colors.playerDark;
                const leg = Math.sin(player.animFrame) * 3;
                ctx.fillRect(7, 30, 5, 6 + (player.onGround ? leg : 0));
                ctx.fillRect(18, 30, 5, 6 + (player.onGround ? -leg : 0));

                ctx.restore();
            }

            // --- 18. GAME PARTICLES ---
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, Math.max(0.1, p.size * p.life), 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // (vignette removed for clarity)

            ctx.restore(); // end screen shake

            // --- TUTORIAL OVERLAYS ---
            drawTutorials();
        }

        let lastFrameTime = 0;
        let accumulator = 0;
        const FIXED_STEP = 16.667;

        function gameLoop(timestamp) {
            if (!lastFrameTime) lastFrameTime = timestamp;
            let elapsed = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            if (elapsed > 100) elapsed = 100;
            accumulator += elapsed;
            while (accumulator >= FIXED_STEP) {
                update(1);
                accumulator -= FIXED_STEP;
            }
            draw();
            requestAnimationFrame(gameLoop);
        }

        document.addEventListener('keydown', e => {
            if (tutorialPaused) {
                if (e.code === 'Space' || e.code === 'Enter' || e.code === 'ArrowRight') nextTutorial();
                if (e.code === 'Escape') dismissTutorials();
                e.preventDefault();
                return;
            }
            keys[e.code] = true;
            if (e.code === 'KeyR') restart();
            if (['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code)) e.preventDefault();
        });
        document.addEventListener('keyup', e => { keys[e.code] = false; });

        // Touch controls for mobile
        let touchStartX = null, touchStartY = null, touchActive = false;
        const DRAG_THRESHOLD = 15;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (tutorialPaused) { nextTutorial(); return; }
            const t = e.touches[0];
            touchStartX = t.clientX;
            touchStartY = t.clientY;
            touchActive = true;
            // Tap jumps immediately
            keys['Space'] = true;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!touchActive || touchStartX === null) return;
            const t = e.touches[0];
            const dx = t.clientX - touchStartX;
            const dy = t.clientY - touchStartY;

            // Horizontal movement
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            if (dx < -DRAG_THRESHOLD) keys['ArrowLeft'] = true;
            else if (dx > DRAG_THRESHOLD) keys['ArrowRight'] = true;

            // Swipe up to jump
            if (dy < -DRAG_THRESHOLD) keys['Space'] = true;
            else keys['Space'] = false;
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchActive = false;
            touchStartX = null;
            touchStartY = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            keys['Space'] = false;
        }, { passive: false });

        // Mouse drag controls (desktop)
        canvas.addEventListener('mousedown', (e) => {
            if (tutorialPaused) { nextTutorial(); return; }
            touchStartX = e.clientX;
            touchStartY = e.clientY;
            touchActive = true;
            keys['Space'] = true;
        });

        document.addEventListener('mousemove', (e) => {
            if (!touchActive || touchStartX === null) return;
            const dx = e.clientX - touchStartX;
            const dy = e.clientY - touchStartY;

            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            if (dx < -DRAG_THRESHOLD) keys['ArrowLeft'] = true;
            else if (dx > DRAG_THRESHOLD) keys['ArrowRight'] = true;

            if (dy < -DRAG_THRESHOLD) keys['Space'] = true;
            else keys['Space'] = false;
        });

        document.addEventListener('mouseup', () => {
            if (!touchActive) return;
            touchActive = false;
            touchStartX = null;
            touchStartY = null;
            keys['ArrowLeft'] = false;
            keys['ArrowRight'] = false;
            keys['Space'] = false;
        });

        canvas.addEventListener('click', (e) => {
            if (tutorialPaused) {
                var rect = canvas.getBoundingClientRect();
                var mx = e.clientX - rect.left, my = e.clientY - rect.top;
                // Check skip button
                if (drawTutorials._skipX >= 0 &&
                    mx >= drawTutorials._skipX && mx <= drawTutorials._skipX + drawTutorials._skipW &&
                    my >= drawTutorials._skipY && my <= drawTutorials._skipY + drawTutorials._skipH) {
                    dismissTutorials();
                } else {
                    nextTutorial();
                }
            }
        });

        initVisuals();
        initClouds();
        generateLevel(1);
        showLevelTutorials();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
